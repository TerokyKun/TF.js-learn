/**
    * @license
    * Copyright 2023 Google LLC. All Rights Reserved.
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    * http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    * =============================================================================
    */
import{Pose as e}from"@mediapipe/pose";import{Tensor as t,browser as n,util as r,tidy as i,add as s,mul as o,tensor2d as a,image as u,expandDims as l,cast as h,slice as c,squeeze as d,dispose as p,tensor1d as f,getBackend as m,engine as g,sub as x,square as y,minimum as b,backend as w,div as v,exp as k,concat as S,reshape as I,clipByValue as C,sigmoid as R,pad as T,mirrorPad as $,env as A,zeros as P,backend_util as z,KernelBackend as N,DataStorage as M,buffer as F,registerBackend as E,Fill as _,Reshape as O,broadcast_util as B,_FusedMatMul as L,Identity as D,Complex as U,upcastType as W,broadcastTo as V,slice_util as G,TensorBuffer as H,Abs as K,Acos as X,Acosh as q,Add as j,AddN as Y,Transpose as Q,sumOutType as Z,All as J,Any as ee,ArgMax as te,ArgMin as ne,Asin as re,Asinh as ie,Atan as se,Atan2 as oe,Atanh as ae,Max as ue,Mean as le,AvgPool as he,AvgPoolGrad as ce,BatchMatMul as de,Slice as pe,BatchToSpaceND as fe,Bincount as me,NotEqual as ge,Real as xe,Cast as ye,Ceil as be,ClipByValue as we,Imag as ve,Concat as ke,Conv2D as Se,Conv2DBackpropFilter as Ie,Conv2DBackpropInput as Ce,Cos as Re,Cosh as Te,CropAndResize as $e,Cumprod as Ae,Cumsum as Pe,DenseBincount as ze,DepthToSpace as Ne,DepthwiseConv2dNative as Me,Diag as Fe,Dilation2D as Ee,Multiply as _e,Sum as Oe,Einsum as Be,Elu as Le,Equal as De,Erf as Ue,Exp as We,ExpandDims as Ve,Expm1 as Ge,FFT as He,FlipLeftRight as Ke,Floor as Xe,FloorDiv as qe,FromPixels as je,FusedBatchNorm as Ye,FusedConv2D as Qe,FusedDepthwiseConv2D as Ze,GatherNd as Je,GatherV2 as et,Greater as tt,GreaterEqual as nt,IFFT as rt,IsFinite as it,IsInf as st,IsNan as ot,LeakyRelu as at,Less as ut,LessEqual as lt,LinSpace as ht,Log as ct,Log1p as dt,LogicalAnd as pt,LogicalNot as ft,LogicalOr as mt,LRN as gt,Maximum as xt,MaxPool as yt,Min as bt,Minimum as wt,MirrorPad as vt,Mod as kt,Neg as St,NonMaxSuppressionV3 as It,kernel_impls as Ct,NonMaxSuppressionV5 as Rt,OneHot as Tt,ZerosLike as $t,OnesLike as At,Pack as Pt,PadV2 as zt,Pow as Nt,Prelu as Mt,Prod as Ft,Range as Et,RealDiv as _t,Reciprocal as Ot,Relu as Bt,Relu6 as Lt,ResizeBilinear as Dt,ResizeNearestNeighbor as Ut,Reverse as Wt,RotateWithOffset as Vt,Round as Gt,Rsqrt as Ht,ScatterNd as Kt,SearchSorted as Xt,Select as qt,Selu as jt,Sigmoid as Yt,Sign as Qt,Sin as Zt,Sinh as Jt,Sub as en,Softmax as tn,Softplus as nn,SpaceToBatchND as rn,Tile as sn,SparseToDense as on,SplitV as an,Sqrt as un,Square as ln,SquaredDifference as hn,Step as cn,StridedSlice as dn,StringNGrams as pn,Tan as fn,Tanh as mn,TopK as gn,Transform as xn,Unpack as yn,registerKernel as bn,scalar as wn,argMax as vn}from"@tensorflow/tfjs-core";import{loadGraphModel as kn}from"@tensorflow/tfjs-converter";var Sn=function(e,t){return(Sn=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n])})(e,t)};function In(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Class extends value "+String(t)+" is not a constructor or null");function n(){this.constructor=e}Sn(e,t),e.prototype=null===t?Object.create(t):(n.prototype=t.prototype,new n)}var Cn=function(){return(Cn=Object.assign||function(e){for(var t,n=1,r=arguments.length;n<r;n++)for(var i in t=arguments[n])Object.prototype.hasOwnProperty.call(t,i)&&(e[i]=t[i]);return e}).apply(this,arguments)};function Rn(e,t,n,r){return new(n||(n=Promise))((function(i,s){function o(e){try{u(r.next(e))}catch(e){s(e)}}function a(e){try{u(r.throw(e))}catch(e){s(e)}}function u(e){var t;e.done?i(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(o,a)}u((r=r.apply(e,t||[])).next())}))}function Tn(e,t){var n,r,i,s,o={label:0,sent:function(){if(1&i[0])throw i[1];return i[1]},trys:[],ops:[]};return s={next:a(0),throw:a(1),return:a(2)},"function"==typeof Symbol&&(s[Symbol.iterator]=function(){return this}),s;function a(s){return function(a){return function(s){if(n)throw new TypeError("Generator is already executing.");for(;o;)try{if(n=1,r&&(i=2&s[0]?r.return:s[0]?r.throw||((i=r.return)&&i.call(r),0):r.next)&&!(i=i.call(r,s[1])).done)return i;switch(r=0,i&&(s=[2&s[0],i.value]),s[0]){case 0:case 1:i=s;break;case 4:return o.label++,{value:s[1],done:!1};case 5:o.label++,r=s[1],s=[0];continue;case 7:s=o.ops.pop(),o.trys.pop();continue;default:if(!(i=o.trys,(i=i.length>0&&i[i.length-1])||6!==s[0]&&2!==s[0])){o=0;continue}if(3===s[0]&&(!i||s[1]>i[0]&&s[1]<i[3])){o.label=s[1];break}if(6===s[0]&&o.label<i[1]){o.label=i[1],i=s;break}if(i&&o.label<i[2]){o.label=i[2],o.ops.push(s);break}i[2]&&o.ops.pop(),o.trys.pop();continue}s=t.call(e,o)}catch(e){s=[6,e],r=0}finally{n=i=0}if(5&s[0])throw s[1];return{value:s[0]?s[1]:void 0,done:!0}}([s,a])}}}function $n(e,t,n){if(n||2===arguments.length)for(var r,i=0,s=t.length;i<s;i++)!r&&i in t||(r||(r=Array.prototype.slice.call(t,0,i)),r[i]=t[i]);return e.concat(r||Array.prototype.slice.call(t))}var An=["nose","left_eye","right_eye","left_ear","right_ear","left_shoulder","right_shoulder","left_elbow","right_elbow","left_wrist","right_wrist","left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle"],Pn=["nose","left_eye_inner","left_eye","left_eye_outer","right_eye_inner","right_eye","right_eye_outer","left_ear","right_ear","mouth_left","mouth_right","left_shoulder","right_shoulder","left_elbow","right_elbow","left_wrist","right_wrist","left_pinky","right_pinky","left_index","right_index","left_thumb","right_thumb","left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle","left_heel","right_heel","left_foot_index","right_foot_index"],zn={left:[1,2,3,7,9,11,13,15,17,19,21,23,25,27,29,31],right:[4,5,6,8,10,12,14,16,18,20,22,24,26,28,30,32],middle:[0]},Nn={left:[1,3,5,7,9,11,13,15],right:[2,4,6,8,10,12,14,16],middle:[0]},Mn=[[0,1],[0,2],[1,3],[2,4],[5,6],[5,7],[5,11],[6,8],[6,12],[7,9],[8,10],[11,12],[11,13],[12,14],[13,15],[14,16]],Fn=[[0,1],[0,4],[1,2],[2,3],[3,7],[4,5],[5,6],[6,8],[9,10],[11,12],[11,13],[11,23],[12,14],[14,16],[12,24],[13,15],[15,17],[16,18],[16,20],[15,17],[15,19],[15,21],[16,22],[17,19],[18,20],[23,25],[23,24],[24,26],[25,27],[26,28],[27,29],[28,30],[27,31],[28,32],[29,31],[30,32]];function En(e){return e instanceof SVGAnimatedLength?e.baseVal.value:e}function _n(e){return Rn(this,void 0,void 0,(function(){var r,i;return Tn(this,(function(s){switch(s.label){case 0:return r=document.createElement("canvas"),e instanceof t?[4,n.toPixels(e,r)]:[3,2];case 1:return s.sent(),[3,3];case 2:r.width=En(e.width),r.height=En(e.height),i=r.getContext("2d"),e instanceof ImageData?i.putImageData(e,0,0):i.drawImage(e,0,0),s.label=3;case 3:return[2,r]}}))}))}function On(e){return Rn(this,void 0,void 0,(function(){var r,i,s,o,a,u;return Tn(this,(function(l){switch(l.label){case 0:return e instanceof t?(r=e.shape.slice(0,2),i=r[0],s=r[1],o=ImageData.bind,[4,n.toPixels(e)]):[3,2];case 1:return[2,new(o.apply(ImageData,[void 0,l.sent(),s,i]))];case 2:return a=document.createElement("canvas"),u=a.getContext("2d"),a.width=En(e.width),a.height=En(e.height),u.drawImage(e,0,0),[2,u.getImageData(0,0,a.width,a.height)]}}))}))}function Bn(e){return Rn(this,void 0,void 0,(function(){var t,r;return Tn(this,(function(i){switch(i.label){case 0:return e instanceof SVGImageElement||e instanceof OffscreenCanvas?[4,_n(e)]:[3,2];case 1:return r=i.sent(),[3,3];case 2:r=e,i.label=3;case 3:return t=r,[2,n.fromPixels(t,4)]}}))}))}function Ln(e){if(e<0||e>=256)throw new Error("Mask value must be in range [0, 255] but got ".concat(e));if(!Number.isInteger(e))throw new Error("Mask value must be an integer but got ".concat(e))}var Dn={runtime:"mediapipe",enableSmoothing:!0,enableSegmentation:!1,smoothSegmentation:!0,modelType:"full"};var Un=function(){function e(e){this.mask=e}return e.prototype.toCanvasImageSource=function(){return Rn(this,void 0,void 0,(function(){return Tn(this,(function(e){return[2,this.mask]}))}))},e.prototype.toImageData=function(){return Rn(this,void 0,void 0,(function(){return Tn(this,(function(e){return[2,On(this.mask)]}))}))},e.prototype.toTensor=function(){return Rn(this,void 0,void 0,(function(){return Tn(this,(function(e){return[2,Bn(this.mask)]}))}))},e.prototype.getUnderlyingType=function(){return"canvasimagesource"},e}();function Wn(e){return Ln(e),"person"}var Vn=function(){function r(t){var n,r=this;switch(this.width=0,this.height=0,this.selfieMode=!1,this.poseSolution=new e({locateFile:function(e,n){if(t.solutionPath){var r=t.solutionPath.replace(/\/+$/,"");return"".concat(r,"/").concat(e)}return"".concat(n,"/").concat(e)}}),t.modelType){case"lite":n=0;break;case"heavy":n=2;break;case"full":default:n=1}this.poseSolution.setOptions({modelComplexity:n,smoothLandmarks:t.enableSmoothing,enableSegmentation:t.enableSegmentation,smoothSegmentation:t.smoothSegmentation,selfieMode:this.selfieMode}),this.poseSolution.onResults((function(e){if(r.height=e.image.height,r.width=e.image.width,null==e.poseLandmarks)r.poses=[];else{var t=r.translateOutput(e.poseLandmarks,e.poseWorldLandmarks);e.segmentationMask&&(t.segmentation={maskValueToLabel:Wn,mask:new Un(e.segmentationMask)}),r.poses=[t]}}))}return r.prototype.translateOutput=function(e,t){var n=this,r={keypoints:e.map((function(e,t){return{x:e.x*n.width,y:e.y*n.height,z:e.z,score:e.visibility,name:Pn[t]}}))};return null!=t&&(r.keypoints3D=t.map((function(e,t){return{x:e.x,y:e.y,z:e.z,score:e.visibility,name:Pn[t]}}))),r},r.prototype.estimatePoses=function(e,r,i){return Rn(this,void 0,void 0,(function(){var s,o;return Tn(this,(function(a){switch(a.label){case 0:return r&&r.flipHorizontal&&r.flipHorizontal!==this.selfieMode&&(this.selfieMode=r.flipHorizontal,this.poseSolution.setOptions({selfieMode:this.selfieMode})),e instanceof t?(o=ImageData.bind,[4,n.toPixels(e)]):[3,2];case 1:return s=new(o.apply(ImageData,[void 0,a.sent(),e.shape[1],e.shape[0]])),[3,3];case 2:s=e,a.label=3;case 3:return e=s,[4,this.poseSolution.send({image:e},i)];case 4:return a.sent(),[2,this.poses]}}))}))},r.prototype.dispose=function(){this.poseSolution.close()},r.prototype.reset=function(){this.poseSolution.reset()},r.prototype.initialize=function(){return this.poseSolution.initialize()},r}();function Gn(e){return Rn(this,void 0,void 0,(function(){var t,n;return Tn(this,(function(r){switch(r.label){case 0:return t=function(e){if(null==e)return Cn({},Dn);var t=Cn({},e);return t.runtime="mediapipe",null==t.enableSegmentation&&(t.enableSegmentation=Dn.enableSegmentation),null==t.enableSmoothing&&(t.enableSmoothing=Dn.enableSmoothing),null==t.smoothSegmentation&&(t.smoothSegmentation=Dn.smoothSegmentation),null==t.modelType&&(t.modelType=Dn.modelType),t}(e),[4,(n=new Vn(t)).initialize()];case 1:return r.sent(),[2,n]}}))}))}function Hn(e){return e instanceof t?{height:e.shape[0],width:e.shape[1]}:{height:e.height,width:e.width}}function Kn(e){return e-2*Math.PI*Math.floor((e+Math.PI)/(2*Math.PI))}function Xn(e){return e instanceof t?e:n.fromPixels(e)}function qn(e,t,n){return jn(n,"inputResolution"),[1/n.width*e[0][0]*t.width,1/n.height*e[0][1]*t.width,e[0][3]*t.width,1/n.width*e[1][0]*t.height,1/n.height*e[1][1]*t.height,e[1][3]*t.height,0,0]}function jn(e,t){r.assert(0!==e.width,(function(){return"".concat(t," width cannot be 0.")})),r.assert(0!==e.height,(function(){return"".concat(t," height cannot be 0.")}))}function Yn(e,t,n){var r=n.rotationVectorStartKeypointIndex,i=n.rotationVectorEndKeypointIndex,s=e.locationData,o=s.relativeKeypoints[r].x*t.width,a=s.relativeKeypoints[r].y*t.height,u=s.relativeKeypoints[i].x*t.width,l=s.relativeKeypoints[i].y*t.height,h=2*Math.sqrt((u-o)*(u-o)+(l-a)*(l-a)),c=function(e,t,n){var r,i=e.locationData,s=n.rotationVectorStartKeypointIndex,o=n.rotationVectorEndKeypointIndex;r=n.rotationVectorTargetAngle?n.rotationVectorTargetAngle:Math.PI*n.rotationVectorTargetAngleDegree/180;var a=i.relativeKeypoints[s].x*t.width,u=i.relativeKeypoints[s].y*t.height,l=i.relativeKeypoints[o].x*t.width,h=i.relativeKeypoints[o].y*t.height;return Kn(r-Math.atan2(-(h-u),l-a))}(e,t,n);return{xCenter:o/t.width,yCenter:a/t.height,width:h/t.width,height:h/t.height,rotation:c}}function Qn(e){if(16!==e.length)throw new Error("Array length must be 16 but got ".concat(e.length));return[[e[0],e[1],e[2],e[3]],[e[4],e[5],e[6],e[7]],[e[8],e[9],e[10],e[11]],[e[12],e[13],e[14],e[15]]]}function Zn(e,t,n,r,i,s,o){return e[t][i]*(e[n][s]*e[r][o]-e[n][o]*e[r][s])}function Jn(e,t,n){var r=(t+1)%4,i=(t+2)%4,s=(t+3)%4,o=(n+1)%4,a=(n+2)%4,u=(n+3)%4;return Zn(e,r,i,s,o,a,u)+Zn(e,i,s,r,o,a,u)+Zn(e,s,r,i,o,a,u)}function er(e,t,n){void 0===n&&(n={ignoreRotation:!1});for(var r=[],i=0,s=e;i<s.length;i++){var o=s[i],a=o.x-.5,u=o.y-.5,l=n.ignoreRotation?0:t.rotation,h=Math.cos(l)*a-Math.sin(l)*u,c=Math.sin(l)*a+Math.cos(l)*u;h=h*t.width+t.xCenter,c=c*t.height+t.yCenter;var d=o.z*t.width,p=Cn({},o);p.x=h,p.y=c,p.z=d,r.push(p)}return r}function tr(e,t){var n=function(e,t,n,r){var i=t-e,s=r-n;if(0===i)throw new Error("Original min and max are both ".concat(e,", range cannot be 0."));var o=s/i;return{scale:o,offset:n-e*o}}(0,255,t[0],t[1]);return i((function(){return s(o(e,n.scale),n.offset)}))}function nr(e,t,n){var r,s,o,c,d,p,f,m,g,x,y,b,w,v,k=t.outputTensorSize,S=t.keepAspectRatio,I=t.borderMode,C=t.outputTensorFloatRange,R=Hn(e),T=function(e,t){return t?{xCenter:t.xCenter*e.width,yCenter:t.yCenter*e.height,width:t.width*e.width,height:t.height*e.height,rotation:t.rotation}:{xCenter:.5*e.width,yCenter:.5*e.height,width:e.width,height:e.height,rotation:0}}(R,n),$=function(e,t,n){if(void 0===n&&(n=!1),!n)return{top:0,left:0,right:0,bottom:0};var r=t.height,i=t.width;jn(t,"targetSize"),jn(e,"roi");var s,o,a=r/i,u=e.height/e.width,l=0,h=0;return a>u?(s=e.width,o=e.width*a,h=(1-u/a)/2):(s=e.height/a,o=e.height,l=(1-a/u)/2),e.width=s,e.height=o,{top:h,left:l,right:l,bottom:h}}(T,k,S),A=(r=T,s=R.width,o=R.height,c=!1,d=r.width,p=r.height,f=c?-1:1,m=Math.cos(r.rotation),g=Math.sin(r.rotation),x=r.xCenter,y=r.yCenter,b=1/s,w=1/o,(v=new Array(16))[0]=d*m*f*b,v[1]=-p*g*b,v[2]=0,v[3]=(-.5*d*m*f+.5*p*g+x)*b,v[4]=d*g*f*w,v[5]=p*m*w,v[6]=0,v[7]=(-.5*p*m-.5*d*g*f+y)*w,v[8]=0,v[9]=0,v[10]=d*b,v[11]=0,v[12]=0,v[13]=0,v[14]=0,v[15]=1,Qn(v));return{imageTensor:i((function(){var t=Xn(e),n=a(qn(A,R,k),[1,8]),r="zero"===I?"constant":"nearest",i=u.transform(l(h(t,"float32")),n,"bilinear",r,0,[k.height,k.width]);return null!=C?tr(i,C):i})),padding:$,transformationMatrix:A}}function rr(e,t,n,r){return 1===r?.5*(e+t):e+(t-e)*n/(r-1)}function ir(e){return i((function(){var t=function(e){return i((function(){return[c(e,[0,0,0],[1,-1,1]),c(e,[0,0,1],[1,-1,-1])]}))}(e),n=t[0],r=t[1];return{boxes:d(r),logits:d(n)}}))}function sr(e){return null!=e&&null!=e.currentTime}function or(e){for(var t={locationData:{relativeKeypoints:[]}},n=Number.MAX_SAFE_INTEGER,r=Number.MIN_SAFE_INTEGER,i=Number.MAX_SAFE_INTEGER,s=Number.MIN_SAFE_INTEGER,o=0;o<e.length;++o){var a=e[o];n=Math.min(n,a.x),r=Math.max(r,a.x),i=Math.min(i,a.y),s=Math.max(s,a.y),t.locationData.relativeKeypoints.push({x:a.x,y:a.y})}return t.locationData.relativeBoundingBox={xMin:n,yMin:i,xMax:r,yMax:s,width:r-n,height:s-i},t}function ar(e,t,n,r){return Rn(this,void 0,void 0,(function(){var r,i,s,o,l;return Tn(this,(function(h){switch(h.label){case 0:return e.sort((function(e,t){return Math.max.apply(Math,t.score)-Math.max.apply(Math,e.score)})),r=a(e.map((function(e){return[e.locationData.relativeBoundingBox.yMin,e.locationData.relativeBoundingBox.xMin,e.locationData.relativeBoundingBox.yMax,e.locationData.relativeBoundingBox.xMax]}))),i=f(e.map((function(e){return e.score[0]}))),[4,u.nonMaxSuppressionAsync(r,i,t,n)];case 1:return[4,(s=h.sent()).array()];case 2:return o=h.sent(),l=e.filter((function(e,t){return o.indexOf(t)>-1})),p([r,i,s]),[2,l]}}))}))}function ur(e,t){return e.map((function(e){var n=Cn(Cn({},e),{x:e.x*t.width,y:e.y*t.height});return null!=e.z&&(n.z=e.z*t.width),n}))}function lr(e,t,n){return Rn(this,void 0,void 0,(function(){var r,i,s,o,a,u,l,h,c,p,f,m,g,x,y,b,w,v,k,S,I,C,R,T;return Tn(this,(function($){switch($.label){case 0:if(r=d(t,[0]),i=r.shape,s=i[0],o=i[1],a=i[2],e.length!==a)throw new Error("Expected heatmap to have same number of channels as the number of landmarks. But got landmarks length: "+"".concat(e.length,", heatmap length: ").concat(a));return u=[],[4,r.buffer()];case 1:for(l=$.sent(),h=0;h<e.length;h++)if(c=e[h],p=Cn({},c),u.push(p),f=Math.trunc(p.x*o),m=Math.trunc(p.y*s),!(f<0||f>=o||m<0||f>=s)){for(g=Math.trunc((n.kernelSize-1)/2),x=Math.max(0,f-g),y=Math.min(o,f+g+1),b=Math.max(0,m-g),w=Math.min(s,m+g+1),v=0,k=0,S=0,I=0,C=b;C<w;++C)for(R=x;R<y;++R)T=l.get(C,R,h),v+=T,I=Math.max(I,T),k+=R*T,S+=C*T;I>=n.minConfidenceToRefine&&v>0&&(p.x=k/o/v,p.y=S/s/v)}return r.dispose(),[2,u]}}))}))}function hr(e,t){var n=t.left,r=t.top,i=t.left+t.right,s=t.top+t.bottom;return e.map((function(e){return Cn(Cn({},e),{x:(e.x-n)/(1-i),y:(e.y-r)/(1-s),z:e.z/(1-i)})}))}function cr(e,t,n){return"webgl"===m()?function(e,t,n){var r=n.combineWithPreviousRatio.toFixed(2),s={variableNames:["prevMask","newMask"],outputShape:e.shape,userCode:"\n  void main() {\n      ivec2 coords = getOutputCoords();\n      int height = coords[0];\n      int width = coords[1];\n\n      float prevMaskValue = getPrevMask(height, width);\n      float newMaskValue = getNewMask(height, width);\n\n      /*\n      * Assume p := newMaskValue\n      * H(p) := 1 + (p * log(p) + (1-p) * log(1-p)) / log(2)\n      * uncertainty alpha(p) =\n      *   Clamp(1 - (1 - H(p)) * (1 - H(p)), 0, 1) [squaring the\n      * uncertainty]\n      *\n      * The following polynomial approximates uncertainty alpha as a\n      * function of (p + 0.5):\n      */\n      const float c1 = 5.68842;\n      const float c2 = -0.748699;\n      const float c3 = -57.8051;\n      const float c4 = 291.309;\n      const float c5 = -624.717;\n      float t = newMaskValue - 0.5;\n      float x = t * t;\n\n      float uncertainty =\n        1.0 - min(1.0, x * (c1 + x * (c2 + x * (c3 + x * (c4 + x * c5)))));\n\n      float outputValue = newMaskValue + (prevMaskValue - newMaskValue) *\n                             (uncertainty * ".concat(r,");\n\n      setOutput(outputValue);\n    }\n")},o=w();return i((function(){var n=o.compileAndRun(s,[e,t]);return g().makeTensorFromDataId(n.dataId,n.shape,n.dtype)}))}(e,t,n):i((function(){var r=x(t,.5),i=y(r),a=x(1,b(1,o(i,s(5.68842,o(i,s(-.748699,o(i,s(-57.8051,o(i,s(291.309,o(i,-624.717)))))))))));return s(t,o(x(e,t),o(a,n.combineWithPreviousRatio)))}))}function dr(e,t,n){return Rn(this,void 0,void 0,(function(){var r,a,u,l,h;return Tn(this,(function(f){switch(f.label){case 0:return r=e[0],a=e[1],u=function(e,t,n){return i((function(){var r,i,a,u;n.reverseOutputOrder?(i=d(c(e,[0,n.boxCoordOffset+0],[-1,1])),r=d(c(e,[0,n.boxCoordOffset+1],[-1,1])),u=d(c(e,[0,n.boxCoordOffset+2],[-1,1])),a=d(c(e,[0,n.boxCoordOffset+3],[-1,1]))):(r=d(c(e,[0,n.boxCoordOffset+0],[-1,1])),i=d(c(e,[0,n.boxCoordOffset+1],[-1,1])),a=d(c(e,[0,n.boxCoordOffset+2],[-1,1])),u=d(c(e,[0,n.boxCoordOffset+3],[-1,1]))),i=s(o(v(i,n.xScale),t.w),t.x),r=s(o(v(r,n.yScale),t.h),t.y),n.applyExponentialOnBoxSize?(a=o(k(v(a,n.hScale)),t.h),u=o(k(v(u,n.wScale)),t.w)):(a=o(v(a,n.hScale),t.h),u=o(v(u,n.wScale),t.h));var l=x(r,v(a,2)),h=x(i,v(u,2)),p=s(r,v(a,2)),f=s(i,v(u,2)),m=S([I(l,[n.numBoxes,1]),I(h,[n.numBoxes,1]),I(p,[n.numBoxes,1]),I(f,[n.numBoxes,1])],1);if(n.numKeypoints)for(var g=0;g<n.numKeypoints;++g){var y=n.keypointCoordOffset+g*n.numValuesPerKeypoint,b=void 0,w=void 0;n.reverseOutputOrder?(b=d(c(e,[0,y],[-1,1])),w=d(c(e,[0,y+1],[-1,1]))):(w=d(c(e,[0,y],[-1,1])),b=d(c(e,[0,y+1],[-1,1])));var C=s(o(v(b,n.xScale),t.w),t.x),R=s(o(v(w,n.yScale),t.h),t.y);m=S([m,I(C,[n.numBoxes,1]),I(R,[n.numBoxes,1])],1)}return m}))}(a,t,n),l=i((function(){var e=r;return n.sigmoidScore?(null!=n.scoreClippingThresh&&(e=C(r,-n.scoreClippingThresh,n.scoreClippingThresh)),e=R(e)):e})),[4,pr(u,l,n)];case 1:return h=f.sent(),p([u,l]),[2,h]}}))}))}function pr(e,t,n){return Rn(this,void 0,void 0,(function(){var r,i,s,o,a,u,l,h,c,d,p,f;return Tn(this,(function(m){switch(m.label){case 0:return r=[],[4,e.data()];case 1:return i=m.sent(),[4,t.data()];case 2:for(s=m.sent(),o=0;o<n.numBoxes;++o)if(!(null!=n.minScoreThresh&&s[o]<n.minScoreThresh||(a=o*n.numCoords,u=fr(i[a+0],i[a+1],i[a+2],i[a+3],s[o],n.flipVertically,o),(l=u.locationData.relativeBoundingBox).width<0||l.height<0))){if(n.numKeypoints>0)for((h=u.locationData).relativeKeypoints=[],c=n.numKeypoints*n.numValuesPerKeypoint,d=0;d<c;d+=n.numValuesPerKeypoint)p=a+n.keypointCoordOffset+d,f={x:i[p+0],y:n.flipVertically?1-i[p+1]:i[p+1]},h.relativeKeypoints.push(f);r.push(u)}return[2,r]}}))}))}function fr(e,t,n,r,i,s,o){return{score:[i],ind:o,locationData:{relativeBoundingBox:{xMin:t,yMin:s?1-n:e,xMax:r,yMax:s?1-e:n,width:r-t,height:n-e}}}}function mr(e,t){return"none"===e?t:function(e){return 1/(1+Math.exp(-e))}(t)}function gr(e,t,n,r){return Rn(this,void 0,void 0,(function(){var i,s,o,a,u,l,h,c;return Tn(this,(function(d){switch(d.label){case 0:return n=n||t.flipHorizontally||!1,r=r||t.flipVertically||!1,i=e.size,s=i/t.numLandmarks,[4,e.data()];case 1:for(o=d.sent(),a=[],u=0;u<t.numLandmarks;++u)l=u*s,(c={x:0,y:0}).x=n?t.inputImageWidth-o[l]:o[l],s>1&&(c.y=r?t.inputImageHeight-o[l+1]:o[l+1]),s>2&&(c.z=o[l+2]),s>3&&(c.score=mr(t.visibilityActivation,o[l+3])),a.push(c);for(h=0;h<a.length;++h)(c=a[h]).x=c.x/t.inputImageWidth,c.y=c.y/t.inputImageHeight,c.z=c.z/t.inputImageWidth/(t.normalizeZ||1);return[2,a]}}))}))}function xr(e,t,n){var r=e.width,i=e.height,s=e.rotation;if(null==n.rotation&&null==n.rotationDegree||(s=function(e,t){null!=t.rotation?e+=t.rotation:null!=t.rotationDegree&&(e+=Math.PI*t.rotationDegree/180);return Kn(e)}(s,n)),0===s)e.xCenter=e.xCenter+r*n.shiftX,e.yCenter=e.yCenter+i*n.shiftY;else{var o=(t.width*r*n.shiftX*Math.cos(s)-t.height*i*n.shiftY*Math.sin(s))/t.width,a=(t.width*r*n.shiftX*Math.sin(s)+t.height*i*n.shiftY*Math.cos(s))/t.height;e.xCenter=e.xCenter+o,e.yCenter=e.yCenter+a}if(n.squareLong){var u=Math.max(r*t.width,i*t.height);r=u/t.width,i=u/t.height}else if(n.squareShort){var l=Math.min(r*t.width,i*t.height);r=l/t.width,i=l/t.height}return e.width=r*n.scaleX,e.height=i*n.scaleY,e}function yr(e,t){return e.map((function(e){var n=Cn(Cn({},e),{x:e.x/t.width,y:e.y/t.height});return null!=e.z&&(e.z=e.z/t.width),n}))}var br=function(){function e(e){this.alpha=e,this.initialized=!1}return e.prototype.apply=function(e,t){var n;return this.initialized?n=null==t?this.storedValue+this.alpha*(e-this.storedValue):this.storedValue+this.alpha*t*Math.asinh((e-this.storedValue)/t):(n=e,this.initialized=!0),this.rawValue=e,this.storedValue=n,n},e.prototype.applyWithAlpha=function(e,t,n){return this.alpha=t,this.apply(e,n)},e.prototype.hasLastRawValue=function(){return this.initialized},e.prototype.lastRawValue=function(){return this.rawValue},e.prototype.reset=function(){this.initialized=!1},e}(),wr=function(){function e(e){this.frequency=e.frequency,this.minCutOff=e.minCutOff,this.beta=e.beta,this.thresholdCutOff=e.thresholdCutOff,this.thresholdBeta=e.thresholdBeta,this.derivateCutOff=e.derivateCutOff,this.x=new br(this.getAlpha(this.minCutOff)),this.dx=new br(this.getAlpha(this.derivateCutOff)),this.lastTimestamp=0}return e.prototype.apply=function(e,t,n){if(null==e)return e;var r=Math.trunc(t);if(this.lastTimestamp>=r)return e;0!==this.lastTimestamp&&0!==r&&(this.frequency=1/(1e-6*(r-this.lastTimestamp))),this.lastTimestamp=r;var i=this.x.hasLastRawValue()?(e-this.x.lastRawValue())*n*this.frequency:0,s=this.dx.applyWithAlpha(i,this.getAlpha(this.derivateCutOff)),o=this.minCutOff+this.beta*Math.abs(s),a=null!=this.thresholdCutOff?this.thresholdCutOff+this.thresholdBeta*Math.abs(s):null;return this.x.applyWithAlpha(e,this.getAlpha(o),a)},e.prototype.getAlpha=function(e){return 1/(1+this.frequency/(2*Math.PI*e))},e}(),vr=function(){function e(e){this.config=e}return e.prototype.apply=function(e,t,n){var r=this;if(null==e)return this.reset(),null;this.initializeFiltersIfEmpty(e);var i=1;if(!this.config.disableValueScaling){if(n<this.config.minAllowedObjectScale)return $n([],e,!0);i=1/n}return e.map((function(e,n){var s=Cn(Cn({},e),{x:r.xFilters[n].apply(e.x,t,i),y:r.yFilters[n].apply(e.y,t,i)});return null!=e.z&&(s.z=r.zFilters[n].apply(e.z,t,i)),s}))},e.prototype.reset=function(){this.xFilters=null,this.yFilters=null,this.zFilters=null},e.prototype.initializeFiltersIfEmpty=function(e){var t=this;null!=this.xFilters&&this.xFilters.length===e.length||(this.xFilters=e.map((function(e){return new wr(t.config)})),this.yFilters=e.map((function(e){return new wr(t.config)})),this.zFilters=e.map((function(e){return new wr(t.config)})))},e}(),kr=function(){function e(e){this.config=e,this.window=[],this.lowPassFilter=new br(1),this.lastValue=0,this.lastValueScale=1,this.lastTimestamp=-1}return e.prototype.apply=function(e,t,n){if(null==e)return e;var r,i=Math.trunc(t);if(this.lastTimestamp>=i)return e;if(-1===this.lastTimestamp)r=1;else{for(var s=e*n-this.lastValue*this.lastValueScale,o=i-this.lastTimestamp,a=s,u=o,l=(1+this.window.length)*(1e6/30),h=0,c=this.window;h<c.length;h++){var d=c[h];if(u+d.duration>l)break;a+=d.distance,u+=d.duration}var p=a/(1e-6*u);r=1-1/(1+this.config.velocityScale*Math.abs(p)),this.window.unshift({distance:s,duration:o}),this.window.length>this.config.windowSize&&this.window.pop()}return this.lastValue=e,this.lastValueScale=n,this.lastTimestamp=i,this.lowPassFilter.applyWithAlpha(e,r)},e}(),Sr=function(){function e(e){this.config=e}return e.prototype.apply=function(e,t,n){var r=this;if(null==e)return this.reset(),null;var i=1;if(!this.config.disableValueScaling){if(n<this.config.minAllowedObjectScale)return $n([],e,!0);i=1/n}return this.initializeFiltersIfEmpty(e),e.map((function(e,n){var s=Cn(Cn({},e),{x:r.xFilters[n].apply(e.x,t,i),y:r.yFilters[n].apply(e.y,t,i)});return null!=e.z&&(s.z=r.zFilters[n].apply(e.z,t,i)),s}))},e.prototype.reset=function(){this.xFilters=null,this.yFilters=null,this.zFilters=null},e.prototype.initializeFiltersIfEmpty=function(e){var t=this;null!=this.xFilters&&this.xFilters.length===e.length||(this.xFilters=e.map((function(e){return new kr(t.config)})),this.yFilters=e.map((function(e){return new kr(t.config)})),this.zFilters=e.map((function(e){return new kr(t.config)})))},e}(),Ir=function(){function e(e){if(null!=e.velocityFilter)this.keypointsFilter=new Sr(e.velocityFilter);else{if(null==e.oneEuroFilter)throw new Error("Either configure velocityFilter or oneEuroFilter, but got "+"".concat(e,"."));this.keypointsFilter=new vr(e.oneEuroFilter)}}return e.prototype.apply=function(e,t,n,r,i){if(void 0===r&&(r=!1),null==e)return this.keypointsFilter.reset(),null;var s=null!=i?function(e,t){return(e.width*t.width+e.height*t.height)/2}(i,n):1,o=r?ur(e,n):e,a=this.keypointsFilter.apply(o,t,s);return r?yr(a,n):a},e}(),Cr=function(){function e(e){this.alpha=e.alpha}return e.prototype.apply=function(e){var t=this;if(null==e)return this.visibilityFilters=null,null;null!=this.visibilityFilters&&this.visibilityFilters.length===e.length||(this.visibilityFilters=e.map((function(e){return new br(t.alpha)})));for(var n=[],r=0;r<e.length;++r){var i=e[r],s=Cn({},i);s.score=this.visibilityFilters[r].apply(i.score),n.push(s)}return n},e}(),Rr={reduceBoxesInLowestlayer:!1,interpolatedScaleAspectRatio:1,featureMapHeight:[],featureMapWidth:[],numLayers:5,minScale:.1484375,maxScale:.75,inputSizeHeight:224,inputSizeWidth:224,anchorOffsetX:.5,anchorOffsetY:.5,strides:[8,16,32,32,32],aspectRatios:[1],fixedAnchorSize:!0},Tr={runtime:"tfjs",modelType:"full",enableSmoothing:!0,enableSegmentation:!1,smoothSegmentation:!0,detectorModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/detector/1",landmarkModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/full/2"},$r={maxPoses:1,flipHorizontal:!1},Ar={applyExponentialOnBoxSize:!1,flipVertically:!1,ignoreClasses:[],numClasses:1,numBoxes:2254,numCoords:12,boxCoordOffset:0,keypointCoordOffset:4,numKeypoints:4,numValuesPerKeypoint:2,sigmoidScore:!0,scoreClippingThresh:100,reverseOutputOrder:!0,xScale:224,yScale:224,hScale:224,wScale:224,minScoreThresh:.5},Pr=.3,zr={shiftX:0,shiftY:0,scaleX:1.25,scaleY:1.25,squareLong:!0},Nr={outputTensorSize:{width:224,height:224},keepAspectRatio:!0,outputTensorFloatRange:[-1,1],borderMode:"zero"},Mr={outputTensorSize:{width:256,height:256},keepAspectRatio:!0,outputTensorFloatRange:[0,1],borderMode:"zero"},Fr={numLandmarks:39,inputImageWidth:256,inputImageHeight:256,visibilityActivation:"sigmoid",flipHorizontally:!1,flipVertically:!1},Er={numLandmarks:39,inputImageWidth:1,inputImageHeight:1,visibilityActivation:"sigmoid",flipHorizontally:!1,flipVertically:!1},_r={kernelSize:7,minConfidenceToRefine:.5},Or={alpha:.1},Br={oneEuroFilter:{frequency:30,minCutOff:.05,beta:80,derivateCutOff:1,minAllowedObjectScale:1e-6}},Lr={oneEuroFilter:{frequency:30,minCutOff:.01,beta:10,derivateCutOff:1,minAllowedObjectScale:1e-6}},Dr={oneEuroFilter:{frequency:30,minCutOff:.1,beta:40,derivateCutOff:1,minAllowedObjectScale:1e-6,disableValueScaling:!0}},Ur={activation:"none"},Wr={combineWithPreviousRatio:.7};var Vr=function(){function e(e){this.mask=e}return e.prototype.toCanvasImageSource=function(){return Rn(this,void 0,void 0,(function(){return Tn(this,(function(e){return[2,_n(this.mask)]}))}))},e.prototype.toImageData=function(){return Rn(this,void 0,void 0,(function(){return Tn(this,(function(e){return[2,On(this.mask)]}))}))},e.prototype.toTensor=function(){return Rn(this,void 0,void 0,(function(){return Tn(this,(function(e){return[2,this.mask]}))}))},e.prototype.getUnderlyingType=function(){return"tensor"},e}();function Gr(e){return Ln(e),"person"}var Hr=function(){function e(e,t,n,r,i,s){this.detectorModel=e,this.landmarkModel=t,this.enableSmoothing=n,this.enableSegmentation=r,this.smoothSegmentation=i,this.modelType=s,this.regionOfInterest=null,this.prevFilteredSegmentationMask=null,this.anchors=function(e){null==e.reduceBoxesInLowestLayer&&(e.reduceBoxesInLowestLayer=!1),null==e.interpolatedScaleAspectRatio&&(e.interpolatedScaleAspectRatio=1),null==e.fixedAnchorSize&&(e.fixedAnchorSize=!1);for(var t=[],n=0;n<e.numLayers;){for(var r=[],i=[],s=[],o=[],a=n;a<e.strides.length&&e.strides[a]===e.strides[n];){var u=rr(e.minScale,e.maxScale,a,e.strides.length);if(0===a&&e.reduceBoxesInLowestLayer)s.push(1),s.push(2),s.push(.5),o.push(.1),o.push(u),o.push(u);else{for(var l=0;l<e.aspectRatios.length;++l)s.push(e.aspectRatios[l]),o.push(u);if(e.interpolatedScaleAspectRatio>0){var h=a===e.strides.length-1?1:rr(e.minScale,e.maxScale,a+1,e.strides.length);o.push(Math.sqrt(u*h)),s.push(e.interpolatedScaleAspectRatio)}}a++}for(var c=0;c<s.length;++c){var d=Math.sqrt(s[c]);r.push(o[c]/d),i.push(o[c]*d)}var p=0,f=0;if(e.featureMapHeight.length>0)p=e.featureMapHeight[n],f=e.featureMapWidth[n];else{var m=e.strides[n];p=Math.ceil(e.inputSizeHeight/m),f=Math.ceil(e.inputSizeWidth/m)}for(var g=0;g<p;++g)for(var x=0;x<f;++x)for(var y=0;y<r.length;++y){var b={xCenter:(x+e.anchorOffsetX)/f,yCenter:(g+e.anchorOffsetY)/p,width:0,height:0};e.fixedAnchorSize?(b.width=1,b.height=1):(b.width=i[y],b.height=r[y]),t.push(b)}n=a}return t}(Rr);var o=f(this.anchors.map((function(e){return e.width}))),u=f(this.anchors.map((function(e){return e.height}))),l=f(this.anchors.map((function(e){return e.xCenter}))),h=f(this.anchors.map((function(e){return e.yCenter})));this.anchorTensor={x:l,y:h,w:o,h:u},this.prevFilteredSegmentationMask=this.enableSegmentation?a([],[0,0]):null}return e.prototype.estimatePoses=function(e,t,n){return Rn(this,void 0,void 0,(function(){var r,s,o,a,u,c,d,f,m,g,x,y,b,w,v,k,S,I,C,R,A,P,z;return Tn(this,(function(N){switch(N.label){case 0:return r=function(e){var t;if(null==(t=null==e?$r:Cn({},e)).maxPoses&&(t.maxPoses=1),t.maxPoses<=0)throw new Error("Invalid maxPoses ".concat(t.maxPoses,". Should be > 0."));if(t.maxPoses>1)throw new Error("Multi-pose detection is not implemented yet. Please set maxPoses to 1.");return t}(t),null==e?(this.reset(),[2,[]]):(this.maxPoses=r.maxPoses,this.timestamp=null!=n?1e3*n:sr(e)?1e6*e.currentTime:null,s=Hn(e),o=i((function(){return h(Xn(e),"float32")})),null!=(a=this.regionOfInterest)?[3,2]:[4,this.detectPose(o)]);case 1:if(0===(u=N.sent()).length)return this.reset(),o.dispose(),[2,[]];c=u[0],a=this.poseDetectionToRoi(c,s),N.label=2;case 2:return[4,this.poseLandmarksByRoi(a,o)];case 3:return d=N.sent(),o.dispose(),null==d?(this.reset(),[2,[]]):(f=d.landmarks,m=d.auxiliaryLandmarks,g=d.poseScore,x=d.worldLandmarks,y=d.segmentationMask,b=this.poseLandmarkFiltering(f,m,x,s),w=b.actualLandmarksFiltered,v=b.auxiliaryLandmarksFiltered,k=b.actualWorldLandmarksFiltered,S=this.poseLandmarksToRoi(v,s),this.regionOfInterest=S,I=this.smoothSegmentation&&null!=y?this.poseSegmentationFiltering(y):y,null!=(C=null!=w?ur(w,s):null)&&C.forEach((function(e,t){e.name=Pn[t]})),null!=(R=k)&&R.forEach((function(e,t){e.name=Pn[t]})),A={score:g,keypoints:C,keypoints3D:R},null!==I&&(P=i((function(){var e=l(I,2),t=T(e,[[0,0],[0,0],[0,1]]);return $(t,[[0,0],[0,0],[0,2]],"symmetric")})),this.smoothSegmentation||p(I),z={maskValueToLabel:Gr,mask:new Vr(P)},A.segmentation=z),[2,[A]])}}))}))},e.prototype.poseSegmentationFiltering=function(e){var t=this.prevFilteredSegmentationMask;return 0===t.size?this.prevFilteredSegmentationMask=e:(this.prevFilteredSegmentationMask=cr(t,e,Wr),p(e)),p(t),this.prevFilteredSegmentationMask},e.prototype.dispose=function(){this.detectorModel.dispose(),this.landmarkModel.dispose(),p([this.anchorTensor.x,this.anchorTensor.y,this.anchorTensor.w,this.anchorTensor.h,this.prevFilteredSegmentationMask])},e.prototype.reset=function(){this.regionOfInterest=null,this.enableSegmentation&&(p(this.prevFilteredSegmentationMask),this.prevFilteredSegmentationMask=a([],[0,0])),this.visibilitySmoothingFilterActual=null,this.visibilitySmoothingFilterAuxiliary=null,this.landmarksSmoothingFilterActual=null,this.landmarksSmoothingFilterAuxiliary=null},e.prototype.detectPose=function(e){return Rn(this,void 0,void 0,(function(){var t,n,r,i,s,o,a,u,l,h;return Tn(this,(function(c){switch(c.label){case 0:return t=nr(e,Nr),n=t.imageTensor,r=t.padding,i=this.detectorModel.predict(n),s=ir(i),o=s.boxes,[4,dr([a=s.logits,o],this.anchorTensor,Ar)];case 1:return 0===(u=c.sent()).length?(p([n,i,a,o]),[2,u]):[4,ar(u,this.maxPoses,Pr)];case 2:return l=c.sent(),h=function(e,t){void 0===e&&(e=[]);for(var n=t.left,r=t.top,i=t.left+t.right,s=t.top+t.bottom,o=0;o<e.length;o++){var a=e[o],u=a.locationData.relativeBoundingBox,l=(u.xMin-n)/(1-i),h=(u.yMin-r)/(1-s),c=u.width/(1-i),d=u.height/(1-s);u.xMin=l,u.yMin=h,u.width=c,u.height=d,u.xMax=l+c,u.yMax=h+d;var p=a.locationData.relativeKeypoints;p&&p.forEach((function(e){var t=(e.x-n)/(1-i),o=(e.y-r)/(1-s);e.x=t,e.y=o}))}return e}(l,r),p([n,i,a,o]),[2,h]}}))}))},e.prototype.poseDetectionToRoi=function(e,t){return 0,1,xr(Yn(e,t,{rotationVectorEndKeypointIndex:1,rotationVectorStartKeypointIndex:0,rotationVectorTargetAngleDegree:90}),t,zr)},e.prototype.poseLandmarksByRoi=function(e,t){return Rn(this,void 0,void 0,(function(){var n,r,i,s,o,a,u,l,h,c,d,f,m,g;return Tn(this,(function(x){switch(x.label){case 0:if(n=Hn(t),r=nr(t,Mr,e),i=r.imageTensor,s=r.padding,o=r.transformationMatrix,"lite"!==this.modelType&&"full"!==this.modelType&&"heavy"!==this.modelType)throw new Error("Model type must be one of lite, full or heavy,"+"but got ".concat(this.modelType));return a=["ld_3d","output_poseflag","activation_heatmap","world_3d"],this.enableSegmentation&&a.push("activation_segmentation"),u=this.landmarkModel.execute(i,a),[4,this.tensorsToPoseLandmarksAndSegmentation(u)];case 1:return null==(l=x.sent())?(p(u),p(i),[2,null]):(h=l.landmarks,c=l.auxiliaryLandmarks,d=l.poseScore,f=l.worldLandmarks,m=l.segmentationMask,[4,this.poseLandmarksAndSegmentationInverseProjection(n,e,s,o,h,c,f,m)]);case 2:return g=x.sent(),p(u),p(i),[2,Cn({poseScore:d},g)]}}))}))},e.prototype.poseLandmarksAndSegmentationInverseProjection=function(e,t,n,r,s,o,l,h){return Rn(this,void 0,void 0,(function(){var c,f,m,g,x,y;return Tn(this,(function(b){return c=hr(s,n),f=hr(o,n),m=er(c,t),g=er(f,t),x=function(e,t){for(var n=[],r=0,i=e;r<i.length;r++){var s=i[r],o=s.x,a=s.y,u=t.rotation,l=Math.cos(u)*o-Math.sin(u)*a,h=Math.sin(u)*o+Math.cos(u)*a,c=Cn({},s);c.x=l,c.y=h,n.push(c)}return n}(l,t),y=null,this.enableSegmentation&&(y=i((function(){var t=h.shape,n=t[0],i=t[1],s=function(e){var t=Qn(new Array(16).fill(0));t[0][0]=Jn(e,0,0),t[1][0]=-Jn(e,0,1),t[2][0]=Jn(e,0,2),t[3][0]=-Jn(e,0,3),t[0][2]=Jn(e,2,0),t[1][2]=-Jn(e,2,1),t[2][2]=Jn(e,2,2),t[3][2]=-Jn(e,2,3),t[0][1]=-Jn(e,1,0),t[1][1]=Jn(e,1,1),t[2][1]=-Jn(e,1,2),t[3][1]=Jn(e,1,3),t[0][3]=-Jn(e,3,0),t[1][3]=Jn(e,3,1),t[2][3]=-Jn(e,3,2),t[3][3]=Jn(e,3,3);for(var n=e[0][0]*t[0][0]+e[1][0]*t[0][1]+e[2][0]*t[0][2]+e[3][0]*t[0][3],r=0;r<t.length;r++)for(var i=0;i<t.length;i++)t[r][i]/=n;return t}(r),o=a(qn(s,{width:i,height:n},e),[1,8]),l=[1,n,i,1];return d(u.transform(I(h,l),o,"bilinear","constant",0,[e.height,e.width]),[0,3])})),p(h)),[2,{landmarks:m,auxiliaryLandmarks:g,worldLandmarks:x,segmentationMask:y}]}))}))},e.prototype.tensorsToPoseLandmarksAndSegmentation=function(e){return Rn(this,void 0,void 0,(function(){var t,n,r,s,o,a,l,h,c,p,f,m,g;return Tn(this,(function(x){switch(x.label){case 0:return t=e[0],n=e[1],r=e[2],s=e[3],o=this.enableSegmentation?e[4]:null,[4,n.data()];case 1:return(a=x.sent()[0])<.5?[2,null]:[4,gr(t,Fr)];case 2:return[4,lr(x.sent(),r,_r)];case 3:return l=x.sent(),h=l.slice(0,33),c=l.slice(33,35),[4,gr(s,Er)];case 4:return p=x.sent(),f=p.slice(0,33),m=function(e,t,n){void 0===n&&(n=!0);for(var r=[],i=0;i<e.length;i++){var s=Cn({},t[i]);n&&(s.score=e[i].score),r.push(s)}return r}(h,f,!0),g=this.enableSegmentation?function(e,t,n){return i((function(){var r=d(e,[0]),i=r.shape[2];if(1===i){var s=r;switch(t.activation){case"none":break;case"sigmoid":s=R(s);break;case"softmax":throw new Error("Softmax activation requires two channels.");default:throw new Error("Activation not supported (".concat(t.activation,")"))}var o=n?u.resizeBilinear(s,[n.height,n.width]):s;return d(o,[2])}throw new Error("Unsupported number of tensor channels ".concat(i))}))}(o,Ur):null,[2,{landmarks:h,auxiliaryLandmarks:c,poseScore:a,worldLandmarks:m,segmentationMask:g}]}}))}))},e.prototype.poseLandmarksToRoi=function(e,t){return xr(Yn(or(e),t,{rotationVectorStartKeypointIndex:0,rotationVectorEndKeypointIndex:1,rotationVectorTargetAngleDegree:90}),t,zr)},e.prototype.poseLandmarkFiltering=function(e,t,n,r){var i,s,o;if(null!=this.timestamp&&this.enableSmoothing){var a=Yn(or(t),r,{rotationVectorEndKeypointIndex:0,rotationVectorStartKeypointIndex:1,rotationVectorTargetAngleDegree:90});null==this.visibilitySmoothingFilterActual&&(this.visibilitySmoothingFilterActual=new Cr(Or)),i=this.visibilitySmoothingFilterActual.apply(e),null==this.visibilitySmoothingFilterAuxiliary&&(this.visibilitySmoothingFilterAuxiliary=new Cr(Or)),s=this.visibilitySmoothingFilterAuxiliary.apply(t),o=this.visibilitySmoothingFilterActual.apply(n),null==this.landmarksSmoothingFilterActual&&(this.landmarksSmoothingFilterActual=new Ir(Br)),i=this.landmarksSmoothingFilterActual.apply(i,this.timestamp,r,!0,a),null==this.landmarksSmoothingFilterAuxiliary&&(this.landmarksSmoothingFilterAuxiliary=new Ir(Lr)),s=this.landmarksSmoothingFilterAuxiliary.apply(s,this.timestamp,r,!0,a),null==this.worldLandmarksSmoothingFilterActual&&(this.worldLandmarksSmoothingFilterActual=new Ir(Dr)),o=this.worldLandmarksSmoothingFilterActual.apply(n,this.timestamp)}else i=e,s=t,o=n;return{actualLandmarksFiltered:i,auxiliaryLandmarksFiltered:s,actualWorldLandmarksFiltered:o}},e}();function Kr(e){return Rn(this,void 0,void 0,(function(){var t,n,r,i,s,o;return Tn(this,(function(a){switch(a.label){case 0:return t=function(e){var t=Cn({},null==e?Tr:e);if(null==t.enableSmoothing&&(t.enableSmoothing=Tr.enableSmoothing),null==t.enableSegmentation&&(t.enableSegmentation=Tr.enableSegmentation),null==t.smoothSegmentation&&(t.smoothSegmentation=Tr.smoothSegmentation),null==t.modelType&&(t.modelType=Tr.modelType),null==t.detectorModelUrl&&(t.detectorModelUrl=Tr.detectorModelUrl),null==t.landmarkModelUrl)switch(t.modelType){case"lite":t.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/lite/2";break;case"heavy":t.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/heavy/2";break;case"full":default:t.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/full/2"}return t}(e),n="string"==typeof t.detectorModelUrl&&t.detectorModelUrl.indexOf("https://tfhub.dev")>-1,r="string"==typeof t.landmarkModelUrl&&t.landmarkModelUrl.indexOf("https://tfhub.dev")>-1,[4,Promise.all([kn(t.detectorModelUrl,{fromTFHub:n}),kn(t.landmarkModelUrl,{fromTFHub:r})])];case 1:return i=a.sent(),s=i[0],o=i[1],[2,new Hr(s,o,t.enableSmoothing,t.enableSegmentation,t.smoothSegmentation,t.modelType)]}}))}))}var Xr,qr,jr=function(){function e(e){!function(e){if(e.maxTracks<1)throw new Error("Must specify 'maxTracks' to be at least 1, but "+"encountered ".concat(e.maxTracks));if(e.maxAge<=0)throw new Error("Must specify 'maxAge' to be positive, but "+"encountered ".concat(e.maxAge));if(void 0!==e.keypointTrackerParams){if(e.keypointTrackerParams.keypointConfidenceThreshold<0||e.keypointTrackerParams.keypointConfidenceThreshold>1)throw new Error("Must specify 'keypointConfidenceThreshold' to be in the range [0, 1], but encountered "+"".concat(e.keypointTrackerParams.keypointConfidenceThreshold));if(e.keypointTrackerParams.minNumberOfKeypoints<1)throw new Error("Must specify 'minNumberOfKeypoints' to be at least 1, but "+"encountered ".concat(e.keypointTrackerParams.minNumberOfKeypoints));for(var t=0,n=e.keypointTrackerParams.keypointFalloff;t<n.length;t++){var r=n[t];if(r<=0)throw new Error("Must specify each keypoint falloff parameterto be positive "+"but encountered ".concat(r))}}}(e),this.tracks=[],this.maxTracks=e.maxTracks,this.maxAge=1e3*e.maxAge,this.minSimilarity=e.minSimilarity,this.nextID=1}return e.prototype.apply=function(e,t){this.filterOldTracks(t);var n=this.computeSimilarity(e);return this.assignTracks(e,n,t),this.updateTracks(t),e},e.prototype.getTracks=function(){return this.tracks.slice()},e.prototype.getTrackIDs=function(){return new Set(this.tracks.map((function(e){return e.id})))},e.prototype.filterOldTracks=function(e){var t=this;this.tracks=this.tracks.filter((function(n){return e-n.lastTimestamp<=t.maxAge}))},e.prototype.assignTracks=function(e,t,n){for(var r=Array.from(Array(t[0].length).keys()),i=[],s=0,o=Array.from(Array(e.length).keys());s<o.length;s++){var a=o[s];if(0!==r.length){for(var u=-1,l=-1,h=0,c=r;h<c.length;h++){var d=c[h],p=t[a][d];p>=this.minSimilarity&&p>l&&(u=d,l=p)}if(u>=0){var f=this.tracks[u];f=Object.assign(f,this.createTrack(e[a],n,f.id)),e[a].id=f.id;var m=r.indexOf(u);r.splice(m,1)}else i.push(a)}else i.push(a)}for(var g=0,x=i;g<x.length;g++){a=x[g];var y=this.createTrack(e[a],n);this.tracks.push(y),e[a].id=y.id}},e.prototype.updateTracks=function(e){this.tracks.sort((function(e,t){return t.lastTimestamp-e.lastTimestamp})),this.tracks=this.tracks.slice(0,this.maxTracks)},e.prototype.createTrack=function(e,t,n){var r={id:n||this.nextTrackID(),lastTimestamp:t,keypoints:$n([],e.keypoints,!0).map((function(e){return Cn({},e)}))};return void 0!==e.box&&(r.box=Cn({},e.box)),r},e.prototype.nextTrackID=function(){var e=this.nextID;return this.nextID+=1,e},e.prototype.remove=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];this.tracks=this.tracks.filter((function(t){return!e.includes(t.id)}))},e.prototype.reset=function(){this.tracks=[]},e}(),Yr=function(e){function t(t){return e.call(this,t)||this}return In(t,e),t.prototype.computeSimilarity=function(e){var t=this;return 0===e.length||0===this.tracks.length?[[]]:e.map((function(e){return t.tracks.map((function(n){return t.iou(e,n)}))}))},t.prototype.iou=function(e,t){var n=Math.max(e.box.xMin,t.box.xMin),r=Math.max(e.box.yMin,t.box.yMin),i=Math.min(e.box.xMax,t.box.xMax),s=Math.min(e.box.yMax,t.box.yMax);if(n>=i||r>=s)return 0;var o=(i-n)*(s-r);return o/(e.box.width*e.box.height+t.box.width*t.box.height-o)},t}(jr),Qr=function(e){function t(t){var n=e.call(this,t)||this;return n.keypointThreshold=t.keypointTrackerParams.keypointConfidenceThreshold,n.keypointFalloff=t.keypointTrackerParams.keypointFalloff,n.minNumKeyoints=t.keypointTrackerParams.minNumberOfKeypoints,n}return In(t,e),t.prototype.computeSimilarity=function(e){if(0===e.length||0===this.tracks.length)return[[]];for(var t=[],n=0,r=e;n<r.length;n++){for(var i=r[n],s=[],o=0,a=this.tracks;o<a.length;o++){var u=a[o];s.push(this.oks(i,u))}t.push(s)}return t},t.prototype.oks=function(e,t){for(var n=this.area(t.keypoints)+1e-6,r=0,i=0,s=0;s<e.keypoints.length;++s){var o=e.keypoints[s],a=t.keypoints[s];if(!(o.score<this.keypointThreshold||a.score<this.keypointThreshold)){i+=1;var u=Math.pow(o.x-a.x,2)+Math.pow(o.y-a.y,2),l=2*this.keypointFalloff[s];r+=Math.exp(-1*u/(2*n*Math.pow(l,2)))}}return i<this.minNumKeyoints?0:r/i},t.prototype.area=function(e){var t=this,n=e.filter((function(e){return e.score>t.keypointThreshold})),r=Math.min.apply(Math,$n([1],n.map((function(e){return e.x})),!1)),i=Math.max.apply(Math,$n([0],n.map((function(e){return e.x})),!1)),s=Math.min.apply(Math,$n([1],n.map((function(e){return e.y})),!1));return(i-r)*(Math.max.apply(Math,$n([0],n.map((function(e){return e.y})),!1))-s)},t}(jr);function Zr(e){switch(e){case qr.BlazePose:return Pn.reduce((function(e,t,n){return e[t]=n,e}),{});case qr.PoseNet:case qr.MoveNet:return An.reduce((function(e,t,n){return e[t]=n,e}),{});default:throw new Error("Model ".concat(e," is not supported."))}}!function(e){e.Keypoint="keypoint",e.BoundingBox="boundingBox"}(Xr||(Xr={})),function(e){e.MoveNet="MoveNet",e.BlazePose="BlazePose",e.PoseNet="PoseNet"}(qr||(qr={}));var Jr=Object.freeze({__proto__:null,getKeypointIndexBySide:function(e){switch(e){case qr.BlazePose:return zn;case qr.PoseNet:case qr.MoveNet:return Nn;default:throw new Error("Model ".concat(e," is not supported."))}},getAdjacentPairs:function(e){switch(e){case qr.BlazePose:return Fn;case qr.PoseNet:case qr.MoveNet:return Mn;default:throw new Error("Model ".concat(e," is not supported."))}},getKeypointIndexByName:Zr}),ei=["SinglePose.Lightning","SinglePose.Thunder","MultiPose.Lightning"],ti={modelType:"SinglePose.Lightning",enableSmoothing:!0},ni={},ri={frequency:30,minCutOff:2.5,beta:300,derivateCutOff:2.5,thresholdCutOff:.5,thresholdBeta:5,disableValueScaling:!0},ii={maxTracks:18,maxAge:1e3,minSimilarity:.2,keypointTrackerParams:{keypointConfidenceThreshold:.3,keypointFalloff:[.026,.025,.025,.035,.035,.079,.079,.072,.072,.062,.062,.107,.107,.087,.087,.089,.089],minNumberOfKeypoints:4}},si={maxTracks:18,maxAge:1e3,minSimilarity:.15,trackerParams:{}};function oi(e,t,n,r){for(var i={},s=0,o=An;s<o.length;s++){var a=o[s];i[a]=[t[n[a]].y*r.height,t[n[a]].x*r.width]}if(function(e,t){return(e[t.left_hip].score>.2||e[t.right_hip].score>.2)&&(e[t.left_shoulder].score>.2||e[t.right_shoulder].score>.2)}(t,n)){var u=(i.left_hip[0]+i.right_hip[0])/2,l=(i.left_hip[1]+i.right_hip[1])/2,h=function(e,t,n,r,i){for(var s=["left_shoulder","right_shoulder","left_hip","right_hip"],o=0,a=0,u=0;u<s.length;u++){(p=Math.abs(r-n[s[u]][0]))>o&&(o=p),(f=Math.abs(i-n[s[u]][1]))>a&&(a=f)}for(var l=0,h=0,c=0,d=Object.keys(n);c<d.length;c++){var p,f,m=d[c];if(!(e[t[m]].score<.2))(p=Math.abs(r-n[m][0]))>l&&(l=p),(f=Math.abs(i-n[m][1]))>h&&(h=f)}return[o,a,l,h]}(t,n,i,u,l),c=h[0],d=h[1],p=h[2],f=h[3],m=Math.max(1.9*d,1.9*c,1.2*p,1.2*f),g=[u-(m=Math.min(m,Math.max(l,r.width-l,u,r.height-u))),l-m];if(m>Math.max(r.width,r.height)/2)return ai(null==e,r);var x=2*m;return{yMin:g[0]/r.height,xMin:g[1]/r.width,yMax:(g[0]+x)/r.height,xMax:(g[1]+x)/r.width,height:(g[0]+x)/r.height-g[0]/r.height,width:(g[1]+x)/r.width-g[1]/r.width}}return ai(null==e,r)}function ai(e,t){var n,r,i,s;return e?t.width>t.height?(n=1,r=t.height/t.width,i=0,s=(t.width/2-t.height/2)/t.width):(n=t.width/t.height,r=1,i=(t.height/2-t.width/2)/t.height,s=0):t.width>t.height?(n=t.width/t.height,r=1,i=(t.height/2-t.width/2)/t.height,s=0):(n=1,r=t.height/t.width,i=0,s=(t.width/2-t.height/2)/t.width),{yMin:i,xMin:s,yMax:i+n,xMax:s+r,height:n,width:r}}function ui(e){var t,n=null==e?ti:Cn({},e);if(null==n.modelType)n.modelType="SinglePose.Lightning";else if(ei.indexOf(n.modelType)<0)throw new Error("Invalid architecture ".concat(n.modelType,". ")+"Should be one of ".concat(ei));if(null==n.enableSmoothing&&(n.enableSmoothing=!0),null!=n.minPoseScore&&(n.minPoseScore<0||n.minPoseScore>1))throw new Error("minPoseScore should be between 0.0 and 1.0");if(null!=n.multiPoseMaxDimension&&(n.multiPoseMaxDimension%32!=0||n.multiPoseMaxDimension<32))throw new Error("multiPoseMaxDimension must be a multiple of 32 and higher than 0");if("MultiPose.Lightning"===n.modelType&&null==n.enableTracking&&(n.enableTracking=!0),"MultiPose.Lightning"===n.modelType&&!0===n.enableTracking)if(null==n.trackerType&&(n.trackerType=Xr.BoundingBox),n.trackerType===Xr.Keypoint)null!=n.trackerConfig?n.trackerConfig=function(e){var t=li(ii,e);t.keypointTrackerParams=Cn({},ii.keypointTrackerParams),null!=e.keypointTrackerParams&&(null!=e.keypointTrackerParams.keypointConfidenceThreshold&&(t.keypointTrackerParams.keypointConfidenceThreshold=e.keypointTrackerParams.keypointConfidenceThreshold),null!=e.keypointTrackerParams.keypointFalloff&&(t.keypointTrackerParams.keypointFalloff=e.keypointTrackerParams.keypointFalloff),null!=e.keypointTrackerParams.minNumberOfKeypoints&&(t.keypointTrackerParams.minNumberOfKeypoints=e.keypointTrackerParams.minNumberOfKeypoints));return t}(n.trackerConfig):n.trackerConfig=ii;else{if(n.trackerType!==Xr.BoundingBox)throw new Error("Tracker type not supported by MoveNet");null!=n.trackerConfig?n.trackerConfig=(t=n.trackerConfig,li(si,t)):n.trackerConfig=si}return n}function li(e,t){var n={maxTracks:e.maxTracks,maxAge:e.maxAge,minSimilarity:e.minSimilarity};return null!=t.maxTracks&&(n.maxTracks=t.maxTracks),null!=t.maxAge&&(n.maxAge=t.maxAge),null!=t.minSimilarity&&(n.minSimilarity=t.minSimilarity),n}var hi=function(){function e(e,t){this.moveNetModel=e,this.modelInputResolution={height:0,width:0},this.keypointIndexByName=Zr(qr.MoveNet),"SinglePose.Lightning"===t.modelType?(this.modelInputResolution.width=192,this.modelInputResolution.height=192):"SinglePose.Thunder"===t.modelType&&(this.modelInputResolution.width=256,this.modelInputResolution.height=256),this.multiPoseModel="MultiPose.Lightning"===t.modelType,this.multiPoseModel||(this.keypointFilter=new vr(ri),this.cropRegionFilterYMin=new br(.9),this.cropRegionFilterXMin=new br(.9),this.cropRegionFilterYMax=new br(.9),this.cropRegionFilterXMax=new br(.9)),this.enableSmoothing=t.enableSmoothing,t.minPoseScore?this.minPoseScore=t.minPoseScore:this.minPoseScore=.25,t.multiPoseMaxDimension?this.multiPoseMaxDimension=t.multiPoseMaxDimension:this.multiPoseMaxDimension=256,this.enableTracking=t.enableTracking,this.multiPoseModel&&this.enableTracking&&(t.trackerType===Xr.Keypoint?this.tracker=new Qr(t.trackerConfig):t.trackerType===Xr.BoundingBox&&(this.tracker=new Yr(t.trackerConfig)),this.enableSmoothing&&(this.keypointFilterMap=new Map))}return e.prototype.runSinglePersonPoseModel=function(e){return Rn(this,void 0,void 0,(function(){var t,n,r,i,s;return Tn(this,(function(o){switch(o.label){case 0:if(4!==(t=this.moveNetModel.execute(e)).shape.length||1!==t.shape[0]||1!==t.shape[1]||17!==t.shape[2]||3!==t.shape[3])throw t.dispose(),new Error("Unexpected output shape from model: [".concat(t.shape,"]"));return"webgpu"===m()?[3,1]:(n=t.dataSync(),[3,3]);case 1:return[4,t.data()];case 2:n=o.sent(),o.label=3;case 3:for(t.dispose(),r={keypoints:[],score:0},i=0,s=0;s<17;++s)r.keypoints[s]={y:n[3*s],x:n[3*s+1],score:n[3*s+2]},r.keypoints[s].score>.2&&(++i,r.score+=r.keypoints[s].score);return i>0&&(r.score/=i),[2,r]}}))}))},e.prototype.runMultiPersonPoseModel=function(e){return Rn(this,void 0,void 0,(function(){var t,n,r,i,s,o,a,u;return Tn(this,(function(l){switch(l.label){case 0:if(3!==(t=this.moveNetModel.execute(e)).shape.length||1!==t.shape[0]||56!==t.shape[2])throw t.dispose(),new Error("Unexpected output shape from model: [".concat(t.shape,"]"));return"webgpu"===m()?[3,1]:(n=t.dataSync(),[3,3]);case 1:return[4,t.data()];case 2:n=l.sent(),l.label=3;case 3:for(t.dispose(),r=[],i=n.length/56,s=0;s<i;++s)for(r[s]={keypoints:[]},o=56*s+51,r[s].box={yMin:n[o],xMin:n[o+1],yMax:n[o+2],xMax:n[o+3],width:n[o+3]-n[o+1],height:n[o+2]-n[o]},a=56*s+55,r[s].score=n[a],r[s].keypoints=[],u=0;u<17;++u)r[s].keypoints[u]={y:n[56*s+3*u],x:n[56*s+3*u+1],score:n[56*s+3*u+2]};return[2,r]}}))}))},e.prototype.estimatePoses=function(e,n,r){return void 0===n&&(n=ni),Rn(this,void 0,void 0,(function(){var i,s,o,a,u,h;return Tn(this,(function(c){switch(c.label){case 0:return n=function(e){return null==e?ni:Cn({},e)}(n),null==e?(this.reset(),[2,[]]):(null==r?sr(e)&&(r=1e6*e.currentTime):r*=1e3,i=Xn(e),s=Hn(i),o=l(i,0),e instanceof t||i.dispose(),a=[],this.multiPoseModel?[3,2]:[4,this.estimateSinglePose(o,s,r)]);case 1:return a=c.sent(),[3,4];case 2:return[4,this.estimateMultiplePoses(o,s,r)];case 3:a=c.sent(),c.label=4;case 4:for(u=0;u<a.length;++u)for(h=0;h<a[u].keypoints.length;++h)a[u].keypoints[h].name=An[h],a[u].keypoints[h].y*=s.height,a[u].keypoints[h].x*=s.width;return[2,a]}}))}))},e.prototype.estimateSinglePose=function(e,t,n){return Rn(this,void 0,void 0,(function(){var r,s,o,l,c=this;return Tn(this,(function(d){switch(d.label){case 0:return this.cropRegion||(this.cropRegion=ai(null==this.cropRegion,t)),r=i((function(){var t=a([[c.cropRegion.yMin,c.cropRegion.xMin,c.cropRegion.yMax,c.cropRegion.xMax]]),n=P([1],"int32"),r=[c.modelInputResolution.height,c.modelInputResolution.width];return h(u.cropAndResize(e,t,n,r,"bilinear",0),"int32")})),e.dispose(),[4,this.runSinglePersonPoseModel(r)];case 1:if(s=d.sent(),r.dispose(),s.score<this.minPoseScore)return this.reset(),[2,[]];for(o=0;o<s.keypoints.length;++o)s.keypoints[o].y=this.cropRegion.yMin+s.keypoints[o].y*this.cropRegion.height,s.keypoints[o].x=this.cropRegion.xMin+s.keypoints[o].x*this.cropRegion.width;return null!=n&&this.enableSmoothing&&(s.keypoints=this.keypointFilter.apply(s.keypoints,n,1)),l=oi(this.cropRegion,s.keypoints,this.keypointIndexByName,t),this.cropRegion=this.filterCropRegion(l),[2,[s]]}}))}))},e.prototype.estimateMultiplePoses=function(e,t,n){return Rn(this,void 0,void 0,(function(){var r,i,s,o,a,l,c,d,p,f,m,g=this;return Tn(this,(function(x){switch(x.label){case 0:return 32,t.width>t.height?(i=this.multiPoseMaxDimension,s=Math.round(this.multiPoseMaxDimension*t.height/t.width),r=u.resizeBilinear(e,[s,i]),a=i,l=32*Math.ceil(s/32),o=T(r,[[0,0],[0,l-s],[0,0],[0,0]])):(i=Math.round(this.multiPoseMaxDimension*t.width/t.height),s=this.multiPoseMaxDimension,r=u.resizeBilinear(e,[s,i]),a=32*Math.ceil(i/32),l=s,o=T(r,[[0,0],[0,0],[0,a-i],[0,0]])),r.dispose(),e.dispose(),c=h(o,"int32"),o.dispose(),[4,this.runMultiPersonPoseModel(c)];case 1:for(d=x.sent(),c.dispose(),d=d.filter((function(e){return e.score>=g.minPoseScore})),f=0;f<d.length;++f)for(p=0;p<d[f].keypoints.length;++p)d[f].keypoints[p].y*=l/s,d[f].keypoints[p].x*=a/i;if(this.enableTracking&&(this.tracker.apply(d,n),this.enableSmoothing)){for(f=0;f<d.length;++f)this.keypointFilterMap.has(d[f].id)||this.keypointFilterMap.set(d[f].id,new vr(ri)),d[f].keypoints=this.keypointFilterMap.get(d[f].id).apply(d[f].keypoints,n,1);m=this.tracker.getTrackIDs(),this.keypointFilterMap.forEach((function(e,t){m.has(t)||g.keypointFilterMap.delete(t)}))}return[2,d]}}))}))},e.prototype.filterCropRegion=function(e){if(e){var t=this.cropRegionFilterYMin.apply(e.yMin),n=this.cropRegionFilterXMin.apply(e.xMin),r=this.cropRegionFilterYMax.apply(e.yMax),i=this.cropRegionFilterXMax.apply(e.xMax);return{yMin:t,xMin:n,yMax:r,xMax:i,height:r-t,width:i-n}}return this.cropRegionFilterYMin.reset(),this.cropRegionFilterXMin.reset(),this.cropRegionFilterYMax.reset(),this.cropRegionFilterXMax.reset(),null},e.prototype.dispose=function(){this.moveNetModel.dispose()},e.prototype.reset=function(){this.cropRegion=null,this.resetFilters()},e.prototype.resetFilters=function(){this.keypointFilter.reset(),this.cropRegionFilterYMin.reset(),this.cropRegionFilterXMin.reset(),this.cropRegionFilterYMax.reset(),this.cropRegionFilterXMax.reset()},e}();function ci(e){return void 0===e&&(e=ti),Rn(this,void 0,void 0,(function(){var t,n,r,i;return Tn(this,(function(s){switch(s.label){case 0:return t=ui(e),r=!0,t.modelUrl?(r="string"==typeof t.modelUrl&&t.modelUrl.indexOf("https://tfhub.dev")>-1,[4,kn(t.modelUrl,{fromTFHub:r})]):[3,2];case 1:return n=s.sent(),[3,4];case 2:return i=void 0,"SinglePose.Lightning"===t.modelType?i="https://tfhub.dev/google/tfjs-model/movenet/singlepose/lightning/4":"SinglePose.Thunder"===t.modelType?i="https://tfhub.dev/google/tfjs-model/movenet/singlepose/thunder/4":"MultiPose.Lightning"===t.modelType&&(i="https://tfhub.dev/google/tfjs-model/movenet/multipose/lightning/1"),[4,kn(i,{fromTFHub:r})];case 3:n=s.sent(),s.label=4;case 4:return"webgl"===m()&&A().set("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",0),[2,new hi(n,t)]}}))}))}var di={architecture:"MobileNetV1",outputStride:16,multiplier:.75,inputResolution:{height:257,width:257}},pi=["MobileNetV1","ResNet50"],fi={MobileNetV1:[8,16],ResNet50:[16]},mi=[8,16,32],gi={MobileNetV1:[.5,.75,1],ResNet50:[1]},xi=[1,2,4],yi={maxPoses:1,flipHorizontal:!1},bi={maxPoses:5,flipHorizontal:!1,scoreThreshold:.5,nmsRadius:20},wi=[-123.15,-115.9,-103.06];function vi(e){return Math.floor(e/2)}var ki=function(){function e(e,t){this.priorityQueue=new Array(e),this.numberOfElements=-1,this.getElementValue=t}return e.prototype.enqueue=function(e){this.priorityQueue[++this.numberOfElements]=e,this.swim(this.numberOfElements)},e.prototype.dequeue=function(){var e=this.priorityQueue[0];return this.exchange(0,this.numberOfElements--),this.sink(0),this.priorityQueue[this.numberOfElements+1]=null,e},e.prototype.empty=function(){return-1===this.numberOfElements},e.prototype.size=function(){return this.numberOfElements+1},e.prototype.all=function(){return this.priorityQueue.slice(0,this.numberOfElements+1)},e.prototype.max=function(){return this.priorityQueue[0]},e.prototype.swim=function(e){for(;e>0&&this.less(vi(e),e);)this.exchange(e,vi(e)),e=vi(e)},e.prototype.sink=function(e){for(;2*e<=this.numberOfElements;){var t=2*e;if(t<this.numberOfElements&&this.less(t,t+1)&&t++,!this.less(e,t))break;this.exchange(e,t),e=t}},e.prototype.getValueAt=function(e){return this.getElementValue(this.priorityQueue[e])},e.prototype.less=function(e,t){return this.getValueAt(e)<this.getValueAt(t)},e.prototype.exchange=function(e,t){var n=this.priorityQueue[e];this.priorityQueue[e]=this.priorityQueue[t],this.priorityQueue[t]=n},e}();function Si(e,t,n,r,i,s){for(var o=s.shape,a=o[0],u=o[1],l=!0,h=Math.max(n-i,0),c=Math.min(n+i+1,a),d=h;d<c;++d){for(var p=Math.max(r-i,0),f=Math.min(r+i+1,u),m=p;m<f;++m)if(s.get(d,m,e)>t){l=!1;break}if(!l)break}return l}function Ii(e){return Rn(this,void 0,void 0,(function(){return Tn(this,(function(t){return[2,Promise.all(e.map((function(e){return e.buffer()})))]}))}))}function Ci(e,t,n,r){return{y:r.get(e,t,n),x:r.get(e,t,n+17)}}function Ri(e,t,n){var r=Ci(e.heatmapY,e.heatmapX,e.id,n),i=r.y,s=r.x;return{x:e.heatmapX*t+s,y:e.heatmapY*t+i}}function Ti(e,t,n,r){var i=n.x,s=n.y;return e.some((function(e){var n,o,a,u,l,h,c=e.keypoints;return n=s,o=i,a=c[r].y,u=c[r].x,(l=a-n)*l+(h=u-o)*h<=t}))}var $i=An.reduce((function(e,t,n){return e[t]=n,e}),{}),Ai=[["nose","left_eye"],["left_eye","left_ear"],["nose","right_eye"],["right_eye","right_ear"],["nose","left_shoulder"],["left_shoulder","left_elbow"],["left_elbow","left_wrist"],["left_shoulder","left_hip"],["left_hip","left_knee"],["left_knee","left_ankle"],["nose","right_shoulder"],["right_shoulder","right_elbow"],["right_elbow","right_wrist"],["right_shoulder","right_hip"],["right_hip","right_knee"],["right_knee","right_ankle"]].map((function(e){var t=e[0],n=e[1];return[$i[t],$i[n]]})),Pi=Ai.map((function(e){return e[1]})),zi=Ai.map((function(e){return e[0]}));function Ni(e,t,n){return e<t?t:e>n?n:e}function Mi(e,t,n,r){return{y:Ni(Math.round(e.y/t),0,n-1),x:Ni(Math.round(e.x/t),0,r-1)}}function Fi(e,t){return{x:e.x+t.x,y:e.y+t.y}}function Ei(e,t,n,r,i,s,o,a){void 0===a&&(a=2);for(var u=r.shape,l=u[0],h=u[1],c={y:t.y,x:t.x},d=Fi(c,function(e,t,n){var r=n.shape[2]/2;return{y:n.get(t.y,t.x,e),x:n.get(t.y,t.x,r+e)}}(e,Mi(c,s,l,h),o)),p=0;p<a;p++){var f=Mi(d,s,l,h),m=Ci(f.y,f.x,n,i);d=Fi({x:f.x*s,y:f.y*s},{x:m.x,y:m.y})}var g=Mi(d,s,l,h),x=r.get(g.y,g.x,n);return{y:d.y,x:d.x,name:An[n],score:x}}function _i(e,t,n,r,i,s){var o=t.shape[2],a=Pi.length,u=new Array(o),l=e.part,h=e.score,c=Ri(l,r,n);u[l.id]={score:h,name:An[l.id],y:c.y,x:c.x};for(var d=a-1;d>=0;--d){var p=Pi[d],f=zi[d];u[p]&&!u[f]&&(u[f]=Ei(d,u[p],f,t,n,r,s))}for(d=0;d<a;++d){p=zi[d],f=Pi[d];u[p]&&!u[f]&&(u[f]=Ei(d,u[p],f,t,n,r,i))}return u}function Oi(e,t,n){return n.reduce((function(n,r,i){var s=r.y,o=r.x,a=r.score;return Ti(e,t,{y:s,x:o},i)||(n+=a),n}),0)/n.length}function Bi(e,t,n,r,i,s,o,a){return void 0===o&&(o=.5),void 0===a&&(a=20),Rn(this,void 0,void 0,(function(){var u,l,h,c,d,p,f,m,g,x,y,b;return Tn(this,(function(w){switch(w.label){case 0:return[4,Ii([e,t,n,r])];case 1:for(u=w.sent(),l=u[0],h=u[1],c=u[2],d=u[3],p=[],f=function(e,t,n){for(var r=n.shape,i=r[0],s=r[1],o=r[2],a=new ki(i*s*o,(function(e){return e.score})),u=0;u<i;++u)for(var l=0;l<s;++l)for(var h=0;h<o;++h){var c=n.get(u,l,h);c<e||Si(h,c,u,l,t,n)&&a.enqueue({score:c,part:{heatmapY:u,heatmapX:l,id:h}})}return a}(o,1,l),m=a*a;p.length<s&&!f.empty();)g=f.dequeue(),x=Ri(g.part,i,h),Ti(p,m,x,g.part.id)||(y=_i(g,l,h,i,c,d),b=Oi(p,m,y),p.push({keypoints:y,score:b}));return[2,p]}}))}))}const Li=A();Li.registerFlag("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE",()=>15),Li.registerFlag("WEBGPU_CPU_FORWARD",()=>!0),Li.registerFlag("WEBGPU_MATMUL_PROGRAM_TYPE",()=>-1),Li.registerFlag("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE",()=>!1),Li.registerFlag("WEBGPU_USE_LOW_POWER_GPU",()=>!1),Li.registerFlag("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e3),Li.registerFlag("WEBGPU_USE_PROFILE_TOOL",()=>!1),Li.registerFlag("WEBGPU_IMPORT_EXTERNAL_TEXTURE",()=>!0),Li.registerFlag("WEBGPU_USE_NAIVE_CONV2D_DEBUG",()=>!1),Li.registerFlag("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL",()=>0),Li.registerFlag("WEBGPU_CONV_SEPARATE_IM2COL_SHADER",()=>!1);class Di{constructor(e){e&&(this.vendor=e.vendor,this.architecture=e.architecture,this.intelGPUGeneration=this.getIntelGPUGeneration())}getIntelGPUGeneration(){if(this.isIntel()){if(this.architecture.startsWith("gen"))return Number(this.architecture.match(/\d+/));if(this.architecture.startsWith("xe"))return 12}return 0}isIntel(){return"intel"===this.vendor}}class Ui{constructor(e){this.device=e,this.numUsedBuffers=0,this.numFreeBuffers=0,this.freeBuffers=new Map,this.usedBuffers=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireUploadBuffer(e,t){return this.acquireBuffer(e,t,!0)}acquireBuffer(e,t,n=!1){const r=Wi(e,t);if(this.freeBuffers.has(r)||this.freeBuffers.set(r,[]),this.usedBuffers.has(r)||this.usedBuffers.set(r,[]),this.numBytesUsed+=e,this.numUsedBuffers++,this.freeBuffers.get(r).length>0){this.numFreeBuffers--;const e=this.freeBuffers.get(r).shift();return this.usedBuffers.get(r).push(e),e}this.numBytesAllocated+=e;const i=this.device.createBuffer({size:e,usage:t,mappedAtCreation:n});return this.usedBuffers.get(r).push(i),i}releaseBuffer(e,t,n){if(0===this.freeBuffers.size)return;const r=Wi(t,n);this.freeBuffers.has(r)||this.freeBuffers.set(r,[]),this.freeBuffers.get(r).push(e),this.numFreeBuffers++,this.numUsedBuffers--;const i=this.usedBuffers.get(r),s=i.indexOf(e);if(s<0)throw new Error("Cannot release a buffer that was never provided by this buffer manager");i.splice(s,1),this.numBytesUsed-=t}releaseUploadBuffer(e,t,n){e.mapAsync(GPUMapMode.WRITE).then(()=>{this.releaseBuffer(e,t,n)},e=>{})}getNumUsedBuffers(){return this.numUsedBuffers}getNumFreeBuffers(){return this.numFreeBuffers}dispose(){this.freeBuffers.forEach((e,t)=>{e.forEach(e=>{e.destroy()})}),this.usedBuffers.forEach((e,t)=>{e.forEach(e=>{e.destroy()})}),this.freeBuffers=new Map,this.usedBuffers=new Map,this.numUsedBuffers=0,this.numFreeBuffers=0,this.numBytesUsed=0,this.numBytesAllocated=0}}function Wi(e,t){return`${e}_${t}`}class Vi{constructor(e){this.device=e,this.numUsedTextures=0,this.numFreeTextures=0,this.freeTextures=new Map,this.usedTextures=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireTexture(e,t,n,r){const i=e*t*Hi(n),s=Gi(e,t,n,r);if(this.freeTextures.has(s)||this.freeTextures.set(s,[]),this.usedTextures.has(s)||this.usedTextures.set(s,[]),this.numBytesUsed+=i,this.numUsedTextures++,this.freeTextures.get(s).length>0){this.numFreeTextures--;const e=this.freeTextures.get(s).shift();return this.usedTextures.get(s).push(e),e}this.numBytesAllocated+=i;const o=this.device.createTexture({size:[e,t],format:n,usage:r});return this.usedTextures.get(s).push(o),o}releaseTexture(e,t,n,r,i){if(0===this.freeTextures.size)return;const s=Gi(t,n,r,i);this.freeTextures.has(s)||this.freeTextures.set(s,[]),this.freeTextures.get(s).push(e),this.numFreeTextures++,this.numUsedTextures--;const o=this.usedTextures.get(s),a=o.indexOf(e);if(a<0)throw new Error("Cannot release a texture that was never provided by this texture manager");o.splice(a,1);const u=t*n*Hi(r);this.numBytesUsed-=u}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){this.freeTextures.forEach((e,t)=>{e.forEach(e=>{e.destroy()})}),this.usedTextures.forEach((e,t)=>{e.forEach(e=>{e.destroy()})}),this.freeTextures=new Map,this.usedTextures=new Map,this.numUsedTextures=0,this.numFreeTextures=0,this.numBytesUsed=0,this.numBytesAllocated=0}}function Gi(e,t,n,r){return`${e}_${t}_${n}_${r}`}function Hi(e){if("rgba8unorm"===e)return 16;throw new Error(e+" is not supported!")}function Ki(e,t){if(Math.max(...e)>3)throw new Error("Cannot symbolically compute strides for rank > 4 tensor.");const n=e.length,r=e.map(e=>`${t}[${e}]`),i=new Array(n-1);i[n-2]=r[n-1];for(let e=n-3;e>=0;--e)i[e]=`(${i[e+1]} * ${r[e+1]})`;return i}const Xi=(e,t,n)=>"int32"===n?`atomicAdd(${e}, bitcast<i32>(${t}));`:`\n          {\n            var oldValue = 0;\n            loop {\n              let newValueF32 = bitcast<f32>(oldValue) + (${t});\n              let newValue = bitcast<i32>(newValueF32);\n              let res = atomicCompareExchangeWeak(${e}, oldValue, newValue);\n              if res.exchanged {\n                break;\n              }\n              oldValue = res.old_value;\n            }\n          }`,qi=(e,t,n,i)=>{const s=function(e,t,n){const i=[],s=n.workgroupSize[0]*n.workgroupSize[1]*n.workgroupSize[2];if(i.push(`\n\n      var<private> localId: vec3<u32>;\n      var<private> localIndex: u32;\n      var<private> globalId: vec3<u32>;\n      var<private> numWorkgroups: vec3<u32>;\n      var<private> workgroupId: vec3<u32>;\n\n      // Only used when the y/z dimension of workgroup size is 1.\n      fn getGlobalIndex() -> i32 {\n        ${rs(n)?"  return i32(globalId.x);":`  return i32((workgroupId.z * numWorkgroups.x * numWorkgroups.y +\n                workgroupId.y * numWorkgroups.x + workgroupId.x) * ${s}u +\n                localIndex);\n        `}\n      }\n    `),n.isFromPixels){i.push(`\n        struct Uniform {\n          size            : i32,\n          numChannels     : i32,\n          outShapeStrides : vec2<i32>,\n        };\n\n        @group(0) @binding(0) var<storage, read_write> result: array<${is(t.dtype,n.isVec4)}>;\n        @group(0) @binding(2) var<uniform> uniforms: Uniform;\n      `);const e=ss(n);return[Ji,i.join("\n"),ts(t.shape),n.getUserCode(),Zi(e,n)].join("\n")}let o="struct Uniforms { NAN : f32, INFINITY : f32, ";n.variableNames.forEach((t,n)=>{const r=ji(e[n].shape.length);o+=`${t.charAt(0).toLowerCase()+t.slice(1)}Shape : ${r}, `});const a=ji(t.shape.length);o+=`outShape : ${a}, `;const u=ji(t.shape.length-1);o+=`\n         outShapeStrides: ${u}, `,n.size&&(o+="size : i32, ");n.uniforms&&(o+=n.uniforms);o+="};",o=function(e){e=e.replace(/(\w+)\s*:\s*vec(5|6)/g,e=>"@align(16) "+e);return e=e.replace(/vec(5|6)\s*,\s*(\w+)/g,(e,t,n)=>`vec${t}, @align(16) ${n}`)}(o),i.push(o),n.atomic?i.push("\n      @group(0) @binding(0) var<storage, read_write> result: array<atomic<i32>>;\n    "):i.push(`\n      @group(0) @binding(0) var<storage, read_write> result: array<${is(t.dtype,n.isVec4)}>;\n    `);n.variableNames.forEach((t,r)=>{i.push(`\n      @group(0) @binding(${1+r}) var<storage, read> ${t}: array<${n.variableTypes?n.variableTypes[r]:is(e[r].dtype,n.isVec4)}>;\n        `)}),""!==o&&i.push(`\n      @group(0) @binding(${1+n.variableNames.length}) var<uniform> uniforms: Uniforms;\n      `);const l=function(e,t){const{x:n,y:r=[],z:i=[]}=t,s=e.length,o=n.length+r.length+i.length;if(o!==s)return"";if(n.length===s){const e=ji(s);return`fn getOutputCoords() -> ${e}{\n    let globalIndex = getGlobalIndex();\n    return getCoordsFromIndex(globalIndex);\n  }\n  `}let a="";const u=[n,r,i];for(let e=0;e<u.length;e++){const t=u[e];if(0!==t.length)if(1===t.length)a+=`let d${t[0]} = i32(globalId[${e}]);`;else{const n=Ki(t,"uniforms.outShape");a+=`var index${e} = i32(globalId[${e}]);`;for(let r=0;r<n.length;r++)a+=`let d${t[r]} = index${e} / ${n[r]};`,r===n.length-1?a+=`let d${t[r+1]} = index${e} - d${t[r]} * ${n[r]};`:a+=`index${e} = index${e} - d${t[r]} * ${n[r]};`}}const l=[];for(let e=0;e<o;e++)l.push("d"+e);const h=ji(o);let c=`fn getOutputCoords() -> ${h} {\n  ${a}\n`;0===l.length?c+=`return ${h}(0); }`:c+=`return ${h}(${l.join(",")}); }`;return c}(t.shape,n.dispatchLayout),h=[Ji,i.join("\n")+es,ts(t.shape),l,ns(t.shape.length)];n.atomic||h.push(function(e,t,n){const r=e.length,i=is(t,n);let s;s=n?`fn setOutputAtIndex(flatIndex : i32, value : vec4<f32>) {\n      result[flatIndex] = ${i}(value);\n    }\n    fn setOutputAtIndexI32(flatIndex : i32, value : vec4<i32>) {\n      result[flatIndex] = ${i}(value);\n    }`:`fn setOutputAtIndex(flatIndex : i32, value : f32) {\n      result[flatIndex] = ${i}(value);\n    }\n    fn setOutputAtIndexI32(flatIndex : i32, value : i32) {\n      result[flatIndex] = ${i}(value);\n    }`;if(r>=2){const e=["d0","d1","d2","d3","d4","d5"].slice(0,r),t=ji(r);s+=n?`\n      fn setOutputAtCoords(${e.map(e=>e+" : i32").join(", ")}, value : vec4<f32>) {\n        let flatIndex = getOutputIndexFromCoords(${t}(${e.join(", ")}));\n        setOutputAtIndex(flatIndex / 4, value);\n      }\n      fn setOutputAtCoordsI32(${e.map(e=>e+" : i32").join(", ")}, value : vec4<i32>) {\n        let flatIndex = getOutputIndexFromCoords(${t}(${e.join(", ")}));\n        setOutputAtIndexI32(flatIndex / 4, value);\n      }\n    `:`\n      fn setOutputAtCoords(${e.map(e=>e+" : i32").join(", ")}, value : f32) {\n        let flatIndex = getOutputIndexFromCoords(${t}(${e.join(", ")}));\n        setOutputAtIndex(flatIndex, value);\n      }\n      fn setOutputAtCoordsI32(${e.map(e=>e+" : i32").join(", ")}, value : i32) {\n        let flatIndex = getOutputIndexFromCoords(${t}(${e.join(", ")}));\n        setOutputAtIndexI32(flatIndex, value);\n      }\n    `}return s}(t.shape,t.dtype,n.isVec4));const c=e.map((e,i)=>function(e,t,n,i){let s=function(e,t){const n=e.name,r=e.shape.length,i=ji(r),s="get"+n.charAt(0).toUpperCase()+n.slice(1),o=["d0","d1","d2","d3","d4","d5"].slice(0,r),a=o.map(e=>e+" : i32").join(", ");if(r<1)return t?`\n        fn ${s}() -> vec4<f32> {\n          return vec4<f32>(${n}[0]);\n        }\n      `:`\n      fn ${s}() ->f32 {\n        return f32(${n}[0]);\n      }\n    `;const u=`uniforms.${n.charAt(0).toLowerCase()+n.slice(1)}Shape`;let l=r+"D";0===r&&(l="1D");if(t)return`\n      fn ${s}(${a}) -> vec4<f32> {\n        return vec4<f32>(${n}[getIndexFromCoords${l}(${i}(${o.join(",")}),\n          ${u}) / 4]);\n      }\n      `;return`\n    fn ${s}(${a}) -> f32 {\n      return f32(${n}[getIndexFromCoords${l}(${i}(${o.join(",")}),\n        ${u})]);\n    }\n   `}(e,n);e.shape.length<=t.length&&(s+=function(e,t,n,i){const s=e.name,o=s.charAt(0).toUpperCase()+s.slice(1),a="get"+o+"ByOutput",u=e.shape.length,l=t.length,h=ji(l);if(r.arraysEqual(e.shape,t)&&i)return n?`\n      fn ${a}Index(globalIndex : i32) -> vec4<f32> {\n        return vec4<f32>(${s}[globalIndex]);\n      }\n\n      fn ${a}Coords(coords : ${h}) -> vec4<f32> {\n        return vec4<f32>(${s}[${l>1?"getOutputIndexFromCoords(coords)":"coords"} / 4]);\n      }\n      `:`\n    fn ${a}Index(globalIndex : i32) -> f32 {\n      return f32(${s}[globalIndex]);\n    }\n\n    fn ${a}Coords(coords : ${h}) -> f32 {\n      return f32(${s}[${l>1?"getOutputIndexFromCoords(coords)":"coords"}]);\n    }\n    `;const c=z.getBroadcastDims(e.shape,t),d=l-u;let p="";if(0===u)return n?`\n    fn ${a}Index(globalIndex : i32) -> vec4<f32> {\n      return get${o}();\n    }\n\n    fn ${a}Coords(coords : ${h}) -> vec4<f32> {\n      return get${o}();\n    }\n  `:`\n    fn ${a}Index(globalIndex : i32) -> f32{\n      return get${o}();\n    }\n\n    fn ${a}Coords(coords : ${h}) -> f32{\n      return get${o}();\n    }\n  `;p=l<2&&c.length>=1?"coords = 0;":c.map(e=>`coords.${Yi(e+d)} = 0;`).join("\n");let f="";if(l<2&&u>0)f="coords";else if(l>1){const t=ji(u),n=e.shape.map((e,t)=>"coords."+Yi(t+d)).join(", ");f=`${t}(${n})`}else f="coords";const m=`uniforms.${s.charAt(0).toLowerCase()+s.slice(1)}Shape`,g=u+"D";if(n)return`\n    fn ${a}Index(globalIndex : i32) -> vec4<f32> {\n      var coords = getCoordsFromIndex(globalIndex);\n      ${p}\n      return ${s}[getIndexFromCoords${g}(${f}, ${m}) / 4];\n    }\n\n    fn ${a}Coords(coordsIn : ${h}) -> vec4<f32> {\n      var coords = coordsIn;\n      ${p}\n      return ${s}[getIndexFromCoords${g}(${f}, ${m}) / 4];\n    }\n  `;return`\n  fn ${a}Index(globalIndex : i32) -> f32 {\n    var coords = getCoordsFromIndex(globalIndex);\n    ${p}\n    return f32(${s}[getIndexFromCoords${g}(${f}, ${m})]);\n  }\n\n  fn ${a}Coords(coordsIn : ${h}) -> f32 {\n    var coords = coordsIn;\n    ${p}\n    return f32(${s}[getIndexFromCoords${g}(${f}, ${m})]);\n  }\n`}(e,t,n,i));return s}(e,t.shape,n.variableTypes?"vec4<f32>"===n.variableTypes[i]:n.isVec4,n.dispatchLayout.x.length===t.shape.length)).join("\n");h.push(c),h.push(n.getUserCode());const d=ss(n);h.push(Zi(d,n));return h.join("\n")}(n,{dtype:i.dtype,shape:i.shape},t),o=e.createShaderModule({code:s,label:t.constructor.name});return e.createComputePipeline({compute:{module:o,entryPoint:"_start"},label:t.constructor.name,layout:"auto"})};function ji(e){if(e<=1)return"i32";if(2===e)return"vec2<i32>";if(3===e)return"vec3<i32>";if(4===e)return"vec4<i32>";if(5===e)return"vec5";if(6===e)return"vec6";throw Error(`GPU for rank ${e} is not yet supported`)}function Yi(e){if(0===e)return"x";if(1===e)return"y";if(2===e)return"z";if(3===e)return"w";if(4===e)return"u";if(5===e)return"v";throw Error(`Index ${e} is not yet supported`)}function Qi(...e){let t;switch(e.length){case 0:t="\n        fn main()\n      ";break;case 1:t=`\n        fn main(${e[0]} : i32)\n      `;break;default:throw Error("Unreachable")}return t}function Zi(e,t){let n;return n=`\n     ${function(e){return`\n  @compute @workgroup_size(${e.workgroupSize[0]}, ${e.workgroupSize[1]}, ${e.workgroupSize[2]})\n`}(t)}\n      fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,\n                @builtin(global_invocation_id) GlobalId : vec3<u32>,\n                @builtin(local_invocation_index) LocalIndex: u32,\n                @builtin(workgroup_id) WorkgroupId : vec3<u32>,\n                @builtin(num_workgroups) NumWorkgroups : vec3<u32>) {\n        localId = LocalId;\n        localIndex = LocalIndex;\n        globalId = GlobalId;\n        numWorkgroups = NumWorkgroups;\n        workgroupId = WorkgroupId;\n        ${e?"main(getGlobalIndex());":"main();"};\n      }\n    `,n}const Ji="\n  struct vec5 {x: i32, y: i32, z: i32, w: i32, u: i32};\n  struct vec6 {x: i32, y: i32, z: i32, w: i32, u: i32, v: i32};\n\n  // Checks whether coordinates lie within the bounds of the shape.\n  fn coordsInBounds2D(coord : vec2<i32>, shape : vec2<i32>) -> bool {\n    return all(coord >= vec2<i32>(0)) && all(coord < shape);\n  }\n  fn coordsInBounds3D(coord : vec3<i32>, shape : vec3<i32>) -> bool {\n    return all(coord >= vec3<i32>(0)) && all(coord < shape);\n  }\n  fn coordsInBounds4D(coord : vec4<i32>, shape : vec4<i32>) -> bool {\n    return all(coord >= vec4<i32>(0)) && all(coord < shape);\n  }\n\n  fn getIndexFromCoords1D(coord : i32, shape : i32) -> i32 {\n    return coord;\n  }\n  fn getIndexFromCoords2D(coords : vec2<i32>, shape : vec2<i32>) -> i32 {\n    return dot(coords, vec2<i32>(shape.y, 1));\n  }\n  fn getIndexFromCoords3D(coords : vec3<i32>, shape : vec3<i32>) -> i32 {\n    return dot(coords, vec3<i32>(shape.y * shape.z, shape.z, 1));\n  }\n  fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\n    return dot(coords, vec4<i32>(\n        shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\n  }\n  fn getIndexFromCoords5D(coords : vec5, shape : vec5) -> i32 {\n    let shapeStrides: vec5 = vec5(shape.y * shape.z * shape.w * shape.u, shape.z * shape.w * shape.u, shape.w * shape.u, shape.u, 1);\n    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u;\n  }\n  fn getIndexFromCoords6D(coords : vec6, shape : vec6) -> i32 {\n    let shapeStrides: vec6 = vec6(shape.y * shape.z * shape.w * shape.u * shape.v, shape.z * shape.w * shape.u * shape.v, shape.w * shape.u * shape.v, shape.u * shape.v, shape.v, 1);\n    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u + coords.v*shapeStrides.v;\n  }\n\n  fn idiv(a: i32, b: i32, sign: f32) -> i32 {\n    var res: i32 = a / b;\n    let modulo: i32 = a % b;\n    if (sign < 0. && modulo != 0) {\n      res = res - 1;\n    }\n    return res;\n  }\n\n  // NaN defination in IEEE 754-1985 is :\n  //   - sign = either 0 or 1.\n  //   - biased exponent = all 1 bits.\n  //   - fraction = anything except all 0 bits (since all 0 bits represents infinity).\n  // https://en.wikipedia.org/wiki/IEEE_754-1985#Representation_of_non-numbers\n  fn isnan(val: f32) -> bool {\n    let floatToUint: u32 = bitcast<u32>(val);\n    return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n  }\n  fn isnanVec4(val : vec4<f32>) -> vec4<bool> {\n    let floatToUint: vec4<u32> = bitcast<vec4<u32>>(val);\n    return (floatToUint & vec4<u32>(0x7fffffffu)) > vec4<u32>(0x7f800000u);\n  }\n",es="\n  fn isinf(val: f32) -> bool {\n    return abs(val) == uniforms.INFINITY;\n  }\n";function ts(e){const t=e.length;if(t<=1)return"fn getCoordsFromIndex(index : i32) -> i32 { return index; }";const n=r.computeStrides(e),i=ji(t),s=[];for(let e=0;e<t;e++)s.push("d"+e);if(1===n.length)return"    fn getCoordsFromIndex(index : i32) -> vec2<i32> {\n      let d0 = index / uniforms.outShapeStrides; let d1 = index - d0 * uniforms.outShapeStrides;\n      return vec2<i32>(d0, d1);\n    }";let o;return o="var index2 = index;"+n.map((e,t)=>`${`let ${s[t]} = index2 / uniforms.outShapeStrides.${Yi(t)}`}; ${t===n.length-1?`let ${s[t+1]} = index2 - ${s[t]} * uniforms.outShapeStrides.${Yi(t)}`:`index2 = index2 - ${s[t]} * uniforms.outShapeStrides.${Yi(t)}`};`).join(""),`\n    fn getCoordsFromIndex(index : i32) -> ${i} {\n      ${o}\n      return ${i}(${s.join(",")});\n    }\n  `}function ns(e){let t="";switch(e){case 0:case 1:t+="\n        fn getOutputIndexFromCoords(coords : i32) -> i32 {\n          return coords;\n        }\n        ";break;case 2:t+="\n        fn getOutputIndexFromCoords(coords : vec2<i32>) -> i32 {\n          return dot(coords, vec2<i32>(uniforms.outShapeStrides, 1));\n        }\n        ";break;case 3:t+="\n        fn getOutputIndexFromCoords(coords : vec3<i32>) -> i32 {\n          return dot(coords, vec3<i32>(uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, 1));\n        }\n        ";break;case 4:t+="\n        fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\n          return dot(coords, vec4<i32>(\n            uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, uniforms.outShapeStrides.z, 1));\n        }\n        ";break;case 5:t+="\n        fn getOutputIndexFromCoords(coords : vec5) -> i32 {\n          return coords.x * uniforms.outShapeStrides.x +\n              coords.y * uniforms.outShapeStrides.y +\n              coords.z * uniforms.outShapeStrides.z +\n              coords.w * uniforms.outShapeStrides.w +\n              coords.u;\n        }\n        ";break;case 6:t+="\n        fn getOutputIndexFromCoords(coords : vec6) -> i32 {\n          return coords.x * uniforms.outShapeStrides.x +\n              coords.y * uniforms.outShapeStrides.y +\n              coords.z * uniforms.outShapeStrides.z +\n              coords.w * uniforms.outShapeStrides.w +\n              coords.u * uniforms.outShapeStrides.u +\n              coords.v;\n        }\n        ";break;default:r.assert(!1,()=>`Unsupported ${e}D shape`)}return t}function rs(e){return 1===e.dispatch[1]&&1===e.dispatch[2]}function is(e,t){return"float32"===e?t?"vec4<f32>":"f32":"int32"===e||"bool"===e?t?"vec4<i32>":"i32":e}function ss(e){return(!e.dispatchLayout.hasOwnProperty("y")||0===e.dispatchLayout.y.length)&&(!e.dispatchLayout.hasOwnProperty("z")||0===e.dispatchLayout.z.length)}const os=e=>{let t=1;for(let n=0;n<e.length;n++)t*=e[n];return t};function as(e,t,n=[1,1,1],r=[1,1,1]){const[i,s,o]=[Math.ceil(os(e.x.map(e=>t[e]))/(n[0]*r[0])),e.y?Math.ceil(os(e.y.map(e=>t[e]))/(n[1]*r[1])):1,e.z?Math.ceil(os(e.z.map(e=>t[e]))/(n[2]*r[2])):1];return[i,s,o]}function us(e,t,n=!1){if(n)return[8,8,1];const r=os(e.x.map(e=>t[e])),i=os(e.y.map(e=>t[e]));return r<=4?[4,16,1]:i<=4?[16,4,1]:[16,16,1]}function ls(e,t,n=!1){if(n)return[4,4,1];const r=os(e.x.map(e=>t[e])),i=os(e.y.map(e=>t[e]));return r<=4?[1,2,1]:i<=4?[2,1,1]:[2,2,1]}function hs(e){return{x:e.map((e,t)=>t)}}function cs(e){if("float32"===e||"int32"===e||"bool"===e||"string"===e)return 4;if("complex64"===e)return 8;throw new Error("Unknown dtype "+e)}function ds(){return("undefined"!=typeof window||"undefined"!=typeof WorkerGlobalScope)&&!!navigator.gpu}var ps;!function(e){e[e.MatMulReduceProgram=0]="MatMulReduceProgram",e[e.MatMulSplitKProgram=1]="MatMulSplitKProgram",e[e.MatMulSmallOutputSizeProgram=2]="MatMulSmallOutputSizeProgram",e[e.MatMulPackedProgram=3]="MatMulPackedProgram",e[e.MatMulMax=4]="MatMulMax"}(ps||(ps={}));const fs=A().getNumber("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD");class ms extends N{constructor(e,t){if(super(),this.commandQueueOwnedIds=new WeakSet,this.dispatchNumberInEncoder=0,this.disposed=!1,this.downloadWaitMs=0,this.tensorDataPendingDisposal=[],this.stagingPendingDisposal=[],this.uniformPendingDisposal=[],this.uploadWaitMs=0,!ds())throw new Error("WebGPU is not supported on this device");this.pipelineCache={},this.device=e,this.queue=e.queue,this.currentCommandEncoder=null,this.currentComputePass=null,this.supportTimeQuery=e.features.has("timestamp-query-inside-passes"),this.adapterInfo=new Di(t),this.thresholdToIncreaseWorkgroups=this.adapterInfo.intelGPUGeneration>=12?16:8,this.bufferManager=new Ui(this.device),this.textureManager=new Vi(this.device),this.tensorMap=new M(this,g()),this.supportTimeQuery&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:2})),A().getBool("WEBGPU_USE_PROFILE_TOOL")&&(this.dummyCanvas=document.createElement("canvas"),this.dummyCanvas.width=1,this.dummyCanvas.height=1,this.dummyContext=this.dummyCanvas.getContext("webgpu"),this.dummyContext.configure({device:e,format:"bgra8unorm"}),document.body.appendChild(this.dummyCanvas))}nextDataId(){return ms.nextDataId++}floatPrecision(){return 32}defaultGpuBufferUsage(){return GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST}disposeData(e,t=!1){if(this.tensorDataPendingDisposal.indexOf(e)>=0)return!1;if(!this.tensorMap.has(e))return!0;const n=this.tensorMap.get(e);if(this.decRef(e),!t&&n.refCount>0)return!1;if(this.commandQueueOwnedIds.has(e))return this.tensorDataPendingDisposal.push(e),!1;const{complexTensorInfos:r}=this.tensorMap.get(e);return null!=r&&(this.disposeData(r.real.dataId,t),this.disposeData(r.imag.dataId,t)),this.releaseResource(e),this.tensorMap.delete(e),!0}memory(){return{numBytesInGPU:this.bufferManager.numBytesUsed,numBytesAllocatedInGPU:this.bufferManager.numBytesAllocated,unreliable:!1}}releaseResource(e){const t=this.tensorMap.get(e);if(t&&t.resourceInfo)if(t.external)t.resourceInfo=null;else{if("texture"in t.resourceInfo){const e=t.resourceInfo;e.texture instanceof GPUTexture&&this.textureManager.releaseTexture(e.texture,e.width,e.height,e.format,e.usage),e.texture=null}else{const e=t.resourceInfo;this.bufferManager.releaseBuffer(e.buffer,e.size,e.usage),e.buffer=null}t.resourceInfo=null}}refCount(e){if(this.tensorMap.has(e)){return this.tensorMap.get(e).refCount}return 0}incRef(e){this.tensorMap.get(e).refCount++}decRef(e){if(this.tensorMap.has(e)){this.tensorMap.get(e).refCount--}}write(e,t,n){if("complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.tensorMap.set(r,{dtype:n,shape:t,values:e,refCount:1}),r}move(e,t,n,r,i){if("complex64"===r)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.tensorMap.set(e,{dtype:r,shape:n,values:t,refCount:i})}submitQueue(){this.ensureComputePassEnded(),this.queue.submit([this.currentCommandEncoder.finish()]),this.currentCommandEncoder=null,this.dispatchNumberInEncoder=0,this.commandQueueOwnedIds=new WeakSet,this.tensorDataPendingDisposal.forEach(e=>{this.releaseResource(e),this.tensorMap.delete(e)}),this.uniformPendingDisposal.forEach(e=>this.bufferManager.releaseBuffer(e.buffer,e.size,e.usage)),this.stagingPendingDisposal.forEach(e=>this.bufferManager.releaseUploadBuffer(e.buffer,e.size,e.usage)),this.tensorDataPendingDisposal=[],this.uniformPendingDisposal=[],this.stagingPendingDisposal=[]}ensureCommandEncoderReady(){this.currentCommandEncoder||(this.currentCommandEncoder=this.device.createCommandEncoder())}ensureComputePassEnded(){this.currentComputePass&&(this.currentComputePass.end(),this.currentComputePass=null)}getComputePass(){return this.currentComputePass||(this.currentComputePass=this.currentCommandEncoder.beginComputePass()),this.currentComputePass}async getBufferData(e,t){const n=this.bufferManager.acquireBuffer(t,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ);this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.copyBufferToBuffer(e,0,n,0,t),this.submitQueue(),await n.mapAsync(GPUMapMode.READ);const i=n.getMappedRange().slice(0);return n.unmap(),null!=n&&this.bufferManager.releaseBuffer(n,t,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ),A().getBool("WEBGPU_USE_PROFILE_TOOL")&&(r.assert(void 0!==this.dummyContext,()=>"Fail to get context for profiling tool"),this.dummyContext.getCurrentTexture()),i}convertAndCacheOnCPU(e,t){const n=this.tensorMap.get(e);return this.releaseResource(e),n.values=t,n.values}readSync(e){const t=this.tensorMap.get(e),{values:n}=t;if(null==n)throw new Error("WebGPU readSync is only available for CPU-resident tensors.");return n}async read(e){if(!this.tensorMap.has(e))throw new Error(`Tensor ${e} was not registered!`);const t=this.tensorMap.get(e),{values:n}=t;if(null!=n)return this.convertAndCacheOnCPU(e,n);let i;if("complex64"===t.dtype){const e=await Promise.all([this.read(t.complexTensorInfos.real.dataId),this.read(t.complexTensorInfos.imag.dataId)]),n=e[0],r=e[1];i=z.mergeRealAndImagArrays(n,r)}else{const e=t.resourceInfo,n=await this.getBufferData(e.buffer,e.size);i=r.convertBackendValuesAndArrayBuffer(n,t.dtype)}return this.convertAndCacheOnCPU(e,i),i}copyBuffer(e,t,n){const r=this.bufferManager.acquireBuffer(t,n);return this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.copyBufferToBuffer(e,0,r,0,t),this.submitQueue(),r}createTensorFromGPUData(e,t,n){let i=e.buffer;if("complex64"===n)throw new Error("Cannot write to a complex64 dtype. ");const s={id:this.nextDataId()};this.tensorMap.set(s,{dtype:n,shape:t,values:null,refCount:1,external:e.zeroCopy});const o=this.tensorMap.get(s),a=cs(o.dtype)*r.sizeFromShape(o.shape);if(e.buffer.size<a)throw new Error(`GPUBuffer size(${e.buffer.size}) is smaller than tensor size(${a})!`);if((e.buffer.usage&(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))!=(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))throw new Error("GPUBuffer.usage should include GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC!");return!0!==e.zeroCopy&&(i=this.copyBuffer(i,a,i.usage)),o.resourceInfo={size:i.size,usage:i.usage,buffer:i},g().makeTensorFromDataId(s,t,n,this)}readToGPU(e){const t=this.tensorMap.get(e),{values:n,dtype:r,shape:i,resourceInfo:s}=t;if("complex64"===r)throw new Error("Does not support reading buffer for complex64 dtype.");if(null==s)throw null!=n?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const o=s.size,a=this.bufferManager.acquireBuffer(o,s.usage);this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.copyBufferToBuffer(s.buffer,0,a,0,o),this.submitQueue();const u=this.makeTensorInfo(i,r),l=g().makeTensorFromTensorInfo(u);return this.tensorMap.get(u.dataId).resourceInfo={size:o,usage:this.defaultGpuBufferUsage(),buffer:a},{tensorRef:l,buffer:a,bufSize:o}}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map(e=>r.decodeString(e));return F(e.shape,e.dtype,n)}catch(e){throw new Error("Failed to decode encoded string bytes into utf-8")}return F(e.shape,e.dtype,t)}async time(e){this.supportTimeQuery||console.warn("This device doesn't support timestamp-query-inside-passes extension. Start Chrome browser with flag --disable-dawn-features=disallow_unsafe_apis then try again. Otherwise, zero will be shown for the kernel time when profiling mode is enabled. Using performance.now is not workable for webgpu since it doesn't support synchronous data read from GPU.");const t=this.activeTimers,n=[];let i=!1;null==this.programTimersStack?(this.programTimersStack=n,i=!0):this.activeTimers.push(n),this.activeTimers=n,e();const s=r.flatten(this.activeTimers.map(e=>e.query)).filter(e=>null!=e),o=r.flatten(this.activeTimers.map(e=>e.name)).filter(e=>null!=e);this.activeTimers=t,i&&(this.programTimersStack=null);const a={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null},u=await Promise.all(s);return a.kernelMs=r.sum(u),a.getExtraProfileInfo=()=>u.map((e,t)=>({name:o[t],ms:e})).map(e=>`${e.name}: ${e.ms}`).join(", "),this.uploadWaitMs=0,this.downloadWaitMs=0,a}makeTensorInfo(e,t,n){"string"===t&&null!=n&&n.length>0&&r.isString(n[0])&&(n=n.map(e=>r.encodeString(e)));return{dataId:this.write(n,e,t),shape:e,dtype:t}}tensorToBinding(e){if(!e)return null;const t=this.tensorMap.get(e.dataId);if("texture"in t.resourceInfo){const e=t.resourceInfo;return e.texture instanceof GPUExternalTexture?e.texture:e.texture.createView()}const n=t.resourceInfo;return{offset:0,size:n.size,buffer:n.buffer}}async getQueryTime(e){return this.supportTimeQuery?this.getTimeFromQuerySet(e):0}uploadToGPU(e){const t=this.tensorMap.get(e);if(t.resourceInfo)return;const n=cs(t.dtype)*r.sizeFromShape(t.shape),i=this.bufferManager.acquireBuffer(n,this.defaultGpuBufferUsage());if(t.resourceInfo={size:n,usage:this.defaultGpuBufferUsage(),buffer:i},t.values){const e=this.bufferManager.acquireUploadBuffer(n,GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC),r=e.getMappedRange();"int32"===t.dtype||"bool"===t.dtype?new Int32Array(r).set(t.values):new Float32Array(r).set(t.values),e.unmap(),this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.copyBufferToBuffer(e,0,i,0,n);const s={size:n,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC,buffer:e};this.stagingPendingDisposal.push(s)}}makeUniforms(e){let t=0,n=0;const i=[];let s=1;e.forEach(e=>{let o;switch(0===e.data.length&&(e.data=[1]),e.data.length){case 1:o=4;break;case 2:o=8;break;case 3:case 4:case 5:case 6:o=16;break;default:r.assert(!1,()=>`Unsupported ${e.data.length}D shape`)}5!==n&&6!==n||(o=16),o>s&&(s=o),t=Math.ceil(t/o)*o,n=e.data.length,i.push(t),t+=4*e.data.length}),t=Math.ceil(t/s)*s;const o=new ArrayBuffer(t);e.forEach((e,t)=>{const n=i[t];"int32"===e.type?new Int32Array(o,n,e.data.length).set(e.data):"uint32"===e.type?new Uint32Array(o,n,e.data.length).set(e.data):new Float32Array(o,n,e.data.length).set(e.data)});const a=this.bufferManager.acquireBuffer(t,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.queue.writeBuffer(a,0,o,0,t);const u={size:t,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM,buffer:a};return this.uniformPendingDisposal.push(u),{offset:0,size:t,buffer:a}}runWebGPUProgram(e,t,n,i,s){if(s||(s=this.makeTensorInfo(e.outputShape,n)),0===r.sizeFromShape(s.shape))return this.tensorMap.get(s.dataId).values=r.getTypedArrayFromDType(s.dtype,0),s;this.uploadToGPU(s.dataId),e.dispatch=((e,t)=>{const n=e.limits.maxComputeWorkgroupsPerDimension,i=t.dispatchLayout,s=t.dispatch;if(s.every(e=>e<=n))return s;r.assert(s[0]>n&&void 0===i.y&&void 0===i.z,()=>"Dispatch size exceeds WebGPU limits in Y or Z dimension.");let o=Math.ceil(Math.sqrt(s[0]));return o>n?(o=Math.ceil(Math.cbrt(s[0])),r.assert(o<=n,()=>"Total dispatch size exceeds WebGPU maximum."),[o,o,o]):[o,o,1]})(this.device,e);let o=[],a=[];if(!e.isFromPixels){o.push({type:"float32",data:[NaN]},{type:"float32",data:[1/0]}),a=t.concat(s).map(e=>e.shape);const n="int32";a.map(e=>{o.push({type:n,data:e})});const i=r.computeStrides(s.shape);if(o.push({type:n,data:i}),e.size){const t=r.sizeFromShape(e.outputShape);o.push({type:n,data:[e.isVec4?t/4:t]})}}const u=t.map((t,n)=>{if("complex64"===t.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");return this.uploadToGPU(t.dataId),{dtype:this.tensorMap.get(t.dataId).dtype,shape:t.shape,name:e.variableNames[n]}}),l=function(e,t,n,i){let s=e.shaderKey;if(e.isFromPixels)return s;const o=n.map(e=>e.dtype).concat(i.dtype),a=n.map(e=>z.getBroadcastDims(e.shape,i.shape)),u=n.map(e=>r.arraysEqual(e.shape,i.shape)).join("_"),l=a.map(e=>e.join("_")).join(";"),h=rs(e)?"flatDispatch":"";return s+="_"+(e.workgroupSize?e.workgroupSize.join(","):"")+t.map(e=>e.length).join(",")+o.join(",")+e.variableNames.join(",")+l+u+h,s}(e,a,u,s);let h;l in this.pipelineCache?h=this.pipelineCache[l]:(h=qi(this.device,e,u,s),this.pipelineCache[l]=h),i&&(o=[...o,...i]);const c=[this.tensorToBinding(s),...t.map(e=>this.tensorToBinding(e)),this.makeUniforms(o)],d=this.device.createBindGroup({layout:h.getBindGroupLayout(0),entries:c.map((e,t)=>({binding:t,resource:e}))});this.ensureCommandEncoderReady();const p=this.getComputePass(),f=null!=this.activeTimers;return f&&this.supportTimeQuery&&p.writeTimestamp(this.querySet,0),p.setPipeline(h),p.setBindGroup(0,d),p.dispatchWorkgroups(e.dispatch[0],e.dispatch[1],e.dispatch[2]),f&&this.supportTimeQuery&&p.writeTimestamp(this.querySet,1),this.dispatchNumberInEncoder++,t.forEach(e=>{this.commandQueueOwnedIds.add(e.dataId)}),this.commandQueueOwnedIds.add(s.dataId),A().get("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE")<=this.dispatchNumberInEncoder&&this.submitQueue(),f&&this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(this.querySet)}),s}async getTimeFromQuerySet(e){const t=this.bufferManager.acquireBuffer(16,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE),n=this.bufferManager.acquireBuffer(16,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.resolveQuerySet(e,0,2,t,0),this.currentCommandEncoder.copyBufferToBuffer(t,0,n,0,16),this.submitQueue(),await n.mapAsync(GPUMapMode.READ);const r=new BigUint64Array(n.getMappedRange()),i=Number(r[1]-r[0]);return n.unmap(),this.bufferManager.releaseBuffer(n,16,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST),this.bufferManager.releaseBuffer(t,16,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE),i/1e6}shouldExecuteOnCPU(e,t=fs){return A().getBool("WEBGPU_CPU_FORWARD")&&e.every(e=>null==this.tensorMap.get(e.dataId).resourceInfo&&r.sizeFromShape(e.shape)<t)}numDataIds(){return this.tensorMap.numDataIds()-this.tensorDataPendingDisposal.length}dispose(){this.disposed||(this.bufferManager.dispose(),this.textureManager.dispose(),this.disposed=!0)}}var gs;ms.nextDataId=0,ds()&&E("webgpu",async()=>{A().set("CHECK_COMPUTATION_FOR_ERRORS",!1);const e={powerPreference:A().get("WEBGPU_USE_LOW_POWER_GPU")?"low-power":"high-performance"},t=await navigator.gpu.requestAdapter(e),n={};t.features.has("timestamp-query-inside-passes")&&(n.requiredFeatures=["timestamp-query-inside-passes"]);const r=t.limits;n.requiredLimits={maxComputeWorkgroupStorageSize:r.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:r.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:r.maxStorageBufferBindingSize};const i=await t.requestDevice(n),s=await t.requestAdapterInfo();return new ms(i,s)},3),function(e){e[e.ADD=0]="ADD",e[e.ATAN2=1]="ATAN2",e[e.COMPLEX_MULTIPLY_IMAG=2]="COMPLEX_MULTIPLY_IMAG",e[e.COMPLEX_MULTIPLY_REAL=3]="COMPLEX_MULTIPLY_REAL",e[e.DIV=4]="DIV",e[e.EQUAL=5]="EQUAL",e[e.GREATER=6]="GREATER",e[e.GREATER_EQUAL=7]="GREATER_EQUAL",e[e.INT_DIV=8]="INT_DIV",e[e.LESS=9]="LESS",e[e.LESS_EQUAL=10]="LESS_EQUAL",e[e.LOGICAL_AND=11]="LOGICAL_AND",e[e.LOGICAL_OR=12]="LOGICAL_OR",e[e.MAX=13]="MAX",e[e.MIN=14]="MIN",e[e.MOD=15]="MOD",e[e.MUL=16]="MUL",e[e.NOT_EQUAL=17]="NOT_EQUAL",e[e.POW=18]="POW",e[e.PRELU=19]="PRELU",e[e.SQUARED_DIFFERENCE=20]="SQUARED_DIFFERENCE",e[e.SUB=21]="SUB"}(gs||(gs={}));const xs="\n  if (isnan(a)) { return a; }\n  if (isnan(b)) { return b; }\n  ",ys="\n  resultTemp = select(\n      resultTemp, vec4<f32>(valueForNaN),\n      vec4<bool>(isNaN) | isnanVec4(a) | isnanVec4(b));\n  ",bs=`\n  ${xs}\n  if (b == 0.) {\n    return uniforms.NAN;\n  }\n  var resultTemp = a % b;\n  if ((a < 0. && b < 0.) || (a >= 0. && b > 0.)) {\n    return resultTemp;\n  } else {\n    return (resultTemp + b) % b;\n  }\n`,ws=`\n  let isNaN = !vec4<bool>(b);\n  let valueForNaN = uniforms.NAN;\n  var resultTemp = vec4<f32>(a % b);\n  ${ys}\n\n  if (!((a[0] < 0. && b[0] < 0.) || (a[0] >= 0. && b[0] > 0.))) {\n    resultTemp[0] = (resultTemp[0] + b[0]) % b[0];\n  }\n  if (!((a[1] < 0. && b[1] < 0.) || (a[1] >= 0. && b[1] > 0.))) {\n    resultTemp[1] = (resultTemp[1] + b[1]) % b[1];\n  }\n  if (!((a[2] < 0. && b[2] < 0.) || (a[2] >= 0. && b[2] > 0.))) {\n    resultTemp[2] = (resultTemp[2] + b[2]) % b[2];\n  }\n  if (!((a[3] < 0. && b[3] < 0.) || (a[3] >= 0. && b[3] > 0.))) {\n    resultTemp[3] = (resultTemp[3] + b[3]) % b[3];\n  }\n\n  return resultTemp;\n`,vs=`\n  var resultTemp = vec4<f32>(a != b);\n  let valueForNaN = 1.0;\n  ${ys}\n\n  return resultTemp;\n`,ks=`\n  let isModRound1Bool = vec4<i32>(round(abs(b) % vec4<f32>(2.0))) == vec4<i32>(1);\n  let isModRound1 = vec4<f32>(isModRound1Bool);\n  let multiplier = sign(a) * isModRound1 + (vec4<f32>(1.0) - isModRound1);\n  var resultTemp = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  let isExpZero = b == vec4<f32>(0.0);\n  if (isExpZero.r) {\n    resultTemp.r = 1.0;\n  }\n  if (isExpZero.g) {\n    resultTemp.g = 1.0;\n  }\n  if (isExpZero.b) {\n    resultTemp.b = 1.0;\n  }\n  if (isExpZero.a) {\n    resultTemp.a = 1.0;\n  }\n  let isNaN = (a < vec4<f32>(0.0)) & (floor(b) < b);\n  let valueForNaN = uniforms.NAN;\n  ${ys}\n  return resultTemp;\n`;function Ss(e,t,n="uniforms.NAN"){const r=t?ys:xs;return t?`\n    let valueForNaN = ${n};\n    var resultTemp = vec4<f32>(${e}(a, b));\n    `+r+"\n    return resultTemp;\n  ":r+`\n    return ${e}(a, b);\n  `}function Is(e,t){switch(e){case gs.ADD:return"return a + b;";case gs.ATAN2:return Ss("atan2",t);case gs.COMPLEX_MULTIPLY_IMAG:return"return areal * bimag + aimag * breal;";case gs.COMPLEX_MULTIPLY_REAL:return"return areal * breal - aimag * bimag;";case gs.DIV:return"return a / b;";case gs.EQUAL:return t?"return vec4<f32>(a == b);":"return f32(a == b);";case gs.GREATER:return t?"return vec4<f32>(a > b);":"return f32(a > b);";case gs.GREATER_EQUAL:return t?"return vec4<f32>(a >= b);":"return f32(a >= b);";case gs.INT_DIV:return t?"\n  let ia = vec4<i32>(round(a));\n  let ib = vec4<i32>(round(b));\n  let cond = ib != vec4<i32>(0);\n  var resultTemp = vec4<i32>(0);\n  let s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    resultTemp[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    resultTemp[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    resultTemp[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    resultTemp[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4<f32>(resultTemp);\n":"\n  let s = sign(a) * sign(b);\n  let ia = i32(round(a));\n  let ib = i32(round(b));\n  return f32(idiv(ia, ib, s));\n";case gs.LESS:return t?"return vec4<f32>(a < b);":"return f32(a < b);";case gs.LESS_EQUAL:return t?"return vec4<f32>(a <= b);":"return f32(a <= b);";case gs.LOGICAL_AND:return t?"return (vec4<f32>(a >= vec4<f32>(1.0)) *\n  vec4<f32>(b >= vec4<f32>(1.0)));":"return f32(a >= 1.0 && b >= 1.0);";case gs.LOGICAL_OR:return t?"return min(vec4<f32>(a >= vec4<f32>(1.0)) +\n  vec4<f32>(b >= vec4<f32>(1.0)), vec4<f32>(1.0));":"return f32(a >= 1.0 || b >= 1.0);";case gs.MAX:return Ss("max",t);case gs.MIN:return Ss("min",t);case gs.MOD:return t?ws:bs;case gs.MUL:return"return a * b;";case gs.NOT_EQUAL:return t?vs:"\n  if (isnan(a) || isnan(b)) {\n    return 1.0;\n  }\n  return f32(a != b);\n";case gs.POW:return t?ks:"\n  if(a < 0.0 && floor(b) < b) {\n    return uniforms.NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  if (round(abs(b) % 2.0) != 1.0) {\n    return pow(abs(a), b);\n  }\n  return sign(a) * pow(abs(a), b);\n";case gs.PRELU:return t?"\n  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));\n  return (aLessThanZero * (b * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);\n":"if (a < 0.0) { return b * a; }  return a;";case gs.SQUARED_DIFFERENCE:return"return (a - b) * (a - b);";case gs.SUB:return"return a - b;";default:throw new Error(`BinaryType ${e} is not implemented!`)}}var Cs;!function(e){e[e.ABS=0]="ABS",e[e.ACOS=1]="ACOS",e[e.ACOSH=2]="ACOSH",e[e.ASIN=3]="ASIN",e[e.ASINH=4]="ASINH",e[e.ATAN=5]="ATAN",e[e.ATANH=6]="ATANH",e[e.CEIL=7]="CEIL",e[e.COS=8]="COS",e[e.COSH=9]="COSH",e[e.ELU=10]="ELU",e[e.ERF=11]="ERF",e[e.EXP=12]="EXP",e[e.EXPM1=13]="EXPM1",e[e.FLOOR=14]="FLOOR",e[e.IS_FINITE=15]="IS_FINITE",e[e.IS_INF=16]="IS_INF",e[e.IS_NAN=17]="IS_NAN",e[e.LINEAR=18]="LINEAR",e[e.LOG=19]="LOG",e[e.LOG1P=20]="LOG1P",e[e.LOGICAL_NOT=21]="LOGICAL_NOT",e[e.NEG=22]="NEG",e[e.RELU=23]="RELU",e[e.RELU6=24]="RELU6",e[e.LEAKYRELU=25]="LEAKYRELU",e[e.RECIPROCAL=26]="RECIPROCAL",e[e.ROUND=27]="ROUND",e[e.RSQRT=28]="RSQRT",e[e.SELU=29]="SELU",e[e.SIGMOID=30]="SIGMOID",e[e.SIGN=31]="SIGN",e[e.SIN=32]="SIN",e[e.SINH=33]="SINH",e[e.SOFTPLUS=34]="SOFTPLUS",e[e.SQRT=35]="SQRT",e[e.SQUARE=36]="SQUARE",e[e.STEP=37]="STEP",e[e.TAN=38]="TAN",e[e.TANH=39]="TANH",e[e.TO_INT=40]="TO_INT"}(Cs||(Cs={}));const Rs=`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  let p = ${z.ERF_P};\n  let a1 = ${z.ERF_A1};\n  let a2 = ${z.ERF_A2};\n  let a3 = ${z.ERF_A3};\n  let a4 = ${z.ERF_A4};\n  let a5 = ${z.ERF_A5};\n\n  let sign = sign(a);\n  let absA = abs(a);\n  let t = 1.0 / (1.0 + p * absA);\n  return sign * (1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * exp(-absA * absA));\n`,Ts=`\n  if (a >= 0.0) {\n    return ${z.SELU_SCALE} * a;\n  } else {\n    return ${z.SELU_SCALEALPHA} * (exp(a) - 1.0);\n  }\n`;function $s(e,t){switch(e){case Cs.ABS:return"return abs(a);";case Cs.ACOS:return"\n  if (abs(a) > 1.) {\n    return uniforms.NAN;\n  }\n  return acos(a);\n";case Cs.ACOSH:return"\n  if (a < 1.) {\n    return uniforms.NAN;\n  }\n  return acosh(a);\n";case Cs.ASIN:return"\n  if (abs(a) > 1.) {\n    return uniforms.NAN;\n  }\n  return asin(a);\n";case Cs.ASINH:return"return asinh(a);";case Cs.ATAN:return"\n  if (isnan(a)) {\n    return uniforms.NAN;\n  }\n  return atan(a);\n";case Cs.ATANH:return"\n  if (abs(a) > 1.) {\n    return uniforms.NAN;\n  }\n  if (a == 1.) {\n    return uniforms.INFINITY;\n  }\n  if (a == -1.) {\n    return -uniforms.INFINITY;\n  }\n  return atanh(a);\n";case Cs.COS:return"return cos(a);";case Cs.COSH:return"\n  let e2x = exp(-a);\n  return (e2x + 1.0 / e2x) / 2.0;\n";case Cs.CEIL:return"return ceil(a);";case Cs.ELU:return t?"\n  var resFloat = exp(a) - vec4<f32>(1.0);\n  if (a.r >= 0.0) {\n    resFloat.r = a.r;\n  }\n  if (a.g >= 0.0) {\n    resFloat.g = a.g;\n  }\n  if (a.b >= 0.0) {\n    resFloat.b = a.b;\n  }\n  if (a.a >= 0.0) {\n    resFloat.a = a.a;\n  }\n  return resFloat;\n":"if (a >= 0.0) { return a; }  return (exp(a) - 1.0);";case Cs.ERF:return Rs;case Cs.EXP:return"return exp(a);";case Cs.EXPM1:return"return exp(a) - 1.0;";case Cs.FLOOR:return"return floor(a);";case Cs.IS_FINITE:return"return f32(!isnan(a) && !isinf(a));";case Cs.IS_INF:return"return f32(isinf(a));";case Cs.IS_NAN:return"return f32(isnan(a));";case Cs.LINEAR:return"return a;";case Cs.LOG:return"if (a < 0.0) { return uniforms.NAN; }\n  return log(a);";case Cs.LOG1P:return"\n  if (isnan(a)) { return a; }\n  return log(1.0 + a);\n";case Cs.LOGICAL_NOT:return"return f32(!(a >= 1.0));";case Cs.NEG:return"return -a;";case Cs.LEAKYRELU:return t?"\n  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));\n  return (aLessThanZero * (uniforms.alpha * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);\n":"if (a < 0.0) { return uniforms.alpha * a; } return a;";case Cs.RECIPROCAL:return"return 1.0 / a;";case Cs.RELU:return t?"\n  return select(a, vec4<f32>(0.0), a < vec4<f32>(0.0));\n":"return select(a, 0.0, a < 0.0);";case Cs.RELU6:return t?"return clamp(a, vec4<f32>(0.0, 0.0, 0.0, 0.0), vec4<f32>(6.0, 6.0, 6.0, 6.0));":"return clamp(a, 0.0, 6.0);";case Cs.ROUND:return"return round(a);";case Cs.RSQRT:return"return inverseSqrt(a);";case Cs.SELU:return Ts;case Cs.SIGMOID:return"return 1.0 / (1.0 + exp(-1.0 * a));";case Cs.SIGN:return"return sign(a);";case Cs.SIN:return"return sin(a);";case Cs.SINH:return"\n  let e2x = exp(a);\n  return (e2x - 1.0 / e2x) / 2.0;\n";case Cs.SOFTPLUS:return"\n  let epsilon = 1.1920928955078125e-7;\n  let threshold = log(epsilon) + 2.0;\n\n  let too_large = a > -threshold;\n  let too_small = a < threshold;\n  let exp_a = exp(a);\n\n  if (too_large) {\n    return a;\n  } else if (too_small) {\n    return exp_a;\n  } else {\n    return log(exp_a + 1.0);\n  }\n";case Cs.SQRT:return"return sqrt(a);";case Cs.SQUARE:return"return a * a;";case Cs.STEP:return"\n  if (isnan(a)) {\n    return a;\n  }\n\n  return select(uniforms.stepAlpha, 1.0, a > 0.0);\n";case Cs.TAN:return"return tan(a);";case Cs.TANH:return"\n  let e2x = exp(-2.0 * abs(a));\n  return sign(a) * (1.0 - e2x) / (1.0 + e2x);\n";case Cs.TO_INT:return"return f32(i32((a)));";default:throw new Error(`BinaryType ${e} is not implemented!`)}}const As=e=>{switch(e){case 1:return"f32";case 2:return"vec2<f32>";case 3:return"vec3<f32>";case 4:return"vec4<f32>";default:throw new Error(e+"-component is not supported.")}};function Ps(e,t=!1,n=!1,r=3){if(null===e)return"";let i="";if("linear"===e)i=$s(Cs.LINEAR);else if("relu"===e)i=$s(Cs.RELU,n);else if("elu"===e)i=$s(Cs.ELU,n);else if("relu6"===e)i=$s(Cs.RELU6,n);else if("prelu"===e)i=Is(gs.PRELU,n);else if("sigmoid"===e)i=$s(Cs.SIGMOID,n);else{if("leakyrelu"!==e)throw new Error(`Activation ${e} has not been implemented for the WebGPU backend.`);i=$s(Cs.LEAKYRELU,n)}const s=As(n?4:1);let o="";return o=t?`\n      fn activation(a : ${s}, coords : vec${r}<i32>) -> ${s} {\n        let b = getPreluActivationWeightsByOutputCoords(coords);\n        ${i}\n      }`:`\n      fn activation(a : ${s}, coords : vec${r}<i32>) -> ${s} {\n        ${i}\n      }`,o}function zs(e,t){return`\n      ${e?"value = value + getBiasByOutputCoords(coords);":""}\n      ${t?"value = activation(value, coords);":""}\n      `}function Ns(e,t,n=!1,i=!1,s=!1,o=1){r.assert(e&&1===o||!e,()=>`transposeA ${e} is not compatible with component size ${o}`);const a=`\n      ${e?"value = getA(batch, col, row);":"value = getA(batch, row, col);"}\n\n    `,u=t?"value = getB(batch, col, row);":"value = getB(batch, row, col);";return`\n  fn mm_readA(batch: i32, row: i32, colIn: i32) -> ${As(o)} {\n    var value = ${As(o)}(0.0);\n    let col = colIn * ${o};\n    ${n&&s?a:`\n    ${e?"if(row < uniforms.dimAOuter && col < uniforms.dimInner)":"if(row < uniforms.aShape[1] && col < uniforms.aShape[2])"}\n    {\n      ${a}\n    }\n    `}\n    return value;\n  }\n\n  fn mm_readB(batch: i32, row: i32, colIn: i32) -> ${As(o)} {\n    let col = colIn * ${o};\n    var value = ${As(o)}(0.0);\n    ${u}\n    return value;\n  }\n  `}function Ms(e,t,n,r,i=!1,s=!1,o=!1,a=1){return`\n  ${Ns(n,r,i,s,o,a)}\n  fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${As(a)}) {\n    let col = colIn * ${a};\n    ${i&&s?"":"if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)"}\n    {\n      var value = valueIn;\n      let coords = vec3<i32>(batch, row, col);\n      ${zs(e,t)}\n      setOutputAtCoords(coords[0], coords[1], coords[2], value);\n    }\n  }\n  `}function Fs(e,t,n=!1,i=32,s=!1,o=32,a=!1,u=!1){const l=t[1]*e[1],h=t[0]*e[0],c=n?l:i,d=n?i:l,p=c/t[0],f=i/t[1],m=e[1];return r.assert((n&&4===p&&4===e[1]||!n&&(3===p||4===p))&&c%t[0]==0&&i%t[1]==0&&4===e[0],()=>`If transposeA ${n} is true, innerElementSize ${p} and workPerThread[1] ${e[1]} must be 4.\n          Otherwise, innerElementSize ${p} must be 3 or 4.\n      tileAWidth ${c} must be divisible by workgroupSize[0]${t[0]}. tileInner ${i} must be divisible by workgroupSize[1] ${t[1]}. colPerThread ${e[0]} must be 4.`),`\n  var<workgroup> mm_Asub : array<array<vec${p}<f32>, ${c/p}>, ${d}>;\n  var<workgroup> mm_Bsub : array<array<vec4<f32>, ${h/e[0]}>, ${i}>;\n\n  ${Qi()} {\n    let localRow = i32(localId.y);\n    let tileRow = ${a?"0":"localRow * "+m};\n    let tileCol = i32(localId.x);\n\n    let globalRow = ${a?"0":"i32(globalId.y) * "+m};\n    let globalCol = i32(globalId.x);\n    let batch = ${s?"0":"i32(globalId.z)"};\n    let batchA = ${s||!u?"batch":"batch % uniforms.aShape[0]"};\n    let batchB = ${s||!u?"batch":"batch % uniforms.bShape[0]"};\n    let globalRowStart = i32(workgroupId.y) * ${l};\n\n    let numTiles = ${s?""+Math.ceil(o/i):`(uniforms.dimInner - 1) / ${i} + 1`};\n    var kStart = ${s?"i32(globalId.z) * "+o:"0"};\n\n    var acc: array<vec4<f32>, ${m}>;\n\n    // Loop over shared dimension.\n    let tileRowB = localRow * ${f};\n    for (var t = 0; t < numTiles; t++) {\n        // Load one tile of A into local memory.\n        for (var innerRow = 0; innerRow < ${m}; innerRow++) {\n            let inputRow = tileRow + innerRow;\n            let inputCol = tileCol;\n            ${((e,t)=>e?`\n        mm_Asub[inputRow][inputCol] = mm_readA(batchA,\n          kStart + inputRow,\n          globalRowStart / ${t} + inputCol);\n        `:`\n        mm_Asub[inputRow][inputCol] = mm_readA(batchA,\n          globalRow + innerRow,\n          kStart / ${t} + inputCol);\n        `)(n,p)}\n        }\n\n        // Load one tile of B into local memory.\n        for (var innerRow = 0; innerRow < ${f}; innerRow++) {\n            let inputRow = tileRowB + innerRow;\n            let inputCol = tileCol;\n            mm_Bsub[inputRow][inputCol] = mm_readB(batchB, kStart + inputRow, globalCol);\n        }\n        kStart = kStart + ${i};\n        workgroupBarrier();\n\n        // Compute acc values for a single thread.\n        for (var k = 0; k < ${i/p}; k++) {\n            let BCached0 = mm_Bsub[k * ${p}][tileCol];\n            let BCached1 = mm_Bsub[k * ${p} + 1][tileCol];\n            let BCached2 = mm_Bsub[k * ${p} + 2][tileCol];\n            ${3===p?"":`let BCached3 = mm_Bsub[k * ${p} + 3][tileCol];`}\n\n            ${((e,t,n)=>e?`\n        let ACached0 = mm_Asub[k * ${t}][localRow];\n        let ACached1 = mm_Asub[k * ${t} + 1][localRow];\n        let ACached2 = mm_Asub[k * ${t} + 2][localRow];\n        ${3===t?"":`let ACached3 = mm_Asub[k * ${t} + 3][localRow];`}\n        for (var i = 0; i < ${n}; i++) {\n          acc[i] = BCached0 * ACached0[i] + acc[i];\n          acc[i] = BCached1 * ACached1[i] + acc[i];\n          acc[i] = BCached2 * ACached2[i] + acc[i];\n          ${3===t?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}\n        }`:`\n        for (var i = 0; i < ${n}; i++) {\n          let ACached = mm_Asub[tileRow + i][k];\n          acc[i] = BCached0 * ACached.x + acc[i];\n          acc[i] = BCached1 * ACached.y + acc[i];\n          acc[i] = BCached2 * ACached.z + acc[i];\n          ${3===t?"":"acc[i] = BCached3 * ACached.w + acc[i];"}\n        }`)(n,p,m)}\n        }\n\n        workgroupBarrier();\n    }\n\n    for (var innerRow = 0; innerRow < ${m}; innerRow++) {\n        mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);\n    }\n  }`}const Es=e=>e?"\n        mm_Asub[inputRow][inputCol] = mm_readA(batchA,\n          kStart + inputRow,\n          globalRowStart + inputCol);\n        ":"\n        mm_Asub[inputRow][inputCol] = mm_readA(batchA,\n          globalRowStart + inputRow,\n          kStart + inputCol);\n        ";function _s(e,t,n=!1,i=32,s=!1,o=32,a=!1,u=!1){const l=e[1]*t[1],h=e[0]*t[0],c=n?l:i,d=n?i:l;r.assert(d%t[1]==0&&c%t[0]==0&&i%t[1]==0,()=>`tileAHight ${d} must be divisible by workgroupSize[1]${t[1]}, tileAWidth ${c} must be divisible by workgroupSize[0]${t[0]}, tileInner ${i} must be divisible by workgroupSize[1]${t[1]}`);const p=d/t[1],f=c/t[0],m=i/t[1],g=e[1],x=e[0],y=a?`\n      let localRow = i32(localId.y);\n      let localCol = i32(localId.x);\n      let globalRowStart = i32(workgroupId.y) * ${l};\n      let globalColStart = i32(workgroupId.x) * ${h};\n\n      // Loop over shared dimension.\n      for (var t = 0; t < numTiles; t++) {\n        // Load one tile of A into local memory.\n        for (var inputRow = localRow; inputRow < ${d}; inputRow = inputRow + ${t[1]}) {\n          for (var inputCol = localCol; inputCol < ${c}; inputCol = inputCol + ${t[0]}) {\n            ${Es(n)}\n          }\n        }\n        // Load one tile of B into local memory.\n        for (var inputRow = localRow; inputRow < ${i}; inputRow = inputRow + ${t[1]}) {\n              for (var inputCol = localCol; inputCol < ${h}; inputCol = inputCol + ${t[0]}) {\n            mm_Bsub[inputRow][inputCol] = mm_readB(batchB,\n              kStart + inputRow,\n              globalColStart + inputCol);\n          }\n        }\n        kStart = kStart + ${i};\n        workgroupBarrier();\n\n        // Compute acc values for a single thread.\n        var BCached : array<f32, ${x}>;\n        for (var k = 0; k < ${i}; k++) {\n          for (var inner = 0; inner < ${x}; inner++) {\n            BCached[inner] = mm_Bsub[k][localCol + inner * ${t[0]}];\n          }\n          for (var innerRow = 0; innerRow < ${g}; innerRow++) {\n            let ACached = ${n?`mm_Asub[k][localRow + innerRow * ${t[1]}];`:`mm_Asub[localRow + innerRow * ${t[1]}][k];`}\n            for (var innerCol = 0; innerCol < ${x}; innerCol++) {\n              acc[innerRow][innerCol] = acc[innerRow][innerCol] +\n                  ACached * BCached[innerCol];\n            }\n          }\n        }\n        workgroupBarrier();\n      }\n      for (var innerRow = 0; innerRow < ${g}; innerRow++) {\n        let gRow = globalRowStart + localRow + innerRow * ${t[1]};\n        for (var innerCol = 0; innerCol < ${x}; innerCol++) {\n          let gCol = globalColStart + localCol + innerCol * ${t[0]};\n          mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);\n        }\n      }\n      `:`\n  let tileRow = i32(localId.y) * ${g};\n  let tileCol = i32(localId.x) * ${x};\n\n  let globalRow = i32(globalId.y) * ${g};\n  let globalCol = i32(globalId.x) * ${x};\n  let globalRowStart = i32(workgroupId.y) * ${l};\n\n  let tileRowA = i32(localId.y) * ${p};\n  let tileColA = i32(localId.x) * ${f};\n  let tileRowB = i32(localId.y) * ${m};\n  // Loop over shared dimension.\n  for (var t = 0; t < numTiles; t++) {\n    // Load one tile of A into local memory.\n    for (var innerRow = 0; innerRow < ${p}; innerRow++) {\n      for (var innerCol = 0; innerCol < ${f}; innerCol++) {\n        let inputRow = tileRowA + innerRow;\n        let inputCol = tileColA + innerCol;\n        ${Es(n)}\n      }\n    }\n\n    // Load one tile of B into local memory.\n    for (var innerRow = 0; innerRow < ${m}; innerRow++) {\n      for (var innerCol = 0; innerCol < ${x}; innerCol++) {\n        let inputRow = tileRowB + innerRow;\n        let inputCol = tileCol + innerCol;\n        mm_Bsub[inputRow][inputCol] = mm_readB(batchB,\n          kStart + inputRow,\n          globalCol + innerCol);\n      }\n    }\n    kStart = kStart + ${i};\n    workgroupBarrier();\n\n    // Compute acc values for a single thread.\n    var BCached : array<f32, ${x}>;\n    for (var k = 0; k < ${i}; k++) {\n      for (var inner = 0; inner < ${x}; inner++) {\n        BCached[inner] = mm_Bsub[k][tileCol + inner];\n      }\n\n      for (var innerRow = 0; innerRow < ${g}; innerRow++) {\n        ${(e=>e?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];")(n)}\n        for (var innerCol = 0; innerCol < ${x}; innerCol++) {\n          acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];\n        }\n      }\n    }\n\n    workgroupBarrier();\n  }\n\n  for (var innerRow = 0; innerRow < ${g}; innerRow++) {\n    for (var innerCol = 0; innerCol < ${x}; innerCol++) {\n      mm_write(batch, globalRow + innerRow, globalCol + innerCol,\n          acc[innerRow][innerCol]);\n    }\n  }\n  `;return`\n    var<workgroup> mm_Asub : array<array<f32, ${c}>, ${d}>;\n    var<workgroup> mm_Bsub : array<array<f32, ${h}>, ${i}>;\n\n    ${Qi()} {\n      let batch = ${s?"0":"i32(globalId.z)"};\n      let batchA = ${s||!u?"batch":"batch % uniforms.aShape[0]"};\n      let batchB = ${s||!u?"batch":"batch % uniforms.bShape[0]"};\n      let numTiles = ${s?""+Math.ceil(o/i):`(uniforms.dimInner - 1) / ${i} + 1`};\n      var kStart = ${s?"i32(globalId.z) * "+o:"0"};\n\n      var acc : array<array<f32, ${x}>, ${g}>;\n\n      // Without this initialization strange values show up in acc.\n      for (var innerRow = 0; innerRow < ${g}; innerRow++) {\n        for (var innerCol = 0; innerCol < ${x}; innerCol++) {\n          acc[innerRow][innerCol] = 0.0;\n        }\n      }\n      ${y}\n    }\n  `}class Os{constructor(e,t,n=!1,r=!1,i=null,s=null,o=null,a=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=t,this.dispatchLayout={x:[2],y:[1],z:[0]};const u=n?e[1]:e[2];if(this.isVec4=(u%4==0&&!n||t[1]%4==0&&n)&&t[2]%4==0&&!r,this.isVectorA=1===t[1]&&!n,!this.isVec4&&this.isVectorA)this.elementsPerThread=[1,1,1],this.workgroupSize=[32,1,1];else{const e=function(e,t,n,r=!1){const i=[8,8,1],s=[4,4,1];return r||(e<=8&&(s[1]=1),t<=16&&n<=16&&(i[0]=4)),{workgroupSize:i,elementsPerThread:s}}(t[1],u,t[2],n);this.workgroupSize=e.workgroupSize,this.elementsPerThread=e.elementsPerThread}this.dispatch=as(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread);const l=null!=i,h=null!=o;l&&this.variableNames.push("bias"),h&&this.variableNames.push("preluActivationWeights"),this.sequentialAccessByThreads=a,this.transposeA=n,this.transposeB=r,this.addBias=l,this.activation=s,this.hasPreluActivationWeights=h,[this.fitAOuter,this.fitBOuter,this.fitInner]=this.getShapeFit(t[1],t[2],u),this.shaderKey=`matMulPacked_${this.elementsPerThread}_${n}_${r}_${this.activation}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.isVectorA}_${this.sequentialAccessByThreads}`}getShapeFit(e,t,n){const r=this.workgroupSize[1]*this.elementsPerThread[1],i=this.workgroupSize[0]*this.elementsPerThread[0];!this.isVec4&&this.isVectorA?this.tileInner=4*this.workgroupSize[0]:this.tileInner=i;return[e%r==0,t%i==0,n%this.tileInner==0]}getUserCode(){return`\n      ${Ps(this.activation,this.hasPreluActivationWeights,this.isVec4)}\n      ${Ms(this.addBias,this.activation,!1,this.transposeB,this.fitAOuter,this.fitBOuter,this.fitInner,this.isVec4?4:1)}\n      ${this.isVec4?Fs(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,this.isVectorA,!0):this.isVectorA?function(e,t=!1){r.assert(1===e[1]&&1===e[2],()=>`A linear work group size is required. But got ${e}.`);const n=4*e[0];return`\n    var<workgroup> mm_Asub : array<vec4<f32>, ${e[0]}>;\n\n    ${Qi()} {\n      let tileCol = i32(localId.x);\n      let globalCol = i32(globalId.x);\n      let globalRow = i32(globalId.y);\n\n      let numTiles = (uniforms.dimInner - 1) / ${n} + 1;\n      let batch = i32(globalId.z);\n      let batchA = batch % uniforms.aShape[0];\n      let batchB = batch % uniforms.bShape[0];\n      // Without this initialization strange values show up in acc.\n      var acc = 0.0;\n\n      // Loop over shared dimension.\n      for (var t = 0; t < numTiles; t++) {\n        // Load one tile of A into local memory.\n        let colA = t * ${n} + tileCol * 4;\n        mm_Asub[tileCol] = vec4<f32>(${(e=>e?"\n      mm_readA(batchA, colA, globalRow),\n      mm_readA(batchA, colA + 1, globalRow),\n      mm_readA(batchA, colA + 2, globalRow),\n      mm_readA(batchA, colA + 3, globalRow)\n  ":"\n      mm_readA(batchA, globalRow, colA),\n      mm_readA(batchA, globalRow, colA + 1),\n      mm_readA(batchA, globalRow, colA + 2),\n      mm_readA(batchA, globalRow, colA + 3)\n  ")(t)});\n        workgroupBarrier();\n\n        // Compute acc values for a single thread.\n        for (var k = 0; k < ${n/4}; k++) {\n          let rowB = t * ${n} + k * 4;\n          let BCached = vec4<f32>(mm_readB(batchB, rowB, globalCol),\n                              mm_readB(batchB, rowB + 1, globalCol),\n                              mm_readB(batchB, rowB + 2, globalCol),\n                              mm_readB(batchB, rowB + 3, globalCol));\n\n          let ACached = mm_Asub[k];\n          acc = acc + dot(ACached, BCached);\n        }\n\n        workgroupBarrier();\n      }\n\n      mm_write(batch, globalRow, globalCol, acc);\n    }\n  `}(this.workgroupSize,this.transposeA):_s(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,this.sequentialAccessByThreads,!0)}\n    `}}class Bs{constructor(e,t=!1,n=!1,r=null,i=null,s=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout={x:[],y:[1,2],z:[0]},this.dispatch=as(this.dispatchLayout,this.outputShape,this.workgroupSize);const o=null!=r,a=null!=s;o&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),this.transposeA=t,this.transposeB=n,this.addBias=o,this.activation=i,this.hasPreluActivationWeights=a,this.shaderKey=`matMulReduce_${this.activation}_${t}_${n}`}getUserCode(){var e;return`\n      ${Ps(this.activation,this.hasPreluActivationWeights)}\n      ${Ms(this.addBias,this.activation,this.transposeA,this.transposeB)}\n      ${e=this.workgroupSize[0],`\n    var<workgroup> sumValues : array<f32, ${e}>;\n    ${Qi()} {\n      let coords = getOutputCoords();\n      let batch = coords[0];\n      let batchA = batch % uniforms.aShape[0];\n      let batchB = batch % uniforms.bShape[0];\n      let row = coords[1];\n      let col = coords[2];\n      var sum = 0.0;\n      let Length = uniforms.dimInner;\n      for (var k = i32(localId.x); k < Length; k = k + ${e}) {\n        let dataA = mm_readA(batchA, row, k);\n        let dataB = mm_readB(batchB, k, col);\n        sum = sum + dataA * dataB;\n      }\n      sumValues[localId.x] = sum;\n      workgroupBarrier();\n\n      for(var currentSize = ${e/2}u; currentSize > 1u;\n          currentSize = currentSize / 2u) {\n        if (localId.x < currentSize)\n        {\n          sumValues[localId.x] = sumValues[localId.x] + sumValues[localId.x + currentSize];\n        }\n        workgroupBarrier();\n      }\n\n      if (localId.x == 0u) {\n        sum = sumValues[0] + sumValues[1];\n        mm_write(batch, row, col, sum);\n      }\n    }\n  `}\n    `}}class Ls{constructor(e,t,n,r=!1,i=!1,s=null,o=null,a=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[16,8,1],this.outputShape=n,this.dispatchLayout={x:[2],y:[1],z:[0]},this.dispatch=[Math.ceil(n[2]/this.workgroupSize[0]),Math.ceil(n[1]/this.workgroupSize[1]),n[0]];const u=null!=s;u&&this.variableNames.push("bias");const l=null!=a;l&&this.variableNames.push("preluActivationWeights"),this.transposeA=r,this.transposeB=i,this.addBias=u,this.activation=o,this.hasPreluActivationWeights=l,this.shaderKey=`matMulSmallOutputSize_${this.activation}_${r}_${i}`}getUserCode(){return`\n      ${Ps(this.activation,this.hasPreluActivationWeights)}\n      ${Ms(this.addBias,this.activation,this.transposeA,this.transposeB)}\n      ${function(e){const t=e[1],n=e[0],r=t>n?t:n;return`\n  var<workgroup> mm_Asub : array<array<f32, ${r}>, ${t}>;\n  var<workgroup> mm_Bsub : array<array<f32, ${n}>, ${r}>;\n\n  // If the output size is small for matrix multiplication, avoid to use vec4\n  // and handle some elements per thread to optimally utilize the ALU.\n  // Read data from global memory to registers firstly, then store them into\n  // shared memory, so it is instruction-Level parallelism for arithmetic\n  // operations and others handle IO operations between barrier api, makes ALU\n  // and load/store units work simultaneously, could improves the performance.\n  ${Qi()} {\n    let tileRow = i32(localId.y);\n    let tileCol = i32(localId.x);\n    let globalRow = i32(globalId.y);\n    let globalCol = i32(globalId.x);\n    let batch = i32(globalId.z);\n    let batchA = batch % uniforms.aShape[0];\n    let batchB = batch % uniforms.bShape[0];\n\n    // uniforms.dimInner should be greater than 0.\n    let numTiles = (uniforms.dimInner - 1) / ${r} + 1;\n    var acc = 0.0;\n\n    var globalColA = tileCol;\n    var globalRowB = 0;\n    var regA = mm_readA(batchA, globalRow, globalColA);\n    var regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);\n    var regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);\n    globalColA = globalColA + ${r};\n    globalRowB = globalRowB + ${r};\n\n    for (var t = 0; t < numTiles; t = t + 1) {\n      mm_Asub[tileRow][tileCol] = regA;\n      mm_Bsub[2 * tileRow][tileCol] = regB0;\n      mm_Bsub[2 * tileRow + 1][tileCol] = regB1;\n\n      workgroupBarrier();\n\n      regA = mm_readA(batchA, globalRow, globalColA);\n      regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);\n      regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);\n      globalColA = globalColA + ${r};\n      globalRowB = globalRowB + ${r};\n\n      for (var k = 0; k < ${r}; k = k + 1) {\n        acc = acc + mm_Asub[tileRow][k] * mm_Bsub[k][tileCol];\n      }\n      workgroupBarrier();\n    }\n\n    mm_write(batch, globalRow, globalCol, acc);\n  }\n  `}(this.workgroupSize)}\n    `}}class Ds{constructor(e,t,n=!1,i=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[8,8,1],this.atomic=!0,this.isVec4=!1,this.splitedDimInner=128,r.assert(1===e[0],()=>"MatMulSplitKProgram only supports batch = 1."),this.outputShape=e,this.dispatchLayout={x:[2],y:[1],z:[0,3]},this.isVec4=(n&&this.outputShape[1]%4==0||!n&&t%4==0)&&this.outputShape[2]%4==0,this.elementsPerThread=[4,4,this.splitedDimInner],this.isVec4||(this.outputShape[1]<16&&(this.elementsPerThread[1]=1),this.outputShape[2]<16&&(this.elementsPerThread[0]=1)),this.dispatch=as(this.dispatchLayout,[this.outputShape[0],this.outputShape[1],this.outputShape[2],t],this.workgroupSize,this.elementsPerThread),this.transposeA=n,this.transposeB=i,this.shaderKey=`matMulSplitK_${n}_${i}_${this.elementsPerThread}_${this.isVec4}`}getUserCode(){const e=this.isVec4?4:1;return`\n      ${Ns(!1,this.transposeB,!1,!1,!1,e)}\n      fn mm_write(batch: i32, row : i32, colIn : i32, value : ${As(e)}) {\n        let col = colIn * ${e};\n        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {\n          let coords = vec3<i32>(batch, row, col);\n          let flatIndex = getOutputIndexFromCoords(coords);\n          // The problem is that we should initialize output to zero before using.\n          // Otherwise, the original value will be added to the result.\n          for (var i = 0; i < ${e}; i = i + 1) {\n            ${Xi("&result[flatIndex + i]",""+(e>1?"value[i]":"value"),"float32")}\n          }\n        }\n      }\n      ${this.isVec4?Fs(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner):_s(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner)}\n    `}}class Us{constructor(e,t=null,n=null,r=null){this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=hs(this.outputShape),this.dispatch=as(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=null!=t,this.hasPreluActivationWeights=null!=r,this.activation=n,this.addBias&&this.variableNames.push("bias"),this.hasPreluActivationWeights&&this.variableNames.push("preluActivationWeights"),this.shaderKey="biasActivation_"+n}getUserCode(){return`\n    ${Ps(this.activation,this.hasPreluActivationWeights)}\n    ${Qi("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        var value = getXByOutputIndex(index);\n        ${zs(this.addBias,this.activation)}\n        setOutputAtIndex(index, value);\n      }\n    }\n    `}}class Ws{constructor(e){this.variableNames=[],this.outputShape=[],this.uniforms="value : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=hs(this.outputShape),this.dispatch=as(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="fill"}getUserCode(){return`\n    ${Qi("index")} {\n      if (index < uniforms.size) {\n        setOutputAtIndex(index, uniforms.value);\n      }\n    }\n  `}}function Vs(e){const{backend:t,attrs:n}=e,{shape:i,value:s}=n;let{dtype:o}=n;if(o=o||r.inferDtype(s),"string"===o){const e=r.getArrayFromDType(o,r.sizeFromShape(i));return e.fill(s),t.makeTensorInfo(i,o,e)}{const e=new Ws(i),n=[{type:"float32",data:[s]}];return t.runWebGPUProgram(e,[],o,n)}}const Gs={kernelName:_,backendName:"webgpu",kernelFunc:Vs};function Hs(e){const{inputs:t,attrs:n}=e,{x:i}=t,{shape:s}=n,o=r.sizeFromShape(i.shape),a=r.inferFromImplicitShape(s,o),u=r.sizeFromShape(a);return r.assert(o===u,()=>`The new shape (${a}) has ${u} elements and the old shape (${i.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`),e.backend.incRef(i.dataId),{dataId:i.dataId,shape:a,dtype:i.dtype}}const Ks={kernelName:O,backendName:"webgpu",kernelFunc:Hs};function Xs({a:e,b:t,transposeA:n,transposeB:i,backend:s,bias:o=null,preluActivationWeights:a=null,leakyreluAlpha:u=0,activation:l=null}){const h=e.shape.length,c=t.shape.length,d=n?e.shape[h-2]:e.shape[h-1],p=i?t.shape[c-1]:t.shape[c-2],f=n?e.shape[h-1]:e.shape[h-2],m=i?t.shape[c-2]:t.shape[c-1],g=e.shape.slice(0,-2),x=t.shape.slice(0,-2),y=r.sizeFromShape(g),b=r.sizeFromShape(x),w=B.assertAndGetBroadcastShape(e.shape.slice(0,-2),t.shape.slice(0,-2)).concat([f,m]);r.assert(d===p,()=>`Error in matMul: inner shapes (${d}) and (${p}) of Tensors with shapes ${e.shape} and ${t.shape} and transposeA=${n} and transposeB=${i} must match.`);const v=n?[y,d,f]:[y,f,d],k=i?[b,m,p]:[b,p,m],S=Hs({inputs:{x:e},backend:s,attrs:{shape:v}}),I=Hs({inputs:{x:t},backend:s,attrs:{shape:k}}),C=[S,I],R=Math.max(y,b),T=[S,I],$=[{type:"int32",data:[f]},{type:"int32",data:[m]},{type:"int32",data:[d]}];let P,z;const N=[R,f,m];let M=A().get("WEBGPU_MATMUL_PROGRAM_TYPE");if(M<0){const e=A().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),t=e>0?e:s.thresholdToIncreaseWorkgroups,n=R*Math.ceil(f/32)*Math.ceil(m/32);M=n<=t||f<=8&&n<=2*t?R*f*m<=128?ps.MatMulReduceProgram:1===R&&p>=2e3?ps.MatMulSplitKProgram:ps.MatMulSmallOutputSizeProgram:ps.MatMulPackedProgram}switch(M){case ps.MatMulReduceProgram:P=new Bs(N,n,i,o,l,a);break;case ps.MatMulSplitKProgram:if(z=Vs({backend:s,attrs:{shape:N,value:0,dtype:e.dtype}}),P=new Ds(N,p,n,i),o||l){z=s.runWebGPUProgram(P,T,e.dtype,$,z);const t=new Us(z.shape,o,l,a);let n=null;const r=[z];o&&r.push(o),a&&r.push(a),"leakyrelu"===l&&(n=[{type:"float32",data:[u]}],t.uniforms+=" alpha : f32,");const i=s.runWebGPUProgram(t,r,z.dtype,n);C.push(z);const h=Hs({inputs:{x:i},backend:s,attrs:{shape:w}});C.push(i);for(const e of C)s.disposeData(e.dataId);return h}break;case ps.MatMulSmallOutputSizeProgram:P=new Ls(v,k,N,n,i,o,l,a);break;case ps.MatMulPackedProgram:const t=s.adapterInfo.isIntel();P=new Os(v,N,n,i,o,l,a,t);break;default:throw new Error(`Unsupported MatMulProgramType ${M}.`)}o&&T.push(o),a&&T.push(a),"leakyrelu"===l&&($.push({type:"float32",data:[u]}),P.uniforms+=" alpha : f32,"),z=s.runWebGPUProgram(P,T,e.dtype,$,z);const F=Hs({inputs:{x:z},backend:s,attrs:{shape:w}});C.push(z);for(const e of C)s.disposeData(e.dataId);return F}const qs={kernelName:L,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:i,b:s,bias:o,preluActivationWeights:a}=t,{transposeA:u,transposeB:l,activation:h,leakyreluAlpha:c}=r;return Xs({a:i,b:s,transposeA:u,transposeB:l,backend:n,bias:o,preluActivationWeights:a,leakyreluAlpha:c,activation:h})}};class js{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.workgroupSize=[128,1,1],this.size=!0,this.outputShape=z.assertAndGetBroadcastShape(t,n),this.dispatchLayout=hs(this.outputShape),this.dispatch=as(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="binaryOpComplex_"+e,this.op=e}getUserCode(){return`\n      fn binaryOpComplex(\n          areal : f32, aimag : f32, breal : f32, bimag : f32) -> f32 {\n        ${Is(this.op,!1)}\n      }\n\n      ${Qi("index")} {\n        if(index < uniforms.size) {\n          let areal = getARealByOutputIndex(index);\n          let aimag = getAImagByOutputIndex(index);\n          let breal = getBRealByOutputIndex(index);\n          let bimag = getBImagByOutputIndex(index);\n          setOutputAtIndex(index, binaryOpComplex(areal, aimag, breal, bimag));\n        }\n      }\n    `}}class Ys{constructor(e,t,n){this.size=!0,this.variableNames=["A","B"],this.outputShape=z.assertAndGetBroadcastShape(t,n),this.dispatchLayout=hs(this.outputShape),this.op=e,this.useSharedMemoryWithA=t.length<=1&&n.length>1&&t[0]<128,this.useSharedMemoryWithB=n.length<=1&&t.length>1&&n[0]<128,this.useSharedMemoryWithA||this.useSharedMemoryWithB?(this.isVec4=!1,this.lastDimensionSize=this.useSharedMemoryWithB?n[0]:t[0],this.shaderKey=`binary_${this.type}_${e}_${this.lastDimensionSize}_${this.useSharedMemoryWithB}`,this.type="shared",this.workgroupSize=[256,1,1],this.workPerThread=1):(r.arraysEqual(t,n)&&r.sizeFromShape(t)%4==0?(this.isVec4=!0,this.type="vec4",this.workPerThread=4):(this.isVec4=!1,this.type="plain",this.workPerThread=1),this.shaderKey=`binary_${this.type}_${e}`,this.workgroupSize=[128,1,1]),this.dispatch=as(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1])}getUserCode(){let e;const t=this.isVec4?"vec4<f32>":"f32",n=`\n    fn binaryOperation(a : ${t}, b : ${t}) -> ${t} {\n      let isNaN = false;\n      {\n        ${Is(this.op,this.isVec4)}\n      }\n    };\n    `;if("shared"===this.type){const t=this.lastDimensionSize>1?`coords[${this.outputShape.length-1}]`:"0",r=this.useSharedMemoryWithB?`let a = getAByOutputIndex(index);\n          let b = sharedBuf[${t}];`:`let a = sharedBuf[${t}];\n          let b = getBByOutputIndex(index);`;e=`\n        ${n}\n        var<workgroup> sharedBuf : array<f32, ${this.lastDimensionSize}>;\n        ${Qi("index")} {\n          // Fill in the shared memory buffer.\n          let localIndex = i32(localId.x);\n          if(localIndex < ${this.lastDimensionSize}) {\n            sharedBuf[localIndex] = f32(${this.useSharedMemoryWithB?"B":"A"}[localIndex]);\n          }\n          workgroupBarrier();\n\n          if(index < uniforms.size) {\n            let coords = getCoordsFromIndex(index);\n            ${r}\n            setOutputAtIndex(index, binaryOperation(a, b));\n          }\n        }\n        `}else e=`\n       ${n}\n       ${Qi("index")} {\n         if (index < uniforms.size) {\n           let a = getAByOutputIndex(index);\n           let b = getBByOutputIndex(index);\n           setOutputAtIndex(index, binaryOperation(a, b));\n         }\n       }\n       `;return e}}function Qs(e){const{inputs:t}=e,{x:n}=t;return e.backend.incRef(n.dataId),{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}const Zs={kernelName:D,backendName:"webgpu",kernelFunc:Qs};function Js(e){const{inputs:t,backend:n}=e,{real:r,imag:i}=t,s=n.makeTensorInfo(r.shape,"complex64"),o=n.tensorMap.get(s.dataId),a=Qs({inputs:{x:r},backend:n}),u=Qs({inputs:{x:i},backend:n});return o.complexTensorInfos={real:a,imag:u},s}const eo={kernelName:U,backendName:"webgpu",kernelFunc:Js};class to{constructor(e,t,n=""){this.variableNames=["A"],this.size=!0;this.workgroupSize=[128,1,1],this.outputShape=e,this.dispatchLayout=hs(this.outputShape),this.dispatch=as(this.dispatchLayout,this.outputShape,this.workgroupSize),this.op=t,""!==n&&(this.uniforms=n),this.shaderKey="unary_"+t}getUserCode(){return`\n      fn unaryOperation(a : f32) -> f32 {\n        ${$s(this.op,!1)}\n      }\n      ${Qi("index")} {\n        if (index < uniforms.size) {\n          let a = getAByOutputIndex(index);\n          setOutputAtIndex(index, unaryOperation(a));\n        }\n      }\n      `}}function no({opType:e,cpuKernelImpl:t,dtype:n}){return({inputs:r,backend:i})=>{const{x:s}=r,o=i,a=n||s.dtype;if(o.shouldExecuteOnCPU([s])&&null!=t){const e=o.tensorMap.get(s.dataId),n=t(e.values,a);return o.makeTensorInfo(s.shape,a,n)}const u=new to(s.shape,e);return o.runWebGPUProgram(u,[s],a)}}function ro({opType:e,cpuKernelImpl:t,supportsComplex:n=!1,dtype:r}){return({inputs:i,backend:s})=>{const{a:o,b:a}=i,u=s;if(n&&"complex64"===o.dtype){const t=u.tensorMap.get(o.dataId),n=u.tensorMap.get(a.dataId);let r,i;if(e!==gs.MUL)[r,i]=[[t.complexTensorInfos.real,n.complexTensorInfos.real],[t.complexTensorInfos.imag,n.complexTensorInfos.imag]].map(t=>{const[n,r]=t,i={dataId:n.dataId,dtype:n.dtype,shape:o.shape},s={dataId:r.dataId,dtype:r.dtype,shape:a.shape},l=new Ys(e,o.shape,a.shape);return u.runWebGPUProgram(l,[i,s],W(n.dtype,r.dtype))});else{const e=new js(gs.COMPLEX_MULTIPLY_REAL,o.shape,a.shape),s=new js(gs.COMPLEX_MULTIPLY_IMAG,o.shape,a.shape),l=[{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:o.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:o.shape},{dataId:n.complexTensorInfos.real.dataId,dtype:n.complexTensorInfos.real.dtype,shape:a.shape},{dataId:n.complexTensorInfos.imag.dataId,dtype:n.complexTensorInfos.imag.dtype,shape:a.shape}];r=u.runWebGPUProgram(e,l,"float32"),i=u.runWebGPUProgram(s,l,"float32")}const s=Js({inputs:{real:r,imag:i},backend:u});return u.disposeData(r.dataId),u.disposeData(i.dataId),s}const l=r||W(o.dtype,a.dtype);if(("string"===o.dtype||"string"===a.dtype||u.shouldExecuteOnCPU([o,a]))&&null!=t){const e=u.tensorMap.get(o.dataId).values,n=u.tensorMap.get(a.dataId).values,r="string"===o.dtype?z.fromUint8ToStringArray(e):e,i="string"===o.dtype?z.fromUint8ToStringArray(n):n,[s,h]=t(o.shape,a.shape,r,i,l);return u.makeTensorInfo(h,l,s)}const h=new Ys(e,o.shape,a.shape);return u.runWebGPUProgram(h,[o,a],l)}}function io(e){return(t,n,i,s,o)=>{const a=z.assertAndGetBroadcastShape(t,n),u=a.length,l=r.computeStrides(a),h=r.sizeFromShape(a),c=r.getTypedArrayFromDType(o,h),d=t.length,p=n.length,f=r.computeStrides(t),m=r.computeStrides(n),g=z.getBroadcastDims(t,a),x=z.getBroadcastDims(n,a);if(g.length+x.length===0)for(let t=0;t<c.length;++t)c[t]=e(i[t%i.length],s[t%s.length]);else for(let t=0;t<c.length;++t){const n=r.indexToLoc(t,u,l),o=n.slice(-d);g.forEach(e=>o[e]=0);const a=r.locToIndex(o,d,f),h=n.slice(-p);x.forEach(e=>h[e]=0);const y=r.locToIndex(h,p,m);c[t]=e(i[a],s[y])}return[c,a]}}const so=io((e,t)=>e+t);function oo(e){return(t,n,i)=>{const s=r.getTypedArrayFromDType(n,t.length);for(let n=0;n<t.length;++n)s[n]=e(t[n],i);return s}}const ao=oo(e=>Math.ceil(e));const uo=io((e,t)=>e===t?1:0),lo=oo(e=>Math.exp(e)),ho=oo(e=>Math.expm1(e)),co=oo(e=>Math.floor(e));const po=io((e,t)=>e>t?1:0),fo=io((e,t)=>e>=t?1:0),mo=io((e,t)=>e<t?1:0),go=io((e,t)=>e<=t?1:0);const xo=oo(e=>Math.log(e));const yo=io((e,t)=>Math.max(e,t)),bo=io((e,t)=>Math.min(e,t)),wo=io((e,t)=>e*t);const vo=io((e,t)=>e!==t?1:0);function ko(e,t,n,r){const i=[];let s=0;const o=t.length-1+n.length,a=new Array(o).fill(null).map(()=>[0]);!function(e,t){for(let n=0;n<e.length;++n){const r=e[n],i=n===e.length-1?t:e[n+1].length;if(0===r.length)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>i)throw new Error("Ragged splits must not point past values");for(let e=1;e<r.length;++e)if(r[e-1]>r[e])throw new Error("Ragged splits must be sorted in ascending order")}}(n,r);let u=1;for(let e=0;e<t.length-1;++e){u*=t[e];const n=t[e+1];for(let t=1;t<u+1;++t)a[e].push(t*n)}for(let r=0;r<e.length;++r){let o=e[r],u=e[r]+1;for(let e=0;e<n.length;++e){const r=n[e],i=e+t.length-1;if(i>=0){const e=a[i],t=e[e.length-1]-r[o];for(let e=o;e<u;++e)a[i].push(r[e+1]+t)}o=r[o],u=r[u]}u!==o&&(i.push([o,u]),s+=u-o)}return{outSplits:a,valueSlices:i,numValues:s}}function So(e,t){const n=e.slice(0,t);for(;n.length<t;)n.push(1);for(let r=t;r<e.length;r++)n[t-1]*=e[r];return n}function Io(e,t,n,i,s){const o=t.slice();o[0]=s;const a=r.getArrayFromDType(n,r.sizeFromShape(o)),u=e.length;return function(e,t,n,r,i,s){const o=So(t,2)[1],a=So(s,2)[1];let u=0;for(const t of n)for(let n=t[0];n<t[1];++n){for(let t=0;t<r;++t)i[u*a+t]=e[n*o+t];++u}}(e,t,i,0===u?0:u/t[0],a,o),[a,o]}var Co=z.RowPartitionType;class Ro{constructor(e,t,n,r,i,s,o,a,u,l){this.shape=e,this.shapeShape=t,this.values=n,this.valuesShape=r,this.valuesDType=i,this.defaultValue=s,this.defaultValueShape=o,this.rowPartitionValues=a,this.rowPartitionValuesShapes=u,this.rowPartitionTypes=z.getRowPartitionTypesHelper(l),this.raggedRank=z.getRaggedRank(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===Co.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===Co.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case Co.VALUE_ROWIDS:return Ro.getMaxWidthValueRowID(t);case Co.ROW_SPLITS:return Ro.getMaxWidthRowSplit(t);default:throw new Error("Cannot handle partition type "+Co[this.getRowPartitionTypeByDimension(e-1)])}}static getMaxWidthRowSplit(e){const t=e.length;if(0===t||1===t)return 0;let n=0;for(let r=0;r<t-1;++r){const t=e[r+1]-e[r];t>n&&(n=t)}return n}static getMaxWidthValueRowID(e){const t=e.length;if(0===t)return 0;let n=0,r=e[0],i=0;for(let s=1;s<t;++s){const t=e[s];t!==r&&(r=t,i=Math.max(s-n,i),n=s)}return Math.max(t-n,i)}tensorShapeFromTensor(e,t,n=!0){if(0===t.length){if(-1===e[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return $o(e,n)}calculateOutputSize(e){const t=this.valuesShape,n=this.defaultValueShape;z.validateDefaultValueShape(n,t);const r=this.tensorShapeFromTensor(this.shape,this.shapeShape),i=z.combineRaggedTensorToTensorShapes(this.raggedRank,r,t);i[0]<0&&(i[0]=e);for(let e=1;e<=this.raggedRank;++e)i[e]<0&&(i[e]=this.getMaxWidth(e));return i}calculateFirstParentOutputIndex(e,t,n){const i=Math.min(e,n),s=[];let o=0;for(let e=0;e<i;++e,o+=t)s.push(o);for(let t=i;t<e;++t)s.push(-1);return r.assert(s.length===e,()=>"Final length of result must be equal to firstDimension."),s}calculateOutputIndexRowSplit(e,t,n,r){const i=e.length,s=[];for(let o=0;o<i-1;++o){const i=e[o+1]-e[o];let a=Math.min(r,i),u=t[o];-1===u&&(a=0);for(let e=0;e<a;++e)s.push(u),u+=n;for(let e=0;e<i-a;++e)s.push(-1)}if(i>0&&s.length!==e[i-1])throw new Error("Invalid row split size.");return s}calculateOutputIndexValueRowID(e,t,n,r){const i=e.length,s=[];if(0===i)return[];let o=0,a=e[0];if(a>=t.length)throw new Error(`Got currentValueRowId=${a}, which is not less than ${t.length}`);let u=t[a];s.push(u);for(let l=1;l<i;++l){const i=e[l];if(i===a)u>=0&&(++o,o<r?u+=n:u=-1);else{if(o=0,a=i,i>=t.length)throw new Error(`Got nextValueRowId=${i} which is not less than ${t.length}`);u=t[i]}s.push(u)}if(s.length!==e.length)throw new Error("Invalid row ids.");return s}calculateOutputIndex(e,t,n,r){const i=this.getRowPartitionTensor(e),s=this.getRowPartitionTypeByDimension(e);switch(s){case Co.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(i,t,n,r);case Co.ROW_SPLITS:if(i.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${i.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(i,t,n,r);default:throw new Error("Unsupported partition type: "+Co[s])}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case Co.FIRST_DIM_SIZE:return e[0];case Co.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case Co.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error("Cannot handle type "+Co[t])}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const e=this.getFirstDimensionSize(),t=this.calculateOutputSize(e),n=new Array(this.raggedRank+1);n[n.length-1]=1;for(let e=n.length-2;e>=0;--e)n[e]=n[e+1]*t[e+1];const i=$o(t,!1),s=r.getArrayFromDType(this.valuesDType,r.sizeFromShape(i));if(n[0]*t[0]>0){let r=this.calculateFirstParentOutputIndex(e,n[0],t[0]);for(let e=1;e<=this.raggedRank;++e){r=this.calculateOutputIndex(e-1,r,n[e],t[e])}this.setOutput(this.raggedRank,r,s,i)}return[i,s]}setOutput(e,t,n,s){if(0===n.length)return;const o=this.values,a=n;let u=s.slice();u=u.slice(e+1);const l=r.sizeFromShape(u),h=t.length;let c=this.defaultValue;if(c.length!==l&&1!==c.length){const e=this.defaultValueShape;i(()=>{const t=I(c,e),n=V(t,u);c=n.dataSync()})}let d=0,p=0,f=0;for(let e=0;e<=h;++e){let r=e<h?t[e]:-1;if(r!==f){if(p<f){const e=o.subarray(d*l);To(a.subarray(p*l),e,(f-p)*l)}if(e>=h){const e=n.length;r=Math.floor(e/l)}if(r>f)if(1===this.defaultValue.length)a.subarray(f*l,r*l).fill(this.defaultValue[0]),f=r;else for(;r>f;){To(a.slice(f*l),c,l),++f}r<0?(d=e+1,p=f):(d=e,p=f,f=p+1)}else++f}}}function To(e,t,n){for(let r=0;r<n;r++)e[r]=t[r]}function $o(e,t){const n=[];for(let r of e){if(r<0){if(!t)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}n.push(r)}return n}const Ao=oo(e=>1/Math.sqrt(e));const Po=oo(e=>1/(1+Math.exp(-e)));const zo=oo(e=>Math.sqrt(e)),No=io((e,t)=>{const n=e-t;return n*n});class Mo{constructor(e,t,n,i,s,o){this.separator=r.encodeString(e),this.nGramWidths=t,this.leftPad=r.encodeString(n),this.rightPad=r.encodeString(i),this.padWidth=s,this.preserveShort=o}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,r,i,s){for(let o=0;o<i;++o){const a=this.getPadWidth(s),u=Math.max(0,a-o),l=Math.max(0,a-(i-(o+1))),h=s-(u+l),c=t+(u>0?0:o-a);let d=0;d+=u*this.leftPad.length;for(let t=0;t<h;++t)d+=e[c+t].length;d+=l*this.rightPad.length;d+=(u+l+h-1)*this.separator.length,n[r+o]=new Uint8Array(d);const p=n[r+o];let f=0;const m=e=>e.forEach(e=>p[f++]=e);for(let e=0;e<u;++e)m(this.leftPad),m(this.separator);for(let t=0;t<h-1;++t)m(e[c+t]),m(this.separator);if(h>0){m(e[c+h-1]);for(let e=0;e<l;++e)m(this.separator),m(this.rightPad)}else{for(let e=0;e<l-1;++e)m(this.rightPad),m(this.separator);m(this.rightPad)}}}compute(e,t){const n=e.length,i=t.length;if(i>0){let e=t[0];if(0!==e)throw new Error("First split value must be 0, got "+e);for(let r=1;r<i;++r){let i=t[r]>=e;if(i=i&&t[r]<=n,!i)throw new Error(`Invalid split value ${t[r]}, must be in [${e}, ${n}]`);e=t[r]}if(e!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${e}`)}const s=i-1,o=r.getArrayFromDType("int32",i);if(0===n||0===i){const e=new Array(n);for(let e=0;e<=s;++e)o[e]=0;return[e,o]}o[0]=0;for(let e=1;e<=s;++e){const n=t[e]-t[e-1];let r=0;this.nGramWidths.forEach(e=>{r+=this.getNumNGrams(n,e)}),this.preserveShort&&n>0&&0===r&&(r=1),o[e]=o[e-1]+r}const a=new Array(o[s]);for(let n=0;n<s;++n){const r=t[n];let i=o[n];if(this.nGramWidths.forEach(s=>{const o=t[n+1]-t[n],u=this.getNumNGrams(o,s);this.createNGrams(e,r,a,i,u,s),i+=u}),this.preserveShort&&i===o[n]){const s=t[n+1]-t[n];if(0===s)continue;const o=s+2*this.padWidth,u=1;this.createNGrams(e,r,a,i,u,o)}}return[a,o]}}function Fo(e,t,n,r){if(!e.length)return;if(0===t.length){for(let t=0;t<e.length;++t)r.push(e.subarray(t,t+1));return}if(1===t.length){const i=t[0];let s=e.indexOf(i);for(;-1!==s;){const t=e.subarray(0,s);n&&0===t.length||r.push(t),s=(e=e.subarray(s+1)).indexOf(i)}return void(n&&0===e.length||r.push(e))}let i=0;for(let s=0;s<e.length+1;s++)if(s===e.length||-1!==t.indexOf(e[s])){const t=e.subarray(i,s);n&&0===t.length||r.push(t),i=s+1}}const Eo=io((e,t)=>e-t);const _o=(e,t)=>{const n=t.value-e.value;return 0===n?e.index-t.index:n};function Oo(e,t,n=0,i=e.length-1){for(;i>n;){if(i-n>600){const r=i-n+1,s=t-n+1,o=Math.log(r),a=.5*Math.exp(2*o/3),u=.5*Math.sqrt(o*a*(r-a)/r)*Math.sign(s-r/2);Oo(e,t,Math.max(n,Math.floor(t-s*a/r+u)),Math.min(i,Math.floor(t+(r-s)*a/r+u)))}const s=e[t];let o=n,a=i;for(r.swap(e,n,t),_o(e[i],s)>0&&r.swap(e,n,i);o<a;){for(r.swap(e,o,a),o++,a--;_o(e[o],s)<0;)o+=1;for(;_o(e[a],s)>0;)a-=1}0===_o(e[n],s)?r.swap(e,n,a):(a+=1,r.swap(e,a,i)),a<=t&&(n=a+1),t<=a&&(i=a-1)}}var Bo=Object.freeze({__proto__:null,simpleAbsImpl:function(e){const t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t},addImpl:so,bincountImpl:function(e,t,n,i,s){const o=r.sizeFromShape(i),a=r.makeZerosTypedArray(s,n);for(let n=0;n<e.length;n++){const r=e[n];if(r<0)throw new Error("Input x must be non-negative!");r>=s||(a[r]+=o>0?t[n]:1)}return a},bincountReduceImpl:function(e,t,n,r=!1){const i=e.shape[0],s=e.shape[1],o=F([i,n],t.dtype);for(let a=0;a<i;a++)for(let i=0;i<s;i++){const s=e.get(a,i);if(s<0)throw new Error("Input x must be non-negative!");s>=n||(r?o.set(1,a,s):t.size>0?o.set(o.get(a,s)+t.get(a,i),a,s):o.set(o.get(a,s)+1,a,s))}return o},castImpl:function(e,t,n,i){if("int32"===i){return[t,"int32",Int32Array.from(e)]}if("bool"===i){const i=r.toTypedArray([0],n),[s,o]=io((e,t)=>e!==t?1:0)(t,[],e,i,"bool");return[o,"bool",s]}throw new Error(`Error in Cast: failed to cast ${n} to ${i}`)},ceilImpl:ao,concatImpl:function(e,t,n,i){const s=r.getArrayFromDType(n,r.sizeFromShape(t));if(i&&"string"!==n){let t=0;e.forEach(e=>{const n=r.sizeFromShape(e.shape);s.set(e.vals,t),t+=n})}else{let r=0;e.forEach(e=>{const i="string"===n?z.fromUint8ToStringArray(e.vals):e.vals;let o=0;for(let n=0;n<e.shape[0];++n){const a=n*t[1]+r;for(let t=0;t<e.shape[1];++t)s[a+t]=i[o++]}r+=e.shape[1]})}return s},equalImpl:uo,expImpl:lo,expm1Impl:ho,floorImpl:co,gatherNdImpl:function(e,t,n,r,i,s,o,a,u){const l=F([r,s],n);for(let n=0;n<r;n++){const r=[];let h=0;for(let t=0;t<i;t++){const s=e[n*i+t];h+=s*o[t],r.push(s)}if(h<0||h>=u/s)throw new Error(`Invalid indices: ${r} does not index into ${a}`);for(let e=0;e<s;e++)l.values[n*s+e]=t.get(...t.indexToLoc(h*s+e))}return l},gatherV2Impl:function(e,t,n){const r=F(n,e.dtype);for(let n=0;n<r.size;++n){const i=r.indexToLoc(n).slice(),s=i[0],o=i[2],a=t.locToIndex([s,o]);i[2]=t.values[a];const u=e.locToIndex(i);0<=u&&u<e.values.length&&(r.values[n]=e.values[u])}return r},greaterImpl:po,greaterEqualImpl:fo,lessImpl:mo,lessEqualImpl:go,linSpaceImpl:function(e,t,n){const i=(t-e)/(n-1),s=r.makeZerosTypedArray(n,"float32");s[0]=e;for(let e=1;e<s.length;e++)s[e]=s[e-1]+i;return s},logImpl:xo,maxImpl:function(e,t,n,i){const s=r.getTypedArrayFromDType(i,r.sizeFromShape(n));for(let n=0;n<s.length;++n){const r=n*t;let i=e[r];for(let n=0;n<t;++n){const t=e[r+n];(Number.isNaN(t)||t>i)&&(i=t)}s[n]=i}return s},maximumImpl:yo,minimumImpl:bo,multiplyImpl:wo,negImpl:function(e,t,n){const i=r.createScalarValue(-1,n);return wo([],t,i,e,n)},notEqualImpl:vo,prodImpl:function(e,t,n,i){const[s,o]=z.computeOutAndReduceShapes(e,i),a=W(t,"int32"),u=r.makeZerosTypedArray(r.sizeFromShape(s),a),l=r.sizeFromShape(o);for(let e=0;e<u.length;++e){const t=e*l;let r=1;for(let e=0;e<l;++e)r*=n[t+e];u[e]=r}return{outVals:u,outShape:s,outDtype:a}},raggedGatherImpl:function(e,t,n,i,s,o,a,u){if(0===e.length)throw new Error("paramsNestedSplits must be non empty");if(0===t[0].length)throw new Error("Split tensors must not be scalars");if(function(e,t,n){e.forEach((e,i)=>{if(e<0||e>=n){const s=r.indexToLoc(i,t.length,r.computeStrides(t)).join(",");throw new Error(`indices[${s}] = ${e} is not in [0, ${n})`)}})}(o,a,t[0][0]-1),0===i.length)throw new Error("params.rank must be nonzero");const l=i[0],{outSplits:h,valueSlices:c,numValues:d}=ko(o,a,e,l),p=function(e){const t=[];for(let n=0;n<e.length;++n){const i=e[n].length,s=r.getArrayFromDType("int32",i);t.push(s),e[n].forEach((e,t)=>s[t]=e)}return t}(h),f=Io(n,i,s,c,d);return[p,f[0],f[1]]},raggedRangeImpl:function(e,t,n,i,s,o,a){if(t.length>1)throw new Error("starts must be a scalar or vector");if(s.length>1)throw new Error("limits must be a scalar or vector");if(a.length>1)throw new Error("deltas must be a scalar or vector");const u=0===t.length,l=0===s.length,h=0===a.length,c=[];u||c.push(t[0]),l||c.push(s[0]),h||c.push(a[0]);for(let e=1;e<c.length;++e)if(c[e]!==c[e-1])throw new Error("starts, limits, and deltas must have the same shape");const d=0===c.length?1:c[0],p=r.getArrayFromDType("int32",d+1);p[0]=0;for(let t=0;t<d;++t){const n=u?e[0]:e[t],r=l?i[0]:i[t],s=h?o[0]:o[t];if(0===s)throw new Error("Requires delta != 0");let a;if(s>0&&r<n||s<0&&r>n)a=0;else if(a=Math.ceil(Math.abs((r-n)/s)),a>2147483647)throw new Error("Requires ((limit - start) / delta) <= 2147483647");p[t+1]=p[t]+a}const f=p[d],m=r.getArrayFromDType(n,f);let g=0;for(let t=0;t<d;++t){const n=p[t+1]-p[t];let r=u?e[0]:e[t];const i=h?o[0]:o[t];for(let e=0;e<n;++e)m[g++]=r,r+=i}return[p,m]},raggedTensorToTensorImpl:function(e,t,n,r,i,s,o,a,u,l){return new Ro(e,t,n,r,i,s,o,a,u,l).compute()},rangeImpl:function(e,t,n,i){if(e===t||e<t&&n<0||t<e&&n>1)return r.makeZerosTypedArray(0,i);const s=Math.abs(Math.ceil((t-e)/n)),o=r.makeZerosTypedArray(s,i);t<e&&1===n&&(n=-1),o[0]=e;for(let e=1;e<o.length;e++)o[e]=o[e-1]+n;return o},rsqrtImpl:Ao,scatterImpl:function(e,t,n,r,i,s,o,a,u,l){const h=[r/i,i],c=e.values,d=t.values;if(0===r)return F(n,t.dtype);const p=F(h,t.dtype);"string"==typeof u||"number"==typeof u?p.values.fill(u):"boolean"==typeof u&&p.values.fill(+u);for(let e=0;e<s;e++){const s=[];let u=0;for(let t=0;t<o;t++){const n=c[e*o+t];s.push(n),u+=n*a[t]}if(u<0||u>=r/i)throw new Error(`Invalid indices: ${s} does not index into ${n}`);for(let n=0;n<i;n++)l?p.values[u*i+n]+=d[e*i+n]:p.values[u*i+n]=0===t.rank?d[0]:d[e*i+n]}return p},sigmoidImpl:Po,sliceImpl:function(e,t,n,i,s){const o=G.isSliceContinous(i,t,n),a=r.sizeFromShape(n),u=r.computeStrides(i);if(o){const n=G.computeFlatOffset(t,u);return"string"===s?e.slice(n,n+a):e.subarray(n,n+a)}const l="string"===s?z.fromUint8ToStringArray(e):e,h=F(i,s,l),c=F(n,s);for(let e=0;e<c.size;++e){const n=c.indexToLoc(e),r=n.map((e,n)=>e+t[n]);c.set(h.get(...r),...n)}return"string"===s?z.fromStringArrayToUint8(c.values):c.values},sparseFillEmptyRowsImpl:function(e,t,n,i,s,o,a){const u=t[0],l=o[0],h=new Array(l),c=new Array(u),d=t[1];if(0===l){if(0!==u)throw new Error(z.getSparseFillEmptyRowsIndicesDenseShapeMismatch(u));return[r.getArrayFromDType(n,0),[0,d],r.getArrayFromDType(s,0),h,c]}let p=!0,f=0;const m=new Array(l).fill(0);for(let t=0;t<u;++t){const n=e[t*d];if(n<0)throw new Error(z.getSparseFillEmptyRowsNegativeIndexErrorMessage(t,n));if(n>=l)throw new Error(z.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(t,n,l));++m[n],p=p&&n>=f,f=n}let g=!0;for(let e=0;e<l;++e){const t=0===m[e];h[e]=t,g=g&&!t,m[e]=Math.max(m[e],1),e>0&&(m[e]+=m[e-1])}if(g&&p){const t=e,n=i;for(let e=0;e<u;++e)c[e]=e;return[t,[u,d],n,h,c]}{const t=m[l-1],o=r.getArrayFromDType(n,t*d),p=r.getArrayFromDType(s,t),f=new Array(l).fill(0);for(let t=0;t<u;++t){const n=e[t*d],r=f[n],s=(0===n?0:m[n-1])+r;f[n]++;for(let n=0;n<d;++n)o[s*d+n]=e[t*d+n];p[s]=i[t],c[t]=s}for(let e=0;e<l;++e){if(0===f[e]){const t=0===e?0:m[e-1];o[t*d+0]=e;for(let e=1;e<d;++e)o[t*d+e]=0;p[t]=a}}return[o,[t,d],p,h,c]}},sparseReshapeImpl:function(e,t,n,i,s){const o=r.sizeFromShape(i),a=t[0],u=s.length,l=[];let h=1,c=-1;for(let e=0;e<u;++e){const t=s[e];if(-1===t){if(-1!==c)throw new Error(z.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(c,e));c=e,l.push(1)}else{if(t<0)throw new Error(z.getSparseReshapeNegativeOutputDimErrorMessage(e,t));h*=t,l.push(t)}}if(-1!==c){if(h<=0)throw new Error(z.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());const e=Math.trunc(o/h);if(h*e!==o)throw new Error(z.getSparseReshapeInputOutputMultipleErrorMessage(i,l));l[c]=e}if(r.sizeFromShape(l)!==o)throw new Error(z.getSparseReshapeInputOutputMismatchErrorMessage(i,l));const d=i.length,p=[];if(d>0){p[d-1]=1;for(let e=d-2;e>=0;--e)p[e]=p[e+1]*i[e+1]}const f=[];if(u>0){f[u-1]=1;for(let e=u-2;e>=0;--e)f[e]=f[e+1]*l[e+1]}const m=r.getArrayFromDType(n,a*u);for(let t=0;t<a;++t){let n=0;for(let r=0;r<d;++r)n+=e[t*d+r]*p[r];for(let e=0;e<u;++e)m[t*u+e]=Math.trunc(n/f[e]),n%=f[e]}return[m,[a,u],l]},sparseSegmentReductionImpl:function(e,t,n,i,s,o=!1,a=0){const u=i.length,l=[t[0],e.length/t[0]],h=l[1],c=u>0?s[u-1]+1:0;if(c<0)throw new Error(z.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());const d=t.slice();d[0]=c;const p=d.reduce((e,t)=>e*t,1),f=r.getArrayFromDType(n,p);if(0===u)return c>0&&f.fill(a),[f,d];if(c<=0)throw new Error(z.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let m=0,g=1,x=0,y=s[m];for(;;){let t=0;if(g<u){if(t=s[g],y===t){++g;continue}if(y>=t)throw new Error(z.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(y<0||y>=c)throw new Error(z.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(y,c));y>x&&f.fill(a,x*h,y*h);for(let t=m;t<g;++t){const n=i[t];if(n<0||n>=l[0])throw new Error(z.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(t,i[t],l[0]));for(let t=0;t<h;t++)f[y*h+t]+=e[n*h+t]}if(o)for(let e=0;e<h;e++)f[y*h+e]/=g-m;if(m=g,++g,x=y+1,y=t,g>u)break}return x<c&&f.fill(a,x*h,c*h),[f,d]},sqrtImpl:zo,squaredDifferenceImpl:No,stridedSliceImpl:function(e,t,n,r){const i=F(e,t.dtype);for(let e=0;e<i.size;e++){const s=i.indexToLoc(e),o=new Array(s.length);for(let e=0;e<o.length;e++)o[e]=s[e]*n[e]+r[e];i.set(t.get(...o),...s)}return i},stringNGramsImpl:function(e,t,n,r,i,s,o,a){return new Mo(n,r,i,s,o,a).compute(e,t)},stringSplitImpl:function(e,t,n){const i=e.length,s=[];let o=0,a=0;const u=new Array(i);for(let r=0;r<i;++r){const i=s.length;Fo(e[r],t,n,s);const l=s.length-i;u[r]=l,o+=l,a=Math.max(a,l)}const l=r.getArrayFromDType("int32",2*o),h=new Array(o),c=[i,a];let d=0;for(let e=0;e<i;++e)for(let t=0;t<u[e];++t)l[2*d]=e,l[2*d+1]=t,h[d]=s[d],++d;return[l,h,c]},stringToHashBucketFastImpl:function(e,t){const n=r.getArrayFromDType("int32",e.length);for(let i=0;i<e.length;++i)n[i]=r.fingerPrint64(e[i]).modulo(t).getLowBitsUnsigned();return n},subImpl:Eo,tileImpl:function(e,t){const n=new Array(e.rank);for(let r=0;r<n.length;r++)n[r]=e.shape[r]*t[r];const r=F(n,e.dtype);for(let t=0;t<r.values.length;++t){const n=r.indexToLoc(t),i=new Array(e.rank);for(let t=0;t<i.length;t++)i[t]=n[t]%e.shape[t];const s=e.locToIndex(i);r.values[t]=e.values[s]}return r},topKImpl:function(e,t,n,i,s){const o=t[t.length-1],[a,u]=[e.length/o,o],l=r.getTypedArrayFromDType(n,a*i),h=r.getTypedArrayFromDType("int32",a*i);for(let t=0;t<a;t++){const n=t*u,r=e.subarray(n,n+u);let o=new Array(r.length);r.forEach((e,t)=>o[t]={value:e,index:t}),i<o.length&&(Oo(o,i),o=o.slice(0,i)),s&&o.sort(_o);const a=t*i,c=l.subarray(a,a+i),d=h.subarray(a,a+i);for(let e=0;e<i;e++)c[e]=o[e].value,d[e]=o[e].index}const c=t.slice();return c[c.length-1]=i,[F(c,n,l),F(c,"int32",h)]},transposeImpl:function(e,t,n,i,s){const o=t.length,a=r.sizeFromShape(t),u=r.computeStrides(t),l=r.computeStrides(s),h=r.getTypedArrayFromDType(n,r.sizeFromShape(s));for(let t=0;t<a;++t){const n=r.indexToLoc(t,o,u),s=new Array(n.length);for(let e=0;e<s.length;e++)s[e]=n[i[e]];h[r.locToIndex(s,o,l)]=e[t]}return h},uniqueImpl:function(e,t,n,i){const s=r.parseAxisParam(t,n)[0],o=[1,n[0],1];for(let e=0;e<s;e++)o[0]*=n[e];o[1]=n[s];for(let e=s+1;e<n.length;e++)o[2]*=n[e];const a={},u=new Int32Array(n[s]),l=new H(o,i,e),h=[],c=1===o[0]&&1===o[2];for(let t=0;t<n[s];t++){let n;if(c)n=e[t].toString();else{const e=[];for(let n=0;n<o[0];n++)for(let r=0;r<o[2];r++)e.push(l.get(n,t,r));n=e.join(",")}if(void 0!==a[n])u[t]=a[n];else{const e=Object.keys(a).length;a[n]=e,u[t]=e,h.push(t)}}const d=o.slice();d[1]=Object.keys(a).length;const p=new H(d,i);h.forEach((e,t)=>{for(let n=0;n<o[0];n++)for(let r=0;r<o[2];r++)p.set(l.get(n,e,r),n,t,r)});const f=n.slice();return f[s]=d[1],{outputValues:p.values,outputShape:f,indices:u}}});const{addImpl:Lo,castImpl:Do,ceilImpl:Uo,concatImpl:Wo,equalImpl:Vo,expImpl:Go,expm1Impl:Ho,floorImpl:Ko,gatherNdImpl:Xo,gatherV2Impl:qo,greaterEqualImpl:jo,greaterImpl:Yo,lessEqualImpl:Qo,lessImpl:Zo,logImpl:Jo,maxImpl:ea,maximumImpl:ta,minimumImpl:na,multiplyImpl:ra,negImpl:ia,notEqualImpl:sa,prodImpl:oa,rangeImpl:aa,rsqrtImpl:ua,scatterImpl:la,simpleAbsImpl:ha,sliceImpl:ca,stridedSliceImpl:da,stringNGramsImpl:pa,subImpl:fa,tileImpl:ma,topKImpl:ga,transposeImpl:xa,uniqueImpl:ya}=Bo,ba={kernelName:K,backendName:"webgpu",kernelFunc:no({opType:Cs.ABS,cpuKernelImpl:ha})},wa={kernelName:X,backendName:"webgpu",kernelFunc:no({opType:Cs.ACOS})},va={kernelName:q,backendName:"webgpu",kernelFunc:no({opType:Cs.ACOSH})},ka={kernelName:j,backendName:"webgpu",kernelFunc:ro({opType:gs.ADD,cpuKernelImpl:Lo,supportsComplex:!0})};class Sa{constructor(e){this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e[0],this.variableNames=e.map((e,t)=>"T"+t),this.dispatchLayout=hs(this.outputShape),this.dispatch=as(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="addN"}getUserCode(){const e=[];this.variableNames.forEach(t=>{e.push(`let v${t} = get${t}ByOutputCoords(coords);`)});const t=this.variableNames.map(e=>"v"+e).join(" + ");return`\n      ${Qi("index")} {\n        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {\n          let flatIndex = index * ${this.workPerThread} + i;\n          if (flatIndex < uniforms.size) {\n            let coords = getCoordsFromIndex(flatIndex);\n            ${e.join("\n        ")}\n            setOutputAtIndex(flatIndex, ${t});\n          }\n        }\n      }\n    `}}const Ia={kernelName:Y,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,r=t;if(1===r.length)return Qs({inputs:{x:r[0]},backend:n});const i=r.map(e=>e.dtype).reduce((e,t)=>W(e,t)),s=r.map(e=>e.shape),o=new Sa(s);return n.runWebGPUProgram(o,r,i)}};class Ca{constructor(e,t){this.variableNames=["A"],this.workgroupSize=[16,16,1];const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];this.outputShape=n,this.dispatchLayout={x:[0],y:[1]},this.dispatch=as(this.dispatchLayout,this.outputShape,this.workgroupSize,[1,1,1]),this.shaderKey="transposeShared"}getUserCode(){r.assert(this.workgroupSize[0]===this.workgroupSize[1],()=>`Must be a square tile, current tile shape is ${this.workgroupSize[0]} x ${this.workgroupSize[1]}`);const e=this.workgroupSize[0];return`\n      var<workgroup> tile : array<array<f32, ${this.workgroupSize[0]+1}>, ${this.workgroupSize[0]}>;\n      ${Qi()} {\n        var x = i32(workgroupId.x) * ${e} + i32(localId.x);\n        var y = i32(workgroupId.y) * ${e} + i32(localId.y);\n        let width = uniforms.outShape[0];\n        let height = uniforms.outShape[1];\n        if (x < width && y < height) {\n          tile[localId.y][localId.x] = f32(A[y * width + x]);\n        }\n        workgroupBarrier();\n\n        x = i32(workgroupId.y) * ${e} + i32(localId.x);\n        y = i32(workgroupId.x) * ${e} + i32(localId.y);\n        if (x < height && y < width) {\n          setOutputAtIndex((y * height + x), tile[localId.x]\n            [localId.y]);\n        }\n      }\n    `}}class Ra{constructor(e,t){this.variableNames=["A"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0;const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];this.outputShape=n,this.dispatchLayout=hs(this.outputShape),this.dispatch=as(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.newDim=t,this.shaderKey="transpose_"+t}getUserCode(){const e=ji(this.outputShape.length),t=function(e){const t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const n=new Array(t);for(let t=0;t<e.length;t++)n[e[t]]="resRC."+Yi(t);return n.join()}(this.newDim);return`\n      ${Qi("index")} {\n        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {\n          let flatIndex = index * ${this.workPerThread} + i;\n          if(flatIndex < uniforms.size) {\n            let resRC = getCoordsFromIndex(flatIndex);\n            setOutputAtIndex(flatIndex, A[getIndexFromCoords${this.outputShape.length}D(\n              ${e}(${t}), uniforms.aShape)]);\n          }\n        }\n      }\n    `}}function Ta(e){const{inputs:t,backend:n,attrs:i}=e,{x:s}=t,{perm:o}=i,a=n,u=s.shape.length,l=new Array(u);for(let e=0;e<l.length;e++)l[e]=s.shape[o[e]];if(n.shouldExecuteOnCPU([s])){const e=a.tensorMap.get(s.dataId).values,t=xa(e,s.shape,s.dtype,o,l);return n.makeTensorInfo(l,s.dtype,t)}if(2===s.shape.length&&r.arraysEqual(o,[1,0])){const e=new Ca(s.shape,o);return a.runWebGPUProgram(e,[s],s.dtype)}const h=new Ra(s.shape,o);return a.runWebGPUProgram(h,[s],s.dtype)}const $a={kernelName:Q,backendName:"webgpu",kernelFunc:Ta};class Aa{constructor(e,t){this.workgroupSize=[64,1,1],this.variableNames=["x"],this.uniforms="reduceSize : i32,",this.size=!0,this.inputShape=[e.batchSize,e.inSize];const[n]=z.computeOutAndReduceShapes(this.inputShape,[1]);this.outputShape=0===n.length?[1]:n,this.dispatchLayout=hs(this.outputShape),this.dispatch=as(this.dispatchLayout,this.outputShape,[1,1,1]),this.reduceType=t,this.shaderKey="reduce_"+t}getUserCode(){let e="",t="0.0";const n=this.workgroupSize[0];"min"===this.reduceType||"max"===this.reduceType?(e=`\n         if (isnan(candidate)) {\n          bestValue = uniforms.NAN;\n         } else if (!isnan(bestValue) && candidate ${"min"===this.reduceType?"<":">"} bestValue)\n           {  bestValue = candidate; }`,t="f32(x[offset])"):"sum"===this.reduceType||"mean"===this.reduceType?e=" bestValue = bestValue + candidate; ":"prod"===this.reduceType?(e=" bestValue = bestValue * candidate; ",t="1.0"):"all"===this.reduceType?(e=" bestValue = f32(bestValue >= 1.0 && candidate >= 1.0); ",t="1.0"):"any"===this.reduceType&&(e=" bestValue = f32(bestValue >= 1.0 || candidate >= 1.0); ",t="0.0");const r="mean"===this.reduceType?"setOutputAtIndex(outputIndex, bestValue / f32(uniforms.reduceSize));":"setOutputAtIndex(outputIndex, bestValue);";return`\n       fn DIV_CEIL(a : u32, b : u32) -> u32 {\n        return ((a - 1u) / b + 1u);\n       }\n\n       ${`\n         var<workgroup> xBestValues : array<f32, ${n}>;\n       `}\n       fn getOffset(outputIndex : i32) -> i32 {\n         let outputCoords = getCoordsFromIndex(outputIndex);\n         let offset = ${1===this.outputShape.length?"outputCoords":"outputCoords[0]"} * uniforms.reduceSize;\n          return offset;\n       }\n       ${Qi("index")} {\n         let outputIndex = index / ${n};\n         let offset = getOffset(outputIndex);\n         var bestValue = ${t};\n         let Length = uniforms.reduceSize;\n         let WorkPerThread = DIV_CEIL(u32(Length), ${n}u);\n         for (var k = i32(localId.x); k < Length && outputIndex < uniforms.size;\n             k = k + ${n}) {\n           let candidate = f32(x[offset + k]);\n           ${e}\n         }\n         xBestValues[localId.x] = bestValue;\n         workgroupBarrier();\n\n         var reduceSize = min(u32(Length), ${n}u);\n         for (var currentSize = reduceSize / 2u; reduceSize > 1u;\n             currentSize = reduceSize / 2u) {\n           let interval = DIV_CEIL(reduceSize, 2u);\n           if (localId.x < currentSize) {\n            let candidate = xBestValues[localId.x + interval];\n            ${e}\n            xBestValues[localId.x] = bestValue;\n           }\n           reduceSize = interval;\n           workgroupBarrier();\n         }\n\n         if (localId.x == 0u && outputIndex < uniforms.size) {\n          ${r}\n        }\n       }\n     `}}function Pa(e,t,n,i,s){const o=e.shape.length,a=[],u=r.parseAxisParam(t,e.shape);let l=u;const h=z.getAxesPermutation(l,o);let c=e;null!=h&&(c=Ta({inputs:{x:e},attrs:{perm:h},backend:s}),l=z.getInnerMostAxes(l.length,o),a.push(c)),z.assertAxesAreInnerMostDims(i,l,o);const[d,p]=z.computeOutAndReduceShapes(c.shape,l);let f,m=d;if(n&&(m=z.expandShapeToKeepDim(d,u)),"max"!==i&&"prod"!==i||!s.shouldExecuteOnCPU([c])){const t=r.sizeFromShape(p),n={windowSize:t,inSize:t,batchSize:r.sizeFromShape(c.shape)/t,outSize:1},o="mean"===i?"float32":Z(e.dtype),u=[{type:"int32",data:[t]}],l=new Aa(n,i),h=s.runWebGPUProgram(l,[c],o,u);a.push(h),f=Hs({inputs:{x:h},attrs:{shape:m},backend:s})}else{const t=s.tensorMap.get(c.dataId).values;switch(i){case"max":const n=ea(t,r.sizeFromShape(p),m,e.dtype);f=s.makeTensorInfo(m,e.dtype,n);break;case"prod":const{outVals:o,outShape:a,outDtype:u}=oa(c.shape,c.dtype,t,l);f=s.makeTensorInfo(a,u,o);break;default:throw new Error(i+" CPU implementation is not yet supported.")}}return a.forEach(e=>s.disposeData(e.dataId)),f}const za={kernelName:J,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{keepDims:s,axis:o}=r;return Pa(i,o,s,"all",n)}};const Na={kernelName:ee,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{keepDims:s,axis:o}=r;return Pa(i,o,s,"any",n)}};class Ma{constructor(e,t,n){this.workgroupSize=[64,1,1],this.variableNames=["x"],this.uniforms="infinityValue : f32,",this.size=!0;const i=[t];this.op="min"===n?"<":">";const[s,o]=z.computeOutAndReduceShapes(e,i);this.outputShape=0===s.length?[1]:s,this.dispatchLayout=hs(this.outputShape),r.sizeFromShape(o)<32||r.sizeFromShape(s)>1e3?(this.type="plain",this.dispatch=as(this.dispatchLayout,this.outputShape,this.workgroupSize)):(this.type="shared",this.dispatch=as(this.dispatchLayout,this.outputShape,[1,1,1])),this.inputShape=e,this.shaderKey=`argMinMax_${this.op}_${this.type}`}getUserCode(){const e=this.workgroupSize[0],t=()=>1===this.inputShape.length?"uniforms.xShape":"uniforms.xShape."+Yi(this.inputShape.length-1),n=()=>{let e="";if(1===this.outputShape.length)1!==this.inputShape.length&&(e+="outputCoords,");else for(let t=0;t<this.outputShape.length;t++)e+=`outputCoords.${Yi(t)},`;return e};if("shared"===this.type){return`\n      fn DIV_CEIL(a : u32, b : u32) -> u32 {\n        return ((a - 1u) / b + 1u);\n      }\n\n      ${`\n      var<workgroup> xBestIndices : array<i32, ${e}>;\n      var<workgroup> xBestValues : array<f32, ${e}>;\n    `}\n\n      ${Qi("index")} {\n        let outputIndex = index / ${e};\n        let reduceLength = ${t()};\n\n        var bestIndex = i32(localId.x);\n        var bestValue = uniforms.infinityValue;\n        let outputCoords = getCoordsFromIndex(outputIndex);\n        for (var k = i32(localId.x); k < reduceLength && outputIndex < uniforms.size;\n            k = k + ${e}) {\n          let candidate = getX(${n()} k);\n          if (!isnan(candidate) && candidate ${this.op} bestValue) {\n            bestValue = candidate;\n            bestIndex = k;\n          }\n        }\n        xBestValues[localId.x] = bestValue;\n        xBestIndices[localId.x] = bestIndex;\n        workgroupBarrier();\n\n        var reduceSize = min(u32(reduceLength), ${e}u);\n        for (var currentSize = reduceSize / 2u; reduceSize > 1u;\n            currentSize = reduceSize / 2u) {\n          let interval = DIV_CEIL(reduceSize, 2u);\n          if (localId.x < currentSize) {\n            let candidate = xBestValues[localId.x + interval];\n            if (candidate ${this.op} bestValue) {\n              bestValue = candidate;\n              xBestValues[localId.x] = bestValue;\n              xBestIndices[localId.x] = xBestIndices[localId.x + interval];\n            }\n          }\n          reduceSize = interval;\n          workgroupBarrier();\n        }\n\n        if (localId.x == 0u && outputIndex < uniforms.size) {\n          setOutputAtIndexI32(outputIndex, xBestIndices[localId.x]);\n        }\n      }\n    `}return`\n      ${Qi("index")} {\n        if (index < uniforms.size) {\n          let outputCoords = getCoordsFromIndex(index);\n          var bestIndex = 0;\n          var bestValue = getX(${n()} 0);\n          let reduceLength = ${t()};\n          for (var i = 1; i < reduceLength; i++) {\n            let candidate = getX(${n()} i);\n            if (candidate ${this.op} bestValue) {\n              bestValue = candidate;\n              bestIndex = i;\n            }\n          }\n          setOutputAtIndexI32(index, bestIndex);\n        }\n      }\n      `}}const Fa={kernelName:te,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{x:s}=t,{axis:o}=i;let a=r.parseAxisParam(o,s.shape);const u=z.getAxesPermutation(a,s.shape.length);let l=s;const h=[];null!=u&&(l=Ta({inputs:{x:s},backend:n,attrs:{perm:u}}),h.push(l),a=z.getInnerMostAxes(a.length,l.shape.length)),z.assertAxesAreInnerMostDims("argMax",[a[0]],l.shape.length);const c=new Ma(l.shape,a[0],"max"),d=[{type:"float32",data:[Number.NEGATIVE_INFINITY]}],p=n.runWebGPUProgram(c,[l],"int32",d);return h.forEach(e=>n.disposeData(e.dataId)),p}};const Ea={kernelName:ne,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{x:s}=t,{axis:o}=i;let a=r.parseAxisParam(o,s.shape);const u=z.getAxesPermutation(a,s.shape.length);let l=s;const h=[];null!=u&&(l=Ta({inputs:{x:s},backend:n,attrs:{perm:u}}),h.push(l),a=z.getInnerMostAxes(a.length,l.shape.length)),z.assertAxesAreInnerMostDims("argMin",[a[0]],l.shape.length);const c=new Ma(l.shape,a[0],"min"),d=[{type:"float32",data:[Number.POSITIVE_INFINITY]}],p=n.runWebGPUProgram(c,[l],"int32",d);return h.forEach(e=>n.disposeData(e.dataId)),p}},_a={kernelName:re,backendName:"webgpu",kernelFunc:no({opType:Cs.ASIN})},Oa={kernelName:ie,backendName:"webgpu",kernelFunc:no({opType:Cs.ASINH})},Ba={kernelName:se,backendName:"webgpu",kernelFunc:no({opType:Cs.ATAN})},La={kernelName:oe,backendName:"webgpu",kernelFunc:ro({opType:gs.ATAN2})},Da={kernelName:ae,backendName:"webgpu",kernelFunc:no({opType:Cs.ATANH})};class Ua{constructor(e,t){this.variableNames=["x"],this.uniforms="stride : vec2<i32>, pad : vec2<i32>, dilation : vec2<i32>, convDims : vec2<i32>, filterDims : vec2<i32>,",this.workgroupSize=[128,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=hs(this.outputShape),this.dispatch=as(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="pool2D_"+t,this.poolType=t}getUserCode(){let e="resultValue = max(value, resultValue);";"avg"===this.poolType&&(e="resultValue = resultValue + value; count = count + 1.0;");let t="resultValue";"avg"===this.poolType&&(t="resultValue / max(count, 1.0)");return`\n      ${Qi("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n          let batch = coords[0];\n          let xRCCorner = vec2<i32>(coords.yz) * uniforms.stride - uniforms.pad;\n          let xRCorner = xRCCorner.x;\n          let xCCorner = xRCCorner.y;\n\n          var resultValue = ${"avg"===this.poolType?"0.0":"-1.0 / pow(10.0, -20.0)"};\n          var count = 0.0;\n\n          for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + uniforms.dilation.x) {\n            let xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= uniforms.convDims.x) {\n              continue;\n            }\n\n            for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + uniforms.dilation.y) {\n              let xC = xCCorner + wC;\n              if (xC < 0 || xC >= uniforms.convDims.y) {\n                continue;\n              }\n\n              let value = getX(batch, xR, xC, coords[3]);\n              ${e}\n            }\n          }\n\n          setOutputAtIndex(index, ${t});\n        }\n      }\n    `}}class Wa{constructor(e){this.variableNames=["x"],this.uniforms="stride : vec2<i32>,",this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=hs(this.outputShape),this.dispatch=as(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="poolWithFilterSizeEqualsOne"}getUserCode(){return`\n      ${Qi("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let batch = coords[0];\n          let d = coords[3];\n\n          let xRCCorner = coords.yz * uniforms.stride;\n          let xRCorner = xRCCorner.x;\n          let xCCorner = xRCCorner.y;\n\n          let value = getX(batch, xRCorner, xCCorner, d);\n          setOutputAtIndex(index, value);\n        }\n      }\n    `}}function Va(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{reductionIndices:s,keepDims:o}=r;return Pa(i,s,o,"max",n)}const Ga={kernelName:ue,backendName:"webgpu",kernelFunc:Va};function Ha(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{keepDims:s,axis:o}=r;return Pa(i,o,s,"mean",n)}const Ka={kernelName:le,backendName:"webgpu",kernelFunc:Ha};function Xa(e,t,n,i){if(1===t.filterWidth&&1===t.filterHeight&&r.arraysEqual(t.inShape,t.outShape))return Qs({inputs:{x:e},backend:i});if(t.filterWidth===t.inWidth&&t.filterHeight===t.inHeight&&1===t.batchSize&&"VALID"===t.padInfo.type){const s=e.shape.length,o=Hs({inputs:{x:e},backend:i,attrs:{shape:[e.shape[s-3]*e.shape[s-2],e.shape[s-1]]}});let a;"avg"===n?a=Ha({inputs:{x:o},backend:i,attrs:{axis:0,keepDims:!1}}):(r.assert("max"===n,()=>"Invalid pool type "+n),a=Va({inputs:{x:o},backend:i,attrs:{reductionIndices:0,keepDims:!1}}));const u=Hs({inputs:{x:a},backend:i,attrs:{shape:t.outShape}});return i.disposeData(o.dataId),i.disposeData(a.dataId),u}let s;const o=[{type:"int32",data:[t.strideHeight,t.strideWidth]}];return 1===t.filterHeight&&1===t.filterWidth?s=new Wa(t):("avg"===n?s=new Ua(t,"avg"):(r.assert("max"===n,()=>"Invalid pool type "+n),s=new Ua(t,"max")),o.push({type:"int32",data:[t.padInfo.top,t.padInfo.left]},{type:"int32",data:[t.dilationHeight,t.dilationWidth]},{type:"int32",data:[t.inHeight,t.inWidth]},{type:"int32",data:[t.effectiveFilterHeight,t.effectiveFilterWidth]})),i.runWebGPUProgram(s,[e],e.dtype,o)}const qa={kernelName:he,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{filterSize:s,strides:o,pad:a,dimRoundingMode:u}=r;return Xa(i,z.computePool2DInfo(i.shape,s,o,1,a,u),"avg",n)}};class ja{constructor(e){this.variableNames=["dy"],this.uniforms="stride : vec2<i32>, pads : vec2<i32>, dilation : vec2<i32>, filterDims : vec2<i32>,\n       outHeight : i32, outWidth : i32, avgMultiplier : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=hs(this.outputShape),this.dispatch=as(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="avg_pool2d_backprop"}getUserCode(){return`\n      ${Qi("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords[0];\n        let d = coords[3];\n\n        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;\n        let dyRCorner = dyRCCorner.x;\n        let dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        for (var wR = 0; wR < uniforms.filterDims[0]; wR = wR + uniforms.dilation[0]) {\n          let dyR = f32(dyRCorner + wR) / f32(uniforms.stride[0]);\n\n          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {\n            continue;\n          }\n          let idyR = i32(dyR);\n\n          for (var wC = 0; wC < uniforms.filterDims[1]; wC = wC + uniforms.dilation[1]) {\n            let dyC = f32(dyCCorner + wC) / f32(uniforms.stride[1]);\n\n            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {\n              continue;\n            }\n            let idyC = i32(dyC);\n\n            let dyValue = getDy(batch, idyR, idyC, d);\n\n            dotProd = dotProd + dyValue * uniforms.avgMultiplier;\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n    `}}const Ya={kernelName:ce,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{dy:s,input:o}=t,a=o;var u,l;u=[s,o],l="avgPoolGrad",Array.isArray(u)||(u=[u]),u.forEach(e=>{null!=e&&r.assert("complex64"!==e.dtype,()=>l+" does not support complex64 tensors in the WebGPU backend.")});const{filterSize:h,strides:c,pad:d}=i,p=z.computePool2DInfo(a.shape,h,c,1,d),f=new ja(p),m=1/(p.filterHeight*p.filterWidth),g=[{type:"int32",data:[p.strideHeight,p.strideWidth]},{type:"int32",data:[p.effectiveFilterHeight-1-p.padInfo.top,p.effectiveFilterWidth-1-p.padInfo.left]},{type:"int32",data:[p.dilationHeight,p.dilationWidth]},{type:"int32",data:[p.effectiveFilterHeight,p.effectiveFilterWidth]},{type:"int32",data:[p.outHeight]},{type:"int32",data:[p.outWidth]},{type:"float32",data:[m]}];return n.runWebGPUProgram(f,[s],a.dtype,g)}};const Qa={kernelName:de,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:i,b:s}=t,{transposeA:o,transposeB:a}=r;return Xs({a:i,b:s,transposeA:o,transposeB:a,backend:n})}};class Za{constructor(e,t){this.variableNames=["source"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.rank=t.length,this.dispatchLayout=hs(this.outputShape),this.dispatch=as(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.start=e,this.uniforms=`start : ${ji(e.length)}, `,this.shaderKey="slice"}getUserCode(){const e=ji(this.rank),t=function(e){if(1===e)return"sourceLoc";if(e<=6)return Ja.slice(0,e).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}(this.rank);let n;n=1===this.start.length?this.outputShape.map((e,t)=>"sourceLoc = uniforms.start + coords;"):this.outputShape.map((e,t)=>`sourceLoc.${Ja[t]} = uniforms.start.${Yi(t)} + coords.${Ja[t]};`);return`\n      ${Qi("index")} {\n        if (index < uniforms.size) {\n          var sourceLoc : ${e};\n          let coords = getCoordsFromIndex(index);\n          ${n.join("\n")}\n          setOutputAtIndex(index, getSource(${t}));\n        }\n      }\n    `}}const Ja=["x","y","z","w","u","v"];function eu(e){const{inputs:t,backend:n,attrs:i}=e,{x:s}=t,{begin:o,size:a}=i,[u,l]=G.parseSliceParams(s,o,a);if(G.assertParamsValid(s,u,l),n.shouldExecuteOnCPU([s])||"string"===s.dtype){const e=n.tensorMap.get(s.dataId),t=ca(e.values,u,l,s.shape,s.dtype);return n.makeTensorInfo(l,s.dtype,t)}if(0===r.sizeFromShape(l))return n.makeTensorInfo(l,s.dtype,[]);const h=new Za(u,l),c=[{type:"int32",data:u}];return n.runWebGPUProgram(h,[s],s.dtype,c)}const tu={kernelName:pe,backendName:"webgpu",kernelFunc:eu},nu={kernelName:fe,backendName:"webgpu",kernelFunc:e=>{const{inputs:t,backend:n,attrs:i}=e,{x:s}=t,{blockShape:o,crops:a}=i;r.assert(s.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGPU backend not implemented yet");const u=o.reduce((e,t)=>e*t),l=z.getReshaped(s.shape,o,u),h=z.getPermuted(l.length,o.length),c=z.getReshapedPermuted(s.shape,o,u),d=z.getSliceBeginCoords(a,o.length),p=z.getSliceSize(c,a,o.length),f=[],m=Hs({inputs:{x:s},backend:n,attrs:{shape:l}}),g=Ta({inputs:{x:m},backend:n,attrs:{perm:h}}),x=Hs({inputs:{x:g},backend:n,attrs:{shape:c}}),y=eu({inputs:{x:x},backend:n,attrs:{begin:d,size:p}});return f.push(m),f.push(g),f.push(x),f.forEach(e=>n.disposeData(e.dataId)),y}},ru=`\n  fn bincount_write(index: i32, value: f32) {\n    ${Xi("&result[index]","value","float32")}\n  }\n`;class iu{constructor(e,t,n=!1){this.outputShape=[],this.variableNames=["x"],this.uniforms="binCountSize : i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.hasWeights=!0,this.binaryOutput=!1,this.outputShape=e,this.rank=e.length,this.dispatchLayout=hs(this.outputShape),this.dispatch=as(this.dispatchLayout,this.outputShape,this.workgroupSize),this.binaryOutput=n,n&&(this.atomic=!1),this.hasWeights=t,this.hasWeights&&this.variableNames.push("w"),this.shaderKey=`bincount_${this.hasWeights}_${this.binaryOutput}_${this.rank}`}getUserCode(){return`\n    ${this.binaryOutput?"\n  fn bincount_write(index: i32, value: f32) {\n    atomicStore(&result[index], bitcast<i32>(value));\n  }\n":ru}\n  ${Qi("index")} {\n    ${1===this.rank?`if (index < uniforms.xShape) {\n      let indexVal = i32(getX(index));\n      if (indexVal < uniforms.binCountSize) {\n        let value = ${this.binaryOutput?1:this.hasWeights?"getW(index)":"1."};\n        bincount_write(indexVal, value);\n      }\n    }`:`let coord = getCoordsFromIndex(index);\n    if (coordsInBounds2D(coord, uniforms.xShape)) {\n      let indexVal = i32(getX(coord[0], coord[1]));\n      if (indexVal < uniforms.binCountSize) {\n        let value = ${this.binaryOutput?1:this.hasWeights?"getW(coord[0], coord[1])":"1."};\n        bincount_write(coord.x * uniforms.binCountSize + indexVal, value);\n      }\n    }`}\n  }\n  `}}const su={kernelName:me,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{x:s,weights:o}=t,{size:a}=i,u=r.sizeFromShape(s.shape),l=r.sizeFromShape(o.shape)>0,h=[a],c=o.dtype,d=Vs({backend:n,attrs:{shape:h,value:0,dtype:c}}),p=new iu([u],l),f=[{type:"int32",data:[a]}],m=l?[s,o]:[s];return n.runWebGPUProgram(p,m,c,f,d)}},ou=ro({opType:gs.NOT_EQUAL,dtype:"bool",cpuKernelImpl:sa}),au={kernelName:ge,backendName:"webgpu",kernelFunc:ou};function uu(e){const{inputs:t,backend:n}=e,{input:r}=t;return Qs({inputs:{x:n.tensorMap.get(r.dataId).complexTensorInfos.real},backend:n})}const lu={kernelName:xe,backendName:"webgpu",kernelFunc:uu};const hu={kernelName:ye,backendName:"webgpu",kernelFunc:function e(t){const{inputs:n,backend:i,attrs:s}=t,{x:o}=n,{dtype:a}=s;if("complex64"===a){if("complex64"===o.dtype)return Qs({inputs:{x:o},backend:i});const t=P(o.shape),n=e({inputs:{x:o},backend:i,attrs:{dtype:"float32"}}),r=Js({inputs:{real:n,imag:t},backend:i});return t.dispose(),i.disposeData(n.dataId),r}if("complex64"===o.dtype){const t=uu({inputs:{input:o},backend:i}),n=e({inputs:{x:t},backend:i,attrs:{dtype:a}});return i.disposeData(t.dataId),n}if(!r.hasEncodingLoss(o.dtype,a)){const e=Qs({inputs:{x:o},backend:i});return{dataId:e.dataId,shape:e.shape,dtype:a}}if(i.shouldExecuteOnCPU([o])){const e=i.tensorMap.get(o.dataId).values,[t,n,r]=Do(e,o.shape,o.dtype,a);return i.makeTensorInfo(t,n,r)}if("int32"===a)return function(e,t){const n=new to(e.shape,Cs.TO_INT),r=t.runWebGPUProgram(n,[e],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}(o,i);if("bool"===a){const e=i.makeTensorInfo([],"bool",r.getTypedArrayFromDType("bool",1)),t=ou({inputs:{a:o,b:e},backend:i});return i.disposeData(e.dataId),t}throw new Error(`Error in Cast: failed to cast ${o.dtype} to ${a}`)}},cu={kernelName:be,backendName:"webgpu",kernelFunc:no({opType:Cs.CEIL,cpuKernelImpl:Uo})};class du{constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workPerThread=4,this.workgroupSize=[64,1,1],this.isVec4=!0,this.size=!0,this.outputShape=e,this.dispatchLayout=hs(this.outputShape),this.dispatch=as(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="clipVec4"}getUserCode(){return`\n      ${Qi("index")} {\n        if(index < uniforms.size) {\n          let value = getAByOutputIndex(index);\n          var clampedValue = clamp(\n              value, vec4<f32>(uniforms.minVal), vec4<f32>(uniforms.maxVal));\n          clampedValue = select(clampedValue, value, isnanVec4(value));\n          setOutputAtIndex(index, clampedValue);\n        }\n      }\n    `}}class pu{constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=hs(this.outputShape),this.dispatch=as(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="clip"}getUserCode(){return`\n      ${Qi("index")} {\n        if(index < uniforms.size) {\n          let value = getAByOutputIndex(index);\n          if (isnan(value)) {\n            setOutputAtIndex(index, value);\n            return;\n          }\n          setOutputAtIndex(index, clamp(value, uniforms.minVal, uniforms.maxVal));\n        }\n      }\n    `}}const fu={kernelName:we,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{x:s}=t,{clipValueMin:o,clipValueMax:a}=i;let u;const l=[{type:"float32",data:[o]},{type:"float32",data:[a]}];return u=r.sizeFromShape(s.shape)%4==0?new du(s.shape):new pu(s.shape),n.runWebGPUProgram(u,[s],s.dtype,l)}};class mu{constructor(e){this.uniforms="",this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=z.computeOutShape(e,1),this.variableNames=e.map((e,t)=>"T"+t),this.dispatchLayout=hs(this.outputShape),this.dispatch=as(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.offsetLength=e.length-1;for(let e=0;e<this.offsetLength;e++)this.uniforms+=`offset${e} : i32,`;this.shaderKey="concat"}getUserCode(){const e=[];if(this.offsetLength>0){e.push("if (yC < uniforms.offset0){ setOutputAtCoords(coords.x, coords.y, getT0(yR, yC)); }");for(let t=1;t<this.offsetLength;t++)e.push(`else if (yC < uniforms.offset${[t]}){ setOutputAtCoords(coords.x, coords.y, getT${t}(yR, yC - uniforms.offset${t-1})); }`);const t=this.offsetLength,n=this.offsetLength-1;e.push(`else { setOutputAtCoords(coords.x, coords.y, getT${t}(yR, yC - uniforms.offset${n})); }`)}else e.push("setOutputAtCoords(coords.x, coords.y, getT0(yR, yC));");return`\n      ${Qi("index")} {\n        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {\n          let flatIndex = index * ${this.workPerThread} + i;\n          if(flatIndex < uniforms.size) {\n            let coords = getCoordsFromIndex(flatIndex);\n            let yR = coords.x;\n            let yC = coords.y;\n\n            ${e.join("\n        ")}\n          }\n        }\n      }\n    `}}function gu(e){const{inputs:t,backend:n}=e,{input:r}=t;return Qs({inputs:{x:n.tensorMap.get(r.dataId).complexTensorInfos.imag},backend:n})}const xu={kernelName:ve,backendName:"webgpu",kernelFunc:gu};function yu(e,t,n){const i=e[0].dtype;if("complex64"===i){const r=e.map(e=>uu({inputs:{input:e},backend:n})),i=e.map(e=>gu({inputs:{input:e},backend:n})),s=yu(r,t,n),o=yu(i,t,n),a=Js({inputs:{real:s,imag:o},backend:n});return r.forEach(e=>n.disposeData(e.dataId)),i.forEach(e=>n.disposeData(e.dataId)),n.disposeData(s.dataId),n.disposeData(o.dataId),a}let s=n.shouldExecuteOnCPU(e);if("string"===i&&(s=!0),s){const s=e.map(e=>{const i=r.sizeFromShape(e.shape.slice(t));return Hs({inputs:{x:e},backend:n,attrs:{shape:[-1,i]}})}),o=s.map(e=>({vals:n.readSync(e.dataId),shape:e.shape})),a=z.computeOutShape(s.map(e=>e.shape),1),u=1===s[0].shape[0],l=Wo(o,a,i,u),h=z.computeOutShape(e.map(e=>e.shape),t),c=n.makeTensorInfo(h,i,l);return s.forEach(e=>n.disposeData(e.dataId)),c}const o=n.device.limits.maxStorageBuffersPerShaderStage-1;if(e.length>o){const r=[];for(let i=0;i<e.length;i+=o){const s=e.slice(i,i+o);r.push(yu(s,t,n))}const i=yu(r,t,n);for(const e of r)n.disposeData(e.dataId);return i}const{tensors2D:a,outShape:u}=function(e,t,n){const i=z.computeOutShape(e.map(e=>e.shape),t);return{tensors2D:e.map(e=>Hs({inputs:{x:e},backend:n,attrs:{shape:[r.sizeFromShape(e.shape.slice(0,t)),r.sizeFromShape(e.shape.slice(t))]}})),outShape:i}}(e,t,n),l=a.map(e=>e.shape),h=new mu(l),c=[],d=new Array(l.length-1);if(d.length>0){d[0]=l[0][1],c.push({type:"int32",data:[d[0]]});for(let e=1;e<d.length;e++)d[e]=d[e-1]+l[e][1],c.push({type:"int32",data:[d[e]]})}const p=n.runWebGPUProgram(h,a,a[0].dtype,c);a.forEach(e=>n.disposeData(e.dataId));const f=Hs({inputs:{x:p},backend:n,attrs:{shape:u}});return n.disposeData(p.dataId),f}function bu(e){const{inputs:t,backend:n,attrs:i}=e,{axis:s}=i,o=r.parseAxisParam(s,t[0].shape)[0],a=t.map(e=>e.shape);z.assertParamsConsistent(a,o);const u=z.computeOutShape(t.map(e=>e.shape),o);if(0===r.sizeFromShape(u))return n.makeTensorInfo(u,t[0].dtype,[]);const l=t.filter(e=>r.sizeFromShape(e.shape)>0);return 1===l.length?Qs({inputs:{x:l[0]},backend:n}):yu(l,o,n)}const wu={kernelName:ke,backendName:"webgpu",kernelFunc:bu};class vu{constructor(e,t,n,r,i=!1,s=null,o=!1,a=!1){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>, dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.outShape,this.isChannelsLast="channelsLast"===e.dataFormat,this.isVec4=((e.inChannels%4==0||e.inChannels%3==0)&&this.isChannelsLast||e.outWidth%4==0&&!this.isChannelsLast)&&e.outChannels%4==0,this.dispatchLayout=this.isChannelsLast?{x:[3],y:[1,2],z:[0]}:{x:[2,3],y:[1],z:[0]},this.workgroupSize=us(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=ls(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=as(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4?(this.isChannelsLast&&e.inChannels%4!=0?(this.innerElementSize=3,this.variableTypes=["f32","vec4<f32>"]):(this.innerElementSize=4,this.variableTypes=["vec4<f32>","vec4<f32>"]),i&&(this.variableNames.push("bias"),this.variableTypes.push("vec4<f32>")),o&&(this.variableNames.push("preluActivationWeights"),this.variableTypes.push("vec4<f32>"))):(this.innerElementSize=this.elementsPerThread[0],i&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights")),this.sequentialAccessByThreads=a,this.addBias=i,this.activation=s,this.hasPreluActivationWeights=o,this.tileAOuter=this.workgroupSize[1]*this.elementsPerThread[1],this.tileBOuter=this.workgroupSize[0]*this.elementsPerThread[0],this.tileInner=Math.max(this.workgroupSize[0]*this.innerElementSize,this.workgroupSize[1]),this.fitAOuter=t%this.tileAOuter==0,this.fitBOuter=n%this.tileBOuter==0,this.fitInner=r%this.tileInner==0,this.shaderKey=`conv2DMM_${this.elementsPerThread}_${this.activation}}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.innerElementSize}_${this.isChannelsLast}_${this.sequentialAccessByThreads}`}getUserCode(){const e=this.isVec4?Fs(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner):_s(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner,!1,null,this.sequentialAccessByThreads),t=this.isVec4?[this.innerElementSize,4,4]:[1,1,1];return`\n    ${function(e,t,n,r,i=!1,s=null,o=!1,a=4,u=4,l=4){const h=e?"\n      let coord = vec4<i32>(batch, xRow, xCol, xCh);\n      ":"\n      let coord = vec4<i32>(batch, xCh, xRow, xCol);\n      ",c=e?"\n      let coords = vec4<i32>(\n        batch,\n        row / outWidth,\n        row % outWidth,\n        col);\n      ":"\n      let coords = vec4<i32>(\n        batch,\n        row,\n        col / outWidth,\n        col % outWidth);\n      ",d=e?"uniforms.xShape[1]":"uniforms.xShape[2]",p=e?"uniforms.xShape[2]":"uniforms.xShape[3]",f=e?"row":"col",m=e?"col":"row",g=`\n      let inChannels = uniforms.wShape[2];\n      let outWidth = ${e?"uniforms.outShape[2]":"uniforms.outShape[3]"};\n      let outRow = ${f} / outWidth;\n      let outCol = ${f} % outWidth;\n\n      let WRow = ${m} / (uniforms.filterDims[1] * inChannels);\n      let WCol = ${m} / inChannels % uniforms.filterDims[1];\n      let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];\n      let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];\n      let xCh = ${m} % inChannels;\n      var resData = ${As(a)}(0.0);\n      // The bounds checking is always needed since we use it to pad zero for\n      // the 'same' padding type.\n      if (xRow >= 0 && xRow < ${d} && xCol >= 0 && xCol < ${p}) {\n        ${h}\n        let xIndex = getIndexFromCoords4D(coord, uniforms.xShape);\n        ${(e=>{switch(e){case 1:return"resData = x[xIndex];";case 3:return"resData = vec3<f32>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);";case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${e} is not supported.`)}})(a)}\n      }\n      return resData;`,x=e?t&&r?`\n      let col = colIn * ${a};\n      ${g}`:`\n      let col = colIn * ${a};\n      if (row < uniforms.dimAOuter && col < uniforms.dimInner) {\n        ${g}\n      }\n      return ${As(a)}(0.0);`:r&&n?`\n      let col = colIn * ${a};\n      ${g}`:`\n      let col = colIn * ${a};\n      if (row < uniforms.dimInner && col < uniforms.dimBOuter) {\n        ${g}\n      }\n      return ${As(a)}(0.0);`,y=""+(e=>{switch(e){case 1:return"return W[row * uniforms.wShape[3] + colIn];";case 4:return"return W[row * uniforms.wShape[3] / 4 + colIn];";default:throw new Error(`innerElementSize ${e} is not supported.`)}})(u),b=As(l),w=As(e?a:u),v=As(e?u:a);return`\n      ${Ps(s,o,4===l,4)}\n      fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${w} {\n        ${e?x:y}\n      }\n\n      fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${v} {\n        ${e?y:x}\n      }\n\n      fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${b}) {\n        let col = colIn * ${l};\n        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)\n        {\n        var value = valueIn;\n        let outWidth = ${e?"uniforms.outShape[2]":"uniforms.outShape[3]"};\n        ${c}\n        ${zs(i,s)}\n        setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n        }\n      }`}(this.isChannelsLast,this.fitAOuter,this.fitBOuter,this.fitInner,this.addBias,this.activation,this.hasPreluActivationWeights,t[0],t[1],t[2])}\n    ${e}\n  `}}class ku{constructor(e,t=!1,n=null,r=!1){this.variableNames=["x","W"],this.uniforms="filterDims: vec2<i32>, pad: vec2<i32>, stride: vec2<i32>, dilation: vec2<i32>,",this.workgroupSize=[4,4,8],this.outputShape=e.outShape,this.isChannelsLast="channelsLast"===e.dataFormat,this.dispatchLayout=this.isChannelsLast?{x:[2],y:[1],z:[0,3]}:{x:[3],y:[2],z:[0,1]},this.dispatch=as(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=t,this.activation=n,this.hasPreluActivationWeights=r,t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`conv2dnaive_${this.activation}_${this.isChannelsLast}`}getUserCode(){return`\n       ${Ps(this.activation,this.hasPreluActivationWeights,!1,4)}\n       fn readInp(batch : i32, row : i32, col : i32, chan : i32) -> f32{\n         let coords = vec4<i32>(batch, row, col, chan);\n         if (coordsInBounds4D(coords, uniforms.xShape)) {\n           return  getX(batch, row, col, chan);\n         } else {\n          return 0.0;\n         }\n       }\n       fn readFilt(row : i32, col : i32, xChannel : i32, outChannel : i32) -> f32{\n         let coords = vec4<i32>(row, col, xChannel, outChannel);\n         if(coordsInBounds4D(coords, uniforms.wShape)) {\n           return getW(row, col, xChannel, outChannel);\n          } else {\n            return 0.0;\n          }\n       }\n       fn writeResult(batch : i32, row : i32, col : i32, chan : i32, valueIn : f32) {\n         let coords = ${this.isChannelsLast?"vec4<i32>(batch, row, col, chan);":"vec4<i32>(batch, chan, row, col);"}\n         if (coordsInBounds4D(coords, uniforms.outShape)) {\n           var value = valueIn;\n           ${zs(this.addBias,this.activation)}\n           setOutputAtCoords(coords.x, coords.y, coords.z, coords.w, value);\n         }\n       }\n       ${Qi("index")} {\n         let coords = getOutputCoords();\n         let batch = coords[0];\n         let outChannel = ${this.isChannelsLast?"coords[3];":"coords[1];"}\n         let outRow = ${this.isChannelsLast?"coords[1];":"coords[2];"}\n         let outCol = ${this.isChannelsLast?"coords[2];":"coords[3];"}\n         var acc : f32 = 0.0;\n         for (var row = 0; row < uniforms.filterDims[0]; row = row + 1) {\n           for (var col = 0; col < uniforms.filterDims[1]; col = col + 1) {\n             let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * row - uniforms.pad[0];\n             let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * col - uniforms.pad[1];\n             for (var xChannel = 0; xChannel < ${this.isChannelsLast?"uniforms.xShape[3];":"uniforms.xShape[1];"} xChannel = xChannel + 1) {\n               ${this.isChannelsLast?"let v = readInp(batch, xRow, xCol, xChannel);":"let v = readInp(batch, xChannel, xRow, xCol);"}\n               let f = readFilt(row, col, xChannel, outChannel);\n               acc = acc + v * f;\n             }\n           }\n         }\n         writeResult(batch, outRow, outCol, outChannel, acc);\n       }\n     `}}class Su{constructor(e,t){this.variableNames=["x"],this.uniforms="pad : vec2<i32>, stride : vec2<i32>, dilation : vec2<i32>, outWidth : i32, itemsPerBlockRow : i32,\n       inChannels : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=hs(this.outputShape),this.dispatch=as(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=t,this.shaderKey="im2col_"+this.isChannelsLast}getUserCode(){const e=this.isChannelsLast?1:2,t=this.isChannelsLast?2:3,n=this.isChannelsLast?"coords[1]":"coords[2]",r=this.isChannelsLast?"coords[2]":"coords[1]",i=this.isChannelsLast?"getX(batch, xRow, xCol, ch)":"getX(batch, ch, xRow, xCol)";return`\n    ${Qi("index")} {\n      let coords = getCoordsFromIndex(index);\n      if(index < uniforms.size) {\n        let batch = coords[0];\n        let row = ${n};\n        let col = ${r};\n        let offsetY = (row / uniforms.outWidth) * uniforms.stride[0] - uniforms.pad[0];\n        let xRow = offsetY + uniforms.dilation[0] * (col / uniforms.itemsPerBlockRow);\n        var value = 0.0;\n        if(xRow < uniforms.xShape[${e}] && xRow >= 0) {\n          let offsetX = (row % uniforms.outWidth) * uniforms.stride[1] -\n              uniforms.pad[1];\n          let xCol = offsetX + uniforms.dilation[1] * ((col %\n              uniforms.itemsPerBlockRow) / uniforms.inChannels);\n          let ch = col % uniforms.inChannels;\n          if(xCol < uniforms.xShape[${t}] && xCol >= 0) {\n            value = ${i};\n          }\n        }\n        setOutputAtIndex(index, value);\n      }\n    }\n   `}}function Iu(e,t){const n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&1===n&&e[0]>1?[e[0],1]:null}function Cu({x:e,filter:t,convInfo:n,backend:r,bias:i=null,preluActivationWeights:s=null,leakyreluAlpha:o=0,activation:a=null}){const u=null!=i,l=null!=s,h="channelsLast"===n.dataFormat,c=h&&n.filterHeight===n.inHeight&&n.filterWidth===n.inWidth&&"VALID"===n.padInfo.type,d=A().getBool("WEBGPU_USE_NAIVE_CONV2D_DEBUG");if(!d&&(c||1===n.filterHeight&&1===n.filterWidth&&1===n.dilationHeight&&1===n.dilationWidth&&1===n.strideHeight&&1===n.strideWidth&&("SAME"===n.padInfo.type||"VALID"===n.padInfo.type)))return function({x:e,filter:t,convInfo:n,backend:r,bias:i=null,preluActivationWeights:s=null,leakyreluAlpha:o=0,activation:a=null}){const u="channelsLast"===n.dataFormat,l=!u,h=[];let c,d;if(u&&n.filterHeight===n.inHeight&&n.filterWidth===n.inWidth&&"VALID"===n.padInfo.type){const i=n.inHeight*n.inWidth*n.inChannels;c=Hs({inputs:{x:e},backend:r,attrs:{shape:[1,n.batchSize,i]}}),d=Hs({inputs:{x:t},backend:r,attrs:{shape:[1,i,n.outChannels]}})}else c=Hs({inputs:{x:e},backend:r,attrs:{shape:u?[n.batchSize,n.inHeight*n.inWidth,n.inChannels]:[n.batchSize,n.inChannels,n.inHeight*n.inWidth]}}),d=Hs({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}});if(h.push(c),h.push(d),null!=s){const e=Iu(s.shape,u);null!=e&&(s=Hs({inputs:{x:s},backend:r,attrs:{shape:e}}),h.push(s))}if(null!=i){const e=Iu(i.shape,u);null!=e&&(i=Hs({inputs:{x:i},backend:r,attrs:{shape:e}}),h.push(i))}const p=Xs({a:u?c:d,b:u?d:c,transposeA:l,transposeB:!1,backend:r,bias:i,activation:a,preluActivationWeights:s,leakyreluAlpha:o}),f=Hs({inputs:{x:p},backend:r,attrs:{shape:n.outShape}});h.push(p);for(const e of h)r.disposeData(e.dataId);return f}({x:e,filter:t,convInfo:n,backend:r,bias:i,activation:a,preluActivationWeights:s,leakyreluAlpha:o});const p=A().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),f=p>0?p:r.thresholdToIncreaseWorkgroups,m=n.batchSize*Math.ceil(n.outHeight*n.outWidth/32)*Math.ceil(n.outChannels/32);if(A().getBool("WEBGPU_CONV_SEPARATE_IM2COL_SHADER")||m<=f)return function({x:e,filter:t,convInfo:n,backend:r,bias:i=null,preluActivationWeights:s=null,leakyreluAlpha:o=0,activation:a=null}){const{filterWidth:u,filterHeight:l,inChannels:h,strideWidth:c,strideHeight:d,padInfo:p,outWidth:f,outHeight:m,dilationWidth:g,dilationHeight:x,dataFormat:y}=n,b="channelsLast"===y,w=u*l*h,v=m*f,k=b?[n.batchSize,v,w]:[n.batchSize,w,v],S=new Su(k,b),I=[{type:"int32",data:[p.top,p.left]},{type:"int32",data:[d,c]},{type:"int32",data:[x,g]},{type:"int32",data:[f]},{type:"int32",data:[h*u]},{type:"int32",data:[h]}],C=r.runWebGPUProgram(S,[e],e.dtype,I),R=[];R.push(C);const T=Hs({inputs:{x:t},backend:r,attrs:{shape:[1,w,-1]}});if(R.push(T),null!=s){const e=Iu(s.shape,b);null!=e&&(s=Hs({inputs:{x:s},backend:r,attrs:{shape:e}}),R.push(s))}if(null!=i){const e=Iu(i.shape,b);null!=e&&(i=Hs({inputs:{x:i},backend:r,attrs:{shape:e}}),R.push(i))}const $=Xs({a:b?C:T,b:b?T:C,transposeA:!b,transposeB:!1,backend:r,bias:i,activation:a,preluActivationWeights:s,leakyreluAlpha:o}),A=Hs({inputs:{x:$},backend:r,attrs:{shape:n.outShape}});R.push($);for(const e of R)r.disposeData(e.dataId);return A}({x:e,filter:t,convInfo:n,backend:r,bias:i,preluActivationWeights:s,leakyreluAlpha:o,activation:a});let g;const x=[n.padInfo.top,n.padInfo.left],y=[{type:"int32",data:[n.filterHeight,n.filterWidth]},{type:"int32",data:[...x]},{type:"int32",data:[n.strideHeight,n.strideWidth]},{type:"int32",data:[n.dilationHeight,n.dilationWidth]}];if(d)g=new ku(n,u,a,l);else{const e=h?n.outHeight*n.outWidth:n.outChannels,t=h?n.outChannels:n.outHeight*n.outWidth,i=n.filterHeight*n.filterWidth*n.inChannels;y.push({type:"int32",data:[e]},{type:"int32",data:[t]},{type:"int32",data:[i]});const s=r.adapterInfo.isIntel();g=new vu(n,e,t,i,u,a,l,s)}const b=[],w=[e,t];u&&(h||1!==i.shape.length||(i=Hs({inputs:{x:i},backend:r,attrs:{shape:[i.shape[0],1,1]}}),b.push(i)),w.push(i)),l&&(h||1!==s.shape.length||(s=Hs({inputs:{x:s},backend:r,attrs:{shape:[s.shape[0],1,1]}}),b.push(s)),w.push(s)),"leakyrelu"===a&&(y.push({type:"float32",data:[o]}),g.uniforms+=" alpha : f32,");const v=r.runWebGPUProgram(g,w,e.dtype,y);for(const e of b)r.disposeData(e.dataId);return v}const Ru={kernelName:Se,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{x:i,filter:s}=t,{strides:o,pad:a,dataFormat:u,dilations:l,dimRoundingMode:h}=n,c=z.convertConv2DDataFormat(u);return Cu({x:i,filter:s,convInfo:z.computeConv2DInfo(i.shape,s.shape,o,l,a,h,!1,c),backend:r})}};class Tu{constructor(e){this.variableNames=["dy","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, stride : vec2<i32>, outBackprop : vec4<i32>,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=hs(this.outputShape),this.dispatch=as(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast="channelsLast"===e.dataFormat,this.shaderKey="conv2DDerInput_"+this.isChannelsLast}getUserCode(){const e=this.isChannelsLast?1:2,t=this.isChannelsLast?2:3,n=this.isChannelsLast?3:1;return`\n    ${Qi("index")} {\n      if(index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords[0];\n        let d1 = coords[${n}];\n\n        let dyCorner = vec2<i32>(coords[${e}], coords[${t}]) - uniforms.pads;\n        let dyRCorner = dyCorner.x;\n        let dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {\n          let dyR = (f32(dyRCorner) + f32(wR)) / f32(uniforms.stride.x);\n          let wRPerm = uniforms.filterDims.x - 1 - wR;\n          if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) || fract(dyR) > 0.0 ||\n              wRPerm < 0) {\n            continue;\n          }\n          let idyR = i32(dyR);\n\n          for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {\n            let dyC = (f32(dyCCorner) + f32(wC)) / f32(uniforms.stride.y);\n            let wCPerm = uniforms.filterDims.y - 1 - wC;\n            if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||\n                fract(dyC) > 0.0 || wCPerm < 0) {\n              continue;\n            }\n            let idyC = i32(dyC);\n\n            for (var d2 = 0; d2 < uniforms.outBackprop[3]; d2 = d2 + 1) {\n              if (${this.isChannelsLast}) {\n                let xValue = getDy(batch, idyR, idyC, d2);\n                let wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd = dotProd + xValue * wValue;\n              } else {\n                let xValue = getDy(batch, d2, idyR, idyC);\n                let wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd = dotProd + xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n  `}}class $u{constructor(e){this.variableNames=["x","dy"],this.uniforms="pad : vec2<i32>, stride : vec2<i32>, batchSize : i32, outHeight : i32, outWidth : i32, inHeight : i32, inWidth : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=hs(this.outputShape),this.dispatch=as(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast="channelsLast"===e.dataFormat,this.shaderKey="conv2DDerFilter_"+this.isChannelsLast}getUserCode(){return`\n    ${Qi("index")} {\n      if(index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let wR = coords[0];\n        let wC = coords[1];\n        let d1 = coords[2];\n        let d2 = coords[3];\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        for (var b = 0; b < uniforms.batchSize; b = b + 1) {\n          for (var yR = 0; yR < uniforms.outHeight; yR = yR + 1) {\n            let xR = wR + yR * uniforms.stride[0] - uniforms.pad[0];\n            if (xR < 0 || xR >= uniforms.inHeight) {\n              continue;\n            }\n\n            for (var yC = 0; yC < uniforms.outWidth; yC = yC + 1) {\n              let xC = wC + yC * uniforms.stride[1] - uniforms.pad[1];\n\n              if (xC < 0 || xC >= uniforms.inWidth) {\n                continue;\n              }\n\n              if (${this.isChannelsLast}) {\n                let dyValue = getDy(b, yR, yC, d2);\n                let xValue = getX(b, xR, xC, d1);\n                dotProd = dotProd + xValue * dyValue;\n              } else {\n                let dyValue = getDy(b, d2, yR, yC);\n                let xValue = getX(b, d1, xR, xC);\n                dotProd = dotProd + xValue * dyValue;\n              }\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n  `}}const Au={kernelName:Ie,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i,dy:s}=t,{strides:o,pad:a,dataFormat:u,dimRoundingMode:l,filterShape:h}=r,c=z.convertConv2DDataFormat(u),d=z.computeConv2DInfo(i.shape,h,o,1,a,l,!1,c),p=new $u(d),f=[{type:"int32",data:[d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.batchSize]},{type:"int32",data:[d.outHeight]},{type:"int32",data:[d.outWidth]},{type:"int32",data:[d.inHeight]},{type:"int32",data:[d.inWidth]}];return n.runWebGPUProgram(p,[i,s],i.dtype,f)}};class Pu{constructor(e){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, stride : vec2<i32>, outBackprop : vec4<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.inShape,r.assert("channelsLast"===e.dataFormat,()=>"TODO: NCHW is unimplemented"),this.isVec4=e.inChannels%4==0&&e.outChannels%4==0,this.dispatchLayout={x:[3],y:[1,2],z:[0]},this.workgroupSize=us(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=ls(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=as(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4&&(this.variableTypes=["vec4<f32>","f32"]),this.shaderKey=`conv2DDerInputMM_${this.isVec4}_${this.elementsPerThread}`}getUserCode(){const e=this.isVec4?Fs(this.elementsPerThread,this.workgroupSize):_s(this.elementsPerThread,this.workgroupSize);return`\n    ${function(e=4){const t=`if (row < uniforms.dimAOuter && col < uniforms.dimInner) {\n        ${`\n      let outRow = row / uniforms.outShape[2];\n      let outCol = row % uniforms.outShape[2];\n\n      let WRow = col / (uniforms.filterDims[1] * uniforms.outBackprop[3]);\n      let WCol = col / uniforms.outBackprop[3] % uniforms.filterDims[1];\n      let xR = f32(outRow - uniforms.pads[0] + WRow) / f32(uniforms.stride[0]);\n      let xC = f32(outCol - uniforms.pads[1] + WCol) / f32(uniforms.stride[1]);\n      if (xR < 0.0 || xR >= f32(uniforms.outBackprop[1]) || fract(xR) > 0.0) {\n        return ${As(e)}(0.0);\n      }\n      if (xC < 0.0 || xC >= f32(uniforms.outBackprop[2]) || fract(xC) > 0.0) {\n        return ${As(e)}(0.0);\n      }\n      let coord = vec4<i32>(\n          batch,\n          i32(xR),\n          i32(xC),\n          col % uniforms.outBackprop[3]);\n      return x[getIndexFromCoords4D(coord, uniforms.xShape)/${e}];`}\n      }\n      return ${As(e)}(0.0);`;return`\n  fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${As(e)} {\n    let col = colIn * ${e};\n    ${t}\n  }\n\n  fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${As(e)} {\n    let col = colIn * ${e};\n    let coordX = uniforms.filterDims.x - 1 -\n        row / (uniforms.filterDims[1] * uniforms.outBackprop[3]);\n    let coordY = uniforms.filterDims.y - 1 -\n        (row / uniforms.outBackprop[3]) % uniforms.filterDims[1];\n    if (row < uniforms.dimInner && col < uniforms.dimBOuter &&\n        coordX >= 0 && coordY >= 0) {\n      let rowInner = row % uniforms.outBackprop[3];\n      let coord = vec4<i32>(coordX, coordY, col, rowInner);\n      ${(e=>{switch(e){case 1:return"return W[getIndexFromCoords4D(coord, uniforms.wShape)];";case 4:return"\n            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);\n            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);\n            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);\n            let v0 = W[getIndexFromCoords4D(coord, uniforms.wShape)];\n            let v1 = W[getIndexFromCoords4D(coord1, uniforms.wShape)];\n            let v2 = W[getIndexFromCoords4D(coord2, uniforms.wShape)];\n            let v3 = W[getIndexFromCoords4D(coord3, uniforms.wShape)];\n            return vec4<f32>(v0, v1, v2, v3);\n            ";default:throw new Error(`innerElementSize ${e} is not supported.`)}})(e)}\n    }\n    return ${As(e)}(0.0);\n  }\n\n  fn mm_write(batch: i32, row : i32, colIn : i32, valueInput : ${As(e)}) {\n    let col = colIn * ${e};\n    if (row < uniforms.dimAOuter && (col + ${e-1}) < uniforms.dimBOuter) {\n      var value = valueInput;\n      let outCoord = vec4<i32>(\n          batch,\n          row / uniforms.outShape[2],\n          row % uniforms.outShape[2],\n          col);\n      result[getIndexFromCoords4D(outCoord, uniforms.outShape)/${e}] = value;\n    }\n  }`}(this.isVec4?4:1)}\n    ${e}\n    `}}const zu={kernelName:Ce,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:i,filter:s}=t,{inputShape:o,strides:a,pad:u,dataFormat:l,dimRoundingMode:h}=r,c=z.convertConv2DDataFormat(l),d=z.computeConv2DInfo(o,s.shape,a,1,u,h,!1,c),p=[{type:"int32",data:[d.filterHeight,d.filterWidth]},{type:"int32",data:[d.filterHeight-1-d.padInfo.top,d.filterWidth-1-d.padInfo.left]},{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.batchSize,d.outHeight,d.outWidth,d.outChannels]}];let f;if(A().getBool("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE")||d.filterHeight<=2&&d.filterWidth<=2&&d.outChannels<=16&&1===d.inChannels)f=new Tu(d);else{f=new Pu(d);const e=d.inHeight*d.inWidth,t=d.inChannels,n=d.filterHeight*d.filterWidth*d.outChannels;p.push({type:"uint32",data:[e]},{type:"uint32",data:[t]},{type:"uint32",data:[n]})}return n.runWebGPUProgram(f,[i,s],"float32",p)}},Nu={kernelName:Re,backendName:"webgpu",kernelFunc:no({opType:Cs.COS})},Mu={kernelName:Te,backendName:"webgpu",kernelFunc:no({opType:Cs.COSH})};class Fu{constructor(e,t,n,r){this.variableNames=["Image","Boxes","BoxInd"],this.uniforms="extrapolationValue : f32,",this.workgroupSize=[64,1,1],this.size=!0;const[i]=t;this.outputShape=[i,n[0],n[1],e],this.dispatchLayout=hs(this.outputShape),this.dispatch=as(this.dispatchLayout,this.outputShape,this.workgroupSize),this.methodId="bilinear"===r?1:0,this.cropHeightBiggerThan1=this.outputShape[1]>1,this.cropWidthBiggerThan1=this.outputShape[2]>1,this.shaderKey=`cropAndResize_${this.methodId}_${this.cropHeightBiggerThan1}_${this.cropWidthBiggerThan1}`}getUserCode(){const[e,t]=["f32(uniforms.imageShape[1] - 1)","f32(uniforms.imageShape[2] - 1)"],[n,r,i]=this.cropHeightBiggerThan1?[`(${e} / f32(uniforms.outShape[1] - 1))`,"(y2-y1) * height_ratio",`y1*${e} + f32(y)*(height_scale)`]:["0.0","0.0","0.5 * (y1+y2) * "+e],[s,o,a]=this.cropWidthBiggerThan1?[`(${t} / f32(uniforms.outShape[2] - 1))`,"(x2-x1) * width_ratio",`x1*${t} + f32(x)*(width_scale)`]:["0.0","0.0","0.5 * (x1+x2) * "+t];return`\n    ${Qi("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let height_ratio = f32(${n});\n        let width_ratio = f32(${s});\n        let b = coords[0];\n        let y = coords[1];\n        let x = coords[2];\n        let d = coords[3];\n        // get box vals\n        let y1 = getBoxes(b, 0);\n        let x1 = getBoxes(b, 1);\n        let y2 = getBoxes(b, 2);\n        let x2 = getBoxes(b, 3);\n        // get image in batch index\n        let bInd = i32(round(getBoxInd(b)));\n        if(bInd < 0 || bInd >= uniforms.outShape[0]) {\n          return;\n        }\n        let height_scale = ${r};\n        let width_scale = ${o};\n        let in_y = ${i};\n        if( in_y < 0.0 || in_y > ${e} ) {\n          setOutputAtIndex(index, uniforms.extrapolationValue);\n          return;\n        }\n        let in_x = ${a};\n        if( in_x < 0.0 || in_x > ${t} ) {\n          setOutputAtIndex(index, uniforms.extrapolationValue);\n          return;\n        }\n        let sourceFracIndexCR = vec2<f32>(in_x,in_y);\n        if(${this.methodId} == 1) {\n          // Compute the four integer indices.\n          let sourceFloorCR = vec2<i32>(sourceFracIndexCR);\n          let sourceCeilCR = vec2<i32>(ceil(sourceFracIndexCR));\n          let topLeft = getImage(bInd, sourceFloorCR.y, sourceFloorCR.x, d);\n          let bottomLeft = getImage(bInd, sourceCeilCR.y, sourceFloorCR.x, d);\n          let topRight = getImage(bInd, sourceFloorCR.y, sourceCeilCR.x, d);\n          let bottomRight = getImage(bInd, sourceCeilCR.y, sourceCeilCR.x, d);\n          let fracCR = sourceFracIndexCR - vec2<f32>(sourceFloorCR);\n          let top = topLeft + (topRight - topLeft) * fracCR.x;\n          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          let newValue = top + (bottom - top) * fracCR.y;\n          setOutputAtIndex(index, newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          let sourceNearestCR = vec2<i32>(floor(\n            sourceFracIndexCR + vec2<f32>(0.5,0.5)));\n          let newValue = getImage(\n            bInd, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutputAtIndex(index, newValue);\n        }\n      }\n    }\n    `}}const Eu={kernelName:$e,backendName:"webgpu",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{image:i,boxes:s,boxInd:o}=t,{cropSize:a,method:u,extrapolationValue:l}=r,h=new Fu(i.shape[3],s.shape,a,u),c=[{type:"float32",data:[l]}];return n.runWebGPUProgram(h,[i,s,o],"float32",c)}};var _u;!function(e){e.Prod="*",e.Sum="+"}(_u||(_u={}));class Ou{constructor(e,t,n,r){this.variableNames=["x"],this.uniforms="index : f32,",this.size=!0,this.workgroupSize=[128,1,1],this.outputShape=t,this.dispatchLayout=hs(this.outputShape),this.dispatch=as(this.dispatchLayout,this.outputShape,this.workgroupSize),this.exclusive=n,this.reverse=r,this.op=e,this.shaderKey=`cum_${this.op}_${this.exclusive}_${this.reverse}`}getUserCode(){const e=this.outputShape.length,t=this.op===_u.Prod?"1.0":"0.0",n=this.exclusive?t:`getX(${Bu(e,"coords",this.op)})`,r=this.outputShape[this.outputShape.length-1];let i="",s="";return this.exclusive?(i=this.reverse?"end != "+(r-1):"end != 0",s=this.reverse?"end + 1":"end - 1"):(i=this.reverse?"end + pow2 < "+r:"end >= pow2",s=this.reverse?"end + pow2":"end - pow2"),`\n      ${Qi("index")} {\n       if (index < uniforms.size) {\n         var coords = getCoordsFromIndex(index);\n\n         let end = ${Lu(e,"coords",this.op)};\n         var val = ${n};\n         let pow2 = i32(pow(2.0, uniforms.index));\n         if (${i}) {\n           let idx = ${s};\n           ${Lu(e,"coords",this.op)} = idx;\n           val ${this.op}= getX(${Bu(e,"coords",this.op)});\n         }\n         setOutputAtIndex(index, val);\n       }\n      }\n    `}}function Bu(e,t,n){if(1===e)return""+t;if(2===e)return`${t}.x, ${t}.y`;if(3===e)return`${t}.x, ${t}.y, ${t}.z`;if(4===e)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function Lu(e,t,n){if(1===e)return""+t;if(2===e)return t+".y";if(3===e)return t+".z";if(4===e)return t+".w";throw Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function Du(e,t,n,r,i,s){const o=t.shape.length,a=z.getAxesPermutation([r],o);let u=t;null!=a&&(u=Ta({inputs:{x:t},backend:n,attrs:{perm:a}}));const l=z.getInnerMostAxes(1,o)[0];if(l!==o-1)throw new Error(`WebGPU cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=`+r);const h=u.shape[l];let c=Qs({inputs:{x:u},backend:n});for(let t=0;t<=Math.ceil(Math.log2(h))-1;t++){const r=new Ou(e,u.shape,!1,s),i=c,o=[{type:"float32",data:[t]}];c=n.runWebGPUProgram(r,[c],c.dtype,o),n.disposeData(i.dataId)}if(i){const t=new Ou(e,u.shape,i,s),r=c,o=[{type:"float32",data:[0]}];c=n.runWebGPUProgram(t,[c],c.dtype,o),n.disposeData(r.dataId)}if(null!=a){const e=Ta({inputs:{x:c},backend:n,attrs:{perm:z.getUndoAxesPermutation(a)}});return n.disposeData(c.dataId),n.disposeData(u.dataId),e}return c}const Uu={kernelName:Ae,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{axis:s,exclusive:o,reverse:a}=r;return Du(_u.Prod,i,n,s,o,a)}};const Wu={kernelName:Pe,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{axis:s,exclusive:o,reverse:a}=r;return Du(_u.Sum,i,n,s,o,a)}};const Vu={kernelName:ze,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{x:s,weights:o}=t,{size:a,binaryOutput:u}=i,l=1===s.shape.length,h=r.sizeFromShape(o.shape)>0,c=o.dtype,d=l?[s.shape[0]]:[s.shape[0],s.shape[1]],p=Vs({backend:n,attrs:{shape:l?[a]:[s.shape[0],a],value:0,dtype:c}}),f=new iu(d,h,u),m=[{type:"int32",data:[a]}],g=h?[s,o]:[s];return n.runWebGPUProgram(f,g,c,m,p)}};class Gu{constructor(e,t){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.uniforms="blockSize : i32,",this.outputShape=e,this.dispatchLayout=hs(this.outputShape),this.dispatch=as(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthToSpace_"+t,this.dataFormat=t}getUserCode(){return`\n      ${Qi("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let b = coords[0];\n          let h = ${this.getHeightCoordString()};\n          let w = ${this.getWidthCoordString()};\n          let d = ${this.getDepthCoordString()};\n\n          let in_h = h / uniforms.blockSize;\n          let offset_h = h % uniforms.blockSize;\n          let in_w = w / uniforms.blockSize;\n          let offset_w = w % uniforms.blockSize;\n          let offset_d = (offset_h * uniforms.blockSize + offset_w) *\n            ${this.getOutputDepthSize()};\n          let in_d = d + offset_d;\n\n          let rlt = ${this.getInputSamplingString()};\n          setOutputAtIndex(index, rlt);\n        }\n      }`}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?"uniforms.outShape[3]":"uniforms.outShape[1]"}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const Hu={kernelName:Ne,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{blockSize:s,dataFormat:o}=r,a=i.shape[0],u=("NHWC"===o?i.shape[1]:i.shape[2])*s,l=("NHWC"===o?i.shape[2]:i.shape[3])*s,h=("NHWC"===o?i.shape[3]:i.shape[1])/(s*s),c=[{type:"int32",data:[s]}],d=new Gu("NHWC"===o?[a,u,l,h]:[a,h,u,l],o);return n.runWebGPUProgram(d,[i],i.dtype,c)}};class Ku{constructor(e,t,n,r=!1,i=null,s=!1){this.variableNames=["x","W"],this.uniforms="pad : vec2<i32>, inDims : vec2<i32>,",this.workgroupSize=[16,16,1],this.outputShape=e,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=as(this.dispatchLayout,this.outputShape,this.workgroupSize),r&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),this.addBias=r,this.activation=i,this.hasPreluActivation=s,this.filterHeight=t,this.filterWidth=n,this.shaderKey=`depthwiseNCHW_${this.activation}_${this.filterHeight}_${this.filterWidth}`}getUserCode(){const e=this.filterWidth*this.filterHeight,t=this.workgroupSize[0]*this.workgroupSize[1]*this.workgroupSize[2],n=this.workgroupSize[1]+this.filterHeight-1,r=this.workgroupSize[0]+this.filterWidth-1;return`\n      ${Ps(this.activation,this.hasPreluActivation,!1,4)}\n\n      var<workgroup> mm_Asub : array<array<f32, ${r}>, ${n}>;\n      var<workgroup> mm_Bsub : array<array<f32, ${this.filterWidth}>, ${this.filterHeight}>;\n      fn readX(batch : i32, channel : i32, row : i32, col : i32) -> f32 {\n        var value = 0.0;\n        if (row >=0 && row < uniforms.inDims[0] && col >=0 && col < uniforms.inDims[1])\n        {\n          value = getX(batch, channel, row, col);\n        }\n        return value;\n      }\n\n      ${Qi()} {\n        let coords = getOutputCoords();\n        let batch = coords[0];\n        let xRCCorner = vec2<i32>(coords.zw) - uniforms.pad;\n        let channelMul = uniforms.wShape[3];\n        let d1 = coords[1] / channelMul;\n        let q = coords[1] % channelMul;\n\n        let inputRowStart = xRCCorner.x;\n        let inputColStart = xRCCorner.y;\n\n        let localRow = i32(localId.y);\n        let localCol = i32(localId.x);\n\n        // Load one tile of X into local memory.\n        for (var inputRow = localRow; inputRow < ${n}; inputRow = inputRow + ${this.workgroupSize[1]}) {\n          for (var inputCol = localCol; inputCol < ${r}; inputCol = inputCol + ${this.workgroupSize[0]}) {\n            let rowOffset = inputRow - localRow;\n            let colOffset = inputCol - localCol;\n            mm_Asub[inputRow][inputCol] = readX(batch, d1, inputRowStart + rowOffset, inputColStart + colOffset);\n          }\n        }\n\n        // Load one tile of W into local memory.\n        var wIndex = i32(localIndex);\n        ${e<t?`if (wIndex < ${e})`:`for(; wIndex < ${e}; wIndex = wIndex + ${t})`}\n\n        {\n          let wRow = wIndex / ${this.filterWidth};\n          let wCol = wIndex % ${this.filterWidth};\n          mm_Bsub[wRow][wCol] = getW(wRow, wCol, d1, q);\n        }\n\n        workgroupBarrier();\n\n        var value = 0.0;\n        for (var wR = 0; wR < ${this.filterHeight}; wR = wR + 1) {\n          for (var wC = 0; wC < ${this.filterWidth}; wC = wC + 1) {\n            let xVal = mm_Asub[localRow + wR][localCol + wC];\n            let wVal = mm_Bsub[wR][wC];\n            value = fma(xVal, wVal, value);\n          }\n        }\n        ${zs(this.addBias,this.activation)}\n        if (coordsInBounds4D(coords, uniforms.outShape)) {\n          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n        }\n      }\n    `}}class Xu{constructor(e,t=!1,n=null,i=!1){this.variableNames=["x","W"],this.uniforms="pad : vec2<i32>, inDims : vec2<i32>,",this.workgroupSize=[4,4,4],this.workPerThread=4,this.isVec4=!0,this.outputShape=e.outShape,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=as(this.dispatchLayout,this.outputShape,this.workgroupSize,[4,this.workPerThread,1]),r.assert("channelsLast"===e.dataFormat,()=>"TODO: NCHW is unimplemented"),t&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=n,this.hasPreluActivation=i,this.shaderKey=`depthwiseVec4_${n}_${this.convInfo.filterHeight}_${this.convInfo.filterWidth}_${this.convInfo.strideHeight}_${this.convInfo.strideWidth}_${this.workPerThread}`}getUserCode(){const e=(this.workPerThread-1)*this.convInfo.strideWidth+this.convInfo.filterWidth,t=this.convInfo.strideHeight,n=this.convInfo.strideWidth;return`\n      ${Ps(this.activation,this.hasPreluActivation,!0,4)}\n      fn readX(batch : i32, row : i32, col : i32, channel : i32) -> vec4<f32> {\n        var value = vec4<f32>(0.0);\n        if (col >=0 && col < uniforms.inDims[1]) {\n          value = getX(batch, row, col, channel);\n        }\n        return value;\n      }\n\n      ${Qi()} {\n        let batch = i32(globalId.z) / uniforms.outShape[1];\n        let r = i32(globalId.z) % uniforms.outShape[1];\n        let c = i32(globalId.y) * ${this.workPerThread};\n        let d1 = i32(globalId.x) * 4;\n        let xRCCorner = vec2<i32>(r, c) * vec2<i32>(${t}, ${n}) - uniforms.pad;\n\n        let xRCorner = xRCCorner.x;\n        let xCCorner = xRCCorner.y;\n        var xVals : array<vec4<f32>, ${e}>;\n        var dotProd : array<vec4<f32>, ${this.workPerThread}>;\n        for (var i = 0; i < ${this.workPerThread}; i++) {\n          dotProd[i] = vec4<f32>(0.0);\n        }\n\n        // Use constant instead of uniform can give better performance.\n        for (var wR = 0; wR < ${this.convInfo.filterHeight}; wR = wR + 1) {\n          let xR = xRCorner + wR;\n          if (xR >=0 && xR < uniforms.inDims[0]) {\n            for (var i = 0; i < ${e}; i++) {\n              xVals[i] = readX(batch, xR, xCCorner + i, d1);\n            }\n            for (var wC = 0; wC < ${this.convInfo.filterWidth}; wC = wC + 1) {\n              let wValue = getW(wR, wC, d1, 0);\n              for (var i = 0; i < ${this.workPerThread}; i++) {\n                dotProd[i] = fma(xVals[i * ${n} + wC], wValue, dotProd[i]);\n              }\n            }\n          }\n        }\n\n        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {\n          let coords = vec4<i32>(batch, r, c + i, d1);\n          if (coordsInBounds4D(coords, uniforms.outShape)) {\n            var value = dotProd[i];\n            ${zs(this.addBias,this.activation)}\n            setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n          }\n        }\n      }\n    `}}class qu{constructor(e,t=!1,n=null,r=!1){this.variableNames=["x","W"],this.uniforms="pad : vec2<i32>, inDims : vec2<i32>, filterHeight : i32,\n      filterWidth : i32, stride : vec2<i32>, dilation : vec2<i32>,",this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=hs(this.outputShape),this.dispatch=as(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast="channelsLast"===e.dataFormat,t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=n,this.hasPreluActivation=r,this.shaderKey=`depthwise_${this.activation}_${this.isChannelsLast}`}getUserCode(){const e=this.isChannelsLast?"getX(batch, xR, xC, d1);":"getX(batch, d1, xR, xC);";return`\n      ${Ps(this.activation,this.hasPreluActivation,!1,4)}\n\n      ${Qi("index")} {\n        if (index < uniforms.size) {\n          let coords = getOutputCoords();\n          let batch = coords[0];\n          let xRCCorner = vec2<i32>(coords.${this.isChannelsLast?"yz":"zw"}) * uniforms.stride - uniforms.pad;\n          let d2 = coords[${this.isChannelsLast?3:1}];\n          let channelMul = uniforms.wShape[3];\n          let d1 = d2 / channelMul;\n          let q = d2 % channelMul;\n\n          let inputRowStart = xRCCorner.x;\n          let inputColStart = xRCCorner.y;\n          let inputRowEnd = inputRowStart + uniforms.filterHeight *\n              uniforms.dilation[0];\n          let inputColEnd = inputColStart + uniforms.filterWidth *\n              uniforms.dilation[1];\n\n          // Convolve x(?, ?, d1)|x(d1, ?, ?) with w(:, :, d1, q) to get\n          // y(yR, yC, d2)|y(d2, yR, yC). ? = to be determined. : = across all\n          // values in that axis. x(?, ?, d1) and y(yR, yC, d2) is for NHWC.\n          // x(d1, ?, ?) and y(d2, yR, yC) is for NCHW.\n          var value = 0.0;\n\n          // Extract if checking out of for loop for performance.\n          if (inputRowStart >= 0 && inputColStart >= 0 &&\n            inputRowEnd < uniforms.inDims[0] &&\n                inputColEnd < uniforms.inDims[1]) {\n              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {\n                let xR = inputRowStart + wR * uniforms.dilation[0];\n\n                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {\n                  let xC = inputColStart + wC * uniforms.dilation[1];\n\n                  let xVal = ${e};\n                  let wVal = getW(wR, wC, d1, q);\n                  value = value + xVal * wVal;\n                }\n              }\n            } else {\n              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {\n                let xR = inputRowStart + wR * uniforms.dilation[0];\n\n                if (xR < 0 || xR >= uniforms.inDims[0]) {\n                  continue;\n                }\n\n                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {\n                  let xC = inputColStart + wC * uniforms.dilation[1];\n\n                  if (xC < 0 || xC >= uniforms.inDims[1]) {\n                    continue;\n                  }\n\n                  let xVal = ${e};\n                  let wVal = getW(wR, wC, d1, q);\n                  value = value + xVal * wVal;\n                }\n              }\n            }\n            ${zs(this.addBias,this.activation)}\n          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n        }\n      }\n    `}}const ju={kernelName:Me,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i,filter:s}=t,{strides:o,pad:a,dataFormat:u,dilations:l,dimRoundingMode:h}=r,c=z.convertConv2DDataFormat(u);let d=l;null==d&&(d=[1,1]);const p=z.computeConv2DInfo(i.shape,s.shape,o,d,a,h,!0,c),f=[{type:"int32",data:[p.padInfo.top,p.padInfo.left]},{type:"int32",data:[p.inHeight,p.inWidth]}],m="channelsLast"===p.dataFormat;let g;return!m&&p.inHeight>16&&p.inWidth>16&&1===p.strideHeight&&1===p.strideWidth&&1===p.dilationWidth&&1===p.dilationHeight&&p.inChannels===p.outChannels?g=new Ku(p.outShape,p.filterHeight,p.filterWidth):m&&p.outHeight>4&&p.outWidth>4&&p.strideWidth<=2&&p.inChannels===p.outChannels&&1===p.dilationHeight&&1===p.dilationWidth&&p.inChannels%4==0?g=new Xu(p):(g=new qu(p),f.push({type:"int32",data:[p.filterHeight]},{type:"int32",data:[p.filterWidth]},{type:"int32",data:[p.strideHeight,p.strideWidth]},{type:"int32",data:[p.dilationHeight,p.dilationWidth]})),n.runWebGPUProgram(g,[i,s],i.dtype,f)}};class Yu{constructor(e){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,e],this.dispatchLayout=hs(this.outputShape),this.dispatch=as(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="diag"}getUserCode(){return`\n      ${Qi("index")} {\n        if (index < uniforms.size) {\n          let coords = getOutputCoords();\n          let value = select(0.0, getX(coords[0]), coords[0] == coords[1]);\n          setOutputAtIndex(index, value);\n        }\n      }\n    `}}const Qu={kernelName:Fe,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:i}=t,s=[...i.shape,...i.shape],o=r.sizeFromShape(i.shape),a=Hs({inputs:{x:i},backend:n,attrs:{shape:[o]}}),u=new Yu(o),l=n.runWebGPUProgram(u,[a],a.dtype),h=Hs({inputs:{x:l},backend:n,attrs:{shape:s}});return n.disposeData(a.dataId),n.disposeData(l.dataId),h}};class Zu{constructor(e){this.variableNames=["x","w"],this.uniforms="filterDims: vec2<i32>, pad: vec2<i32>, stride: vec2<i32>, dilation: vec2<i32>",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=hs(this.outputShape),this.dispatch=as(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="dilation2d"}getUserCode(){return`\n       ${Qi("index")} {\n         if (index < uniforms.size) {\n           let neg_infinity = -3.4e38;\n           let coords = getOutputCoords();\n           let batch = coords.x;\n           let d1 = coords.w;\n           let outTopLeftCorner = coords.yz * uniforms.stride - uniforms.pad;\n           let hBeg = outTopLeftCorner.x;\n           let wBeg = outTopLeftCorner.y;\n\n           var curVal = neg_infinity;\n           for (var h = 0; h < uniforms.filterDims[0]; h = h + 1) {\n             let hIn = hBeg + h * uniforms.dilation[0];\n\n             if (hIn >= 0 && hIn < uniforms.xShape[1]) {\n               for (var w = 0; w < uniforms.filterDims[1]; w = w + 1) {\n                 let wIn = wBeg + w * uniforms.dilation[1];\n\n                 if (wIn >= 0 && wIn < uniforms.xShape[2]) {\n                   let val = getX(batch, hIn, wIn, d1) + getW(h, w, d1);\n                   if (val > curVal) {\n                     curVal = val;\n                   }\n                 }\n               }\n             }\n           }\n\n           setOutputAtIndex(index, curVal);\n         }\n       }\n     `}}const Ju={kernelName:Ee,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i,filter:s}=t,{strides:o,pad:a,dilations:u}=r,l=z.computeDilation2DInfo(i.shape,s.shape,o,a,"NHWC",u),h=[l.padInfo.top,l.padInfo.left],c=[{type:"int32",data:[l.filterHeight,l.filterWidth]},{type:"int32",data:[...h]},{type:"int32",data:[l.strideHeight,l.strideWidth]},{type:"int32",data:[l.dilationHeight,l.dilationWidth]}],d=new Zu(l);return n.runWebGPUProgram(d,[i,s],i.dtype,c)}},el=ro({opType:gs.MUL,cpuKernelImpl:ra,supportsComplex:!0}),tl={kernelName:_e,backendName:"webgpu",kernelFunc:el};function nl(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{axis:s,keepDims:o}=r;return Pa(i,s,o,"sum",n)}const rl={kernelName:Oe,backendName:"webgpu",kernelFunc:nl};const il={kernelName:Be,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{equation:s}=i,o=t,{allDims:a,summedDims:u,idDims:l}=z.decodeEinsumEquation(s,o.length);z.checkEinsumDimSizes(a.length,l,o);const{path:h,steps:c}=z.getEinsumComputePath(u,l),d=c.length;let p=null,f=a.length;const m=[];for(let e=0;e<d;++e){for(const t of c[e]){const{permutationIndices:e,expandDims:i}=z.getEinsumPermutation(f,l[t]);let s;z.isIdentityPermutation(e)?s=o[t]:(s=Ta({inputs:{x:o[t]},backend:n,attrs:{perm:e}}),m.push(s));const a=s.shape.slice();for(let e=0;e<i.length;++e)a.splice(i[e],0,1);r.arraysEqual(s.shape,a)||(s=Hs({inputs:{x:s},backend:n,attrs:{shape:a}}),m.push(s)),null===p?p=s:(p=el({inputs:{a:s,b:p},backend:n}),m.push(p))}e<d-1&&(h[e]>=0&&(p=nl({inputs:{x:p},backend:n,attrs:{axis:h[e]-(a.length-f),keepDims:!1}}),m.push(p)),f--)}for(const e of m)e!==p&&n.disposeData(e.dataId);return p}},sl={kernelName:Le,backendName:"webgpu",kernelFunc:no({opType:Cs.ELU})},ol={kernelName:De,backendName:"webgpu",kernelFunc:ro({opType:gs.EQUAL,dtype:"bool",cpuKernelImpl:Vo})},al={kernelName:Ue,backendName:"webgpu",kernelFunc:no({opType:Cs.ERF})},ul=no({opType:Cs.EXP,cpuKernelImpl:Go,dtype:"float32"}),ll={kernelName:We,backendName:"webgpu",kernelFunc:ul};function hl(e){const{inputs:t,attrs:n,backend:i}=e,{dim:s}=n,{input:o}=t,a=o.shape.length,u=o.shape.slice();let l=s;return s<0&&(r.assert(-(a+1)<=s,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),l=a+s+1),u.splice(l,0,1),Hs({inputs:{x:o},backend:i,attrs:{shape:u}})}const cl={kernelName:Ve,backendName:"webgpu",kernelFunc:hl},dl={kernelName:Ge,backendName:"webgpu",kernelFunc:no({opType:Cs.EXPM1,cpuKernelImpl:Ho})};class pl{constructor(e,t){this.variableNames=["real","imag"],this.outputShape=[],this.uniforms="exponentMultiplier : f32, denominator: f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=hs(this.outputShape),this.dispatch=as(this.dispatchLayout,this.outputShape,this.workgroupSize),this.component=e,this.shaderKey="fft_"+e}getUserCode(){return`\n    fn unaryOpComplex(real: f32, expR: f32, imag: f32, expI: f32) -> f32 {\n      ${"real"===this.component?"return real * expR - imag * expI;":"return real * expI + imag * expR;"}\n    }\n\n    fn mulMatDFT(batch: i32, index: i32) -> f32 {\n      let indexRatio = f32(index) / f32(uniforms.realShape[1]);\n      let exponentMultiplierTimesIndexRatio =\n          uniforms.exponentMultiplier * indexRatio;\n\n      var result = 0.0;\n\n      for (var i = 0; i < uniforms.realShape[1]; i = i + 1) {\n        // x = (-2|2 * PI / N) * index * i;\n        let x = exponentMultiplierTimesIndexRatio * f32(i);\n        let expR = cos(x);\n        let expI = sin(x);\n        let real = getReal(batch, i);\n        let imag = getImag(batch, i);\n\n        result = result +\n            unaryOpComplex(real, expR, imag, expI) / uniforms.denominator;\n      }\n\n      return result;\n    }\n\n    ${Qi("index")} {\n      if (index < uniforms.size) {\n        let coords = getOutputCoords();\n        setOutputAtIndex(index, mulMatDFT(coords[0], coords[1]));\n      }\n    }\n  `}}function fl(e,t,n){const i=n.tensorMap.get(e.dataId),s=r.sizeFromShape(e.shape),o=e.shape[e.shape.length-1],a=[],u=Hs({inputs:{x:e},backend:n,attrs:{shape:[s/o,o]}});a.push(u);const l=u.shape,h=new pl("real",l),c=new pl("imag",l),d=[{dataId:i.complexTensorInfos.real.dataId,dtype:i.complexTensorInfos.real.dtype,shape:l},{dataId:i.complexTensorInfos.imag.dataId,dtype:i.complexTensorInfos.imag.dtype,shape:l}],p=[{type:"float32",data:[t?2*Math.PI:-2*Math.PI]},{type:"float32",data:[t?l[1]:1]}],f=n.runWebGPUProgram(h,d,"float32",p);a.push(f);const m=n.runWebGPUProgram(c,d,"float32",p);a.push(m);const g=Js({inputs:{real:f,imag:m},backend:n});a.push(g);const x=Hs({inputs:{x:g},backend:n,attrs:{shape:e.shape}});return a.forEach(e=>n.disposeData(e.dataId)),x}const ml={kernelName:He,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t;return fl(r,!1,n)}};class gl{constructor(e){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=hs(this.outputShape),this.dispatch=as(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="flipLeftRight"}getUserCode(){return`\n      ${Qi("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let coordX = uniforms.xShape[2] - coords[2] - 1;\n          let outputValue = getX(coords[0], coords[1], coordX, coords[3]);\n          setOutputAtIndex(index, outputValue);\n        }\n      }\n    `}}const xl={kernelName:Ke,backendName:"webgpu",kernelFunc:({inputs:e,backend:t})=>{const{image:n}=e,r=t,i=new gl(n.shape);return r.runWebGPUProgram(i,[n],n.dtype)}},yl={kernelName:Xe,backendName:"webgpu",kernelFunc:no({opType:Cs.FLOOR,cpuKernelImpl:Ko})},bl={kernelName:qe,backendName:"webgpu",kernelFunc:ro({opType:gs.INT_DIV,dtype:"int32"})};class wl{constructor(e,t,n=!1){this.isFromPixels=!0,this.outputShape=[0],this.variableNames=[],this.workgroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout=hs(this.outputShape),this.dispatch=as(this.dispatchLayout,this.outputShape,this.workgroupSize,[t,1,1]),this.importVideo=n,this.shaderKey="fromPixels_"+this.importVideo}getUserCode(){const e=this.importVideo?"textureLoad(src, vec2<i32>(coords.yx));":"textureLoad(src, vec2<i32>(coords.yx), 0)";return`\n      @binding(1) @group(0) var src: ${this.importVideo?"texture_external":"texture_2d<f32>"};\n      ${Qi("index")} {\n        let flatIndex = index * uniforms.numChannels;\n        if (flatIndex < uniforms.size) {\n          let coords = getCoordsFromIndex(flatIndex);\n          let values = ${e};\n          for (var i = 0; i < uniforms.numChannels; i = i + 1) {\n            result[flatIndex + i] = i32(floor(255.0 * values[i]));\n          }\n        }\n      }\n  `}}const vl={kernelName:je,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e;let{pixels:s}=t;const{numChannels:o}=i;if(null==s)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");const a="undefined"!=typeof HTMLVideoElement&&s instanceof HTMLVideoElement,u="undefined"!=typeof HTMLImageElement&&s instanceof HTMLImageElement,l="undefined"!=typeof HTMLCanvasElement&&s instanceof HTMLCanvasElement||"undefined"!=typeof OffscreenCanvas&&s instanceof OffscreenCanvas,h="undefined"!=typeof ImageBitmap&&s instanceof ImageBitmap,[c,d]=a?[s.videoWidth,s.videoHeight]:[s.width,s.height],p=[d,c,o],f=a||u;if(h||l||f){let e;{if(f){const e=A().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");null!=kl&&e===Sl||(Sl=e,kl=document.createElement("canvas").getContext("2d",{willReadFrequently:Sl})),kl.canvas.width=c,kl.canvas.height=d,kl.drawImage(s,0,0,c,d),s=kl.canvas}const t=GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING,r="rgba8unorm",i=n.textureManager.acquireTexture(p[1],p[0],r,t);n.queue.copyExternalImageToTexture({source:s},{texture:i},[p[1],p[0]]),e={width:c,height:d,format:r,usage:t,texture:i}}const t=r.sizeFromShape(p),i=r.computeStrides(p),a=new wl(p,o,!1),u=[{type:"uint32",data:[t]},{type:"uint32",data:[o]},{type:"uint32",data:[...i]}],l=n.makeTensorInfo([d,c],"int32");n.tensorMap.get(l.dataId).resourceInfo=e;const h=n.runWebGPUProgram(a,[l],"int32",u);return n.disposeData(l.dataId),h}const m=s.data;let g=m;if(null!=o&&4!==o){g=new Uint8Array(s.width*s.height*o);const e=m.length;let t=0;for(let n=0;n<e;n++)n%4<o&&(g[t++]=m[n])}const x=n.makeTensorInfo(p,"int32",new Int32Array(g));return n.uploadToGPU(x.dataId),x}};let kl,Sl=A().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");class Il{constructor(e,t,n,r,i){this.uniforms="varianceEpsilon : f32,",this.workgroupSize=[128,1,1],this.size=!0,this.variableNames=["x","mean","variance"],z.assertAndGetBroadcastShape(e,t),z.assertAndGetBroadcastShape(e,n),this.outputShape=e,this.dispatchLayout=hs(this.outputShape),this.dispatch=as(this.dispatchLayout,this.outputShape,this.workgroupSize),null!=r&&(z.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset")),null!=i&&(z.assertAndGetBroadcastShape(e,i),this.variableNames.push("scale")),this.offsetShape=r,this.scaleShape=i,this.shaderKey="batchNorm"}getUserCode(){let e="0.0";null!=this.offsetShape&&(e="getOffsetByOutputIndex(index)");let t="1.0";null!=this.scaleShape&&(t="getScaleByOutputIndex(index)");return`\n      ${Qi("index")} {\n        if (index < uniforms.size)\n        {\n          let xValue = getXByOutputIndex(index);\n          let meanValue = getMeanByOutputIndex(index);\n          let varianValue = getVarianceByOutputIndex(index);\n          let offsetValue = ${e};\n          let scaleValue = ${t};\n          let inv = scaleValue * inverseSqrt(varianValue + f32(uniforms.varianceEpsilon));\n          setOutputAtIndex(index,dot(vec3<f32>(xValue, -meanValue, offsetValue), vec3<f32>(inv, inv, 1.0)));\n        }\n      }\n  `}}const Cl={kernelName:Ye,backendName:"webgpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r,scale:i,offset:s,mean:o,variance:a}=e,{varianceEpsilon:u}=t,l=n,h=[r,o,a];let c=null;null!=s&&(c=s.shape,h.push(s));let d=null;null!=i&&(d=i.shape,h.push(i));const p=new Il(r.shape,o.shape,a.shape,c,d),f=[{type:"float32",data:[u]}];return l.runWebGPUProgram(p,h,r.dtype,f)}};const Rl={kernelName:Qe,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i,filter:s,bias:o,preluActivationWeights:a}=t,{strides:u,pad:l,dataFormat:h,dilations:c,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=r,m=z.convertConv2DDataFormat(h);return Cu({x:i,filter:s,convInfo:z.computeConv2DInfo(i.shape,s.shape,u,c,l,d,!1,m),backend:n,bias:o,preluActivationWeights:a,leakyreluAlpha:f,activation:p})}};const Tl={kernelName:Ze,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{x:s,filter:o,bias:a,preluActivationWeights:u}=t,{strides:l,pad:h,dilations:c,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=i;let m=c;null==m&&(m=[1,1]),r.assert(z.eitherStridesOrDilationsAreOne(l,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${m}'`);const g=z.computeConv2DInfo(s.shape,o.shape,l,m,h,d,!0),x=[s,o],y=null!=a,b=null!=u;y&&x.push(a),b&&x.push(u);const w=[{type:"int32",data:[g.padInfo.top,g.padInfo.left]},{type:"int32",data:[g.inHeight,g.inWidth]}];let v;return g.outHeight>4&&g.outWidth>4&&g.strideWidth<=2&&g.inChannels===g.outChannels&&1===g.dilationHeight&&1===g.dilationWidth&&g.inChannels%4==0?v=new Xu(g,y,p,b):(v=new qu(g,y,p,b),w.push({type:"int32",data:[g.filterHeight]},{type:"int32",data:[g.filterWidth]},{type:"int32",data:[g.strideHeight,g.strideWidth]},{type:"int32",data:[g.dilationHeight,g.dilationWidth]})),"leakyrelu"===p&&(w.push({type:"float32",data:[f]}),v.uniforms+=" alpha : f32,"),n.runWebGPUProgram(v,x,"float32",w)}};class $l{constructor(e,t){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=hs(this.outputShape),this.dispatch=as(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="gathernd_"+e,this.sliceDim=e,this.uniforms=`sliceDim : i32, strides : ${ji(e)},`}getUserCode(){let e;e=this.sliceDim>1?"uniforms.strides[j]":"uniforms.strides";return`\n      ${Qi("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          var flattenIndex = 0;\n          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {\n            let indexTemp = i32(round(getIndices(coords[0], j)));\n            let strideNum = ${e};\n            flattenIndex = flattenIndex + indexTemp * strideNum;\n          }\n\n          setOutputAtIndex(index, getA(flattenIndex, coords[1]));\n        }\n      }\n      `}}const Al={kernelName:Je,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:i,indices:s}=t,o=s.shape,a=o[o.length-1],u=r.sizeFromShape(i.shape),[l,h,c,d]=z.prepareAndValidate(i,s),p=Hs({inputs:{x:s},backend:n,attrs:{shape:[h,a]}}),f=Hs({inputs:{x:i},backend:n,attrs:{shape:[r.sizeFromShape(i.shape)/c,c]}});if(n.shouldExecuteOnCPU([i,s])||"string"===i.dtype){const e=n.readSync(s.dataId),t=n.bufferSync(i),r=Xo(e,t,i.dtype,h,a,c,d,i.shape,u);return n.makeTensorInfo(l,i.dtype,r.values)}const m=new $l(a,[h,c]),g=[{type:"int32",data:[a]},{type:"int32",data:d}],x=n.runWebGPUProgram(m,[f,p],f.dtype,g),y=Hs({inputs:{x:x},backend:n,attrs:{shape:l}});return n.disposeData(p.dataId),n.disposeData(f.dataId),n.disposeData(x.dataId),y}};class Pl{constructor(e,t){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.slice(),this.aShape=e,this.outputShape=t,this.dispatchLayout=hs(this.outputShape),this.dispatch=as(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="gather"}getUserCode(){const e=function(e){const t=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[];for(let r=0;r<e.length;r++)2===r?n.push("indexZ"):n.push(""+t[r]);return n.join()}(this.aShape);return`\n      ${Qi("index")} {\n        if (index < uniforms.size) {\n          let resRC = getCoordsFromIndex(index);\n          let indexZ = i32(getIndices(resRC.x, resRC.z));\n          let inBounds = select(0.0, 1.0, indexZ >= 0 && indexZ < uniforms.aShape[2]);\n          setOutputAtIndex(index, inBounds * getA(${e}));\n        }\n      }\n    `}}function zl(e){const{inputs:t,backend:n,attrs:i}=e,{x:s,indices:o}=t,{axis:a,batchDims:u}=i,l=r.parseAxisParam(a,s.shape)[0],h=z.segment_util.collectGatherOpShapeInfo(s,o,l,u),c=r.sizeFromShape(o.shape),d=[],p=Hs({inputs:{x:s},backend:n,attrs:{shape:[h.batchSize,h.outerSize,h.dimSize,h.sliceSize]}}),f=Hs({inputs:{x:o},backend:n,attrs:{shape:[h.batchSize,c/h.batchSize]}});d.push(p),d.push(f);const m=[h.batchSize,h.outerSize,c/h.batchSize,h.sliceSize];if(n.shouldExecuteOnCPU([s,o])){const e=n.tensorMap.get(f.dataId).values,t=F(f.shape,f.dtype,e),r=n.tensorMap.get(p.dataId).values,i=F(p.shape,p.dtype,r),s=qo(i,t,m);return d.forEach(e=>n.disposeData(e.dataId)),n.makeTensorInfo(h.outputShape,s.dtype,s.values)}const g=new Pl(p.shape,m),x=n.runWebGPUProgram(g,[p,f],p.dtype);d.push(x);const y=Hs({inputs:{x:x},backend:n,attrs:{shape:h.outputShape}});return d.forEach(e=>n.disposeData(e.dataId)),y}const Nl={kernelName:et,backendName:"webgpu",kernelFunc:zl},Ml={kernelName:tt,backendName:"webgpu",kernelFunc:ro({opType:gs.GREATER,cpuKernelImpl:Yo,dtype:"bool"})},Fl={kernelName:nt,backendName:"webgpu",kernelFunc:ro({opType:gs.GREATER_EQUAL,dtype:"bool",cpuKernelImpl:jo})};const El={kernelName:rt,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t;return fl(r,!0,n)}},_l={kernelName:it,backendName:"webgpu",kernelFunc:no({opType:Cs.IS_FINITE,dtype:"bool"})},Ol={kernelName:st,backendName:"webgpu",kernelFunc:no({opType:Cs.IS_INF,dtype:"bool"})},Bl={kernelName:ot,backendName:"webgpu",kernelFunc:no({opType:Cs.IS_NAN,dtype:"bool"})};const Ll={kernelName:at,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{alpha:s}=r,o=[{type:"float32",data:[s]}],a=new to(i.shape,Cs.LEAKYRELU,"alpha : f32,");return n.runWebGPUProgram(a,[i],"float32",o)}},Dl={kernelName:ut,backendName:"webgpu",kernelFunc:ro({opType:gs.LESS,dtype:"bool",cpuKernelImpl:Zo})},Ul={kernelName:lt,backendName:"webgpu",kernelFunc:ro({opType:gs.LESS_EQUAL,dtype:"bool",cpuKernelImpl:Qo})};class Wl{constructor(e){this.variableNames=[],this.outputShape=[],this.uniforms="start : f32, step : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e],this.dispatchLayout=hs(this.outputShape),this.dispatch=as(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="linSpace"}getUserCode(){return`\n      ${Qi("index")} {\n        if (index < uniforms.size) {\n          setOutputAtIndex(index, uniforms.start + f32(index) * uniforms.step);\n        }\n      }\n    `}}const Vl={kernelName:ht,backendName:"webgpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:r,stop:i,num:s}=n,o=(i-r)/(s-1),a=new Wl(s),u=[{type:"float32",data:[r]},{type:"float32",data:[o]}];return t.runWebGPUProgram(a,[],"float32",u)}},Gl={kernelName:ct,backendName:"webgpu",kernelFunc:no({opType:Cs.LOG,cpuKernelImpl:Jo})},Hl={kernelName:dt,backendName:"webgpu",kernelFunc:no({opType:Cs.LOG1P})},Kl={kernelName:pt,backendName:"webgpu",kernelFunc:ro({opType:gs.LOGICAL_AND,dtype:"bool"})},Xl={kernelName:ft,backendName:"webgpu",kernelFunc:no({opType:Cs.LOGICAL_NOT})},ql={kernelName:mt,backendName:"webgpu",kernelFunc:ro({opType:gs.LOGICAL_OR})},jl="\n  var powValue = 0.0;\n  let basis = uniforms.bias + uniforms.alpha * sum;\n  if (uniforms.beta == 0.5) {\n    powValue = inverseSqrt(basis);\n  } else if (uniforms.beta == 1.0) {\n    powValue = 1.0 / basis;\n  } else {\n    powValue = exp(log(basis) * (-uniforms.beta));\n  }\n";class Yl{constructor(e){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=hs(this.outputShape),this.dispatch=as(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="lrn"}getUserCode(){return`\n    ${Qi("index")} {\n      if (index < uniforms.size) {\n        let coords = getOutputCoords();\n        let b = coords[0];\n        let r = coords[1];\n        let c = coords[2];\n        let d = coords[3];\n\n        let x = getX(b, r, c, d);\n        var sum = 0.0;\n        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {\n          let idx = d + i;\n          if (idx >= 0 && idx < uniforms.xShape[3]) {\n            let z = getX(b, r, c, idx);\n            sum = sum + z * z;\n          }\n        }\n        ${jl}\n\n        setOutputAtIndex(index, x * powValue);\n      }\n    }\n  `}}class Ql{constructor(e,t){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[256,1,1],this.maxAllowRadius=16,r.assert(t<=this.maxAllowRadius,()=>`Radius must be less than or equal to ${this.maxAllowRadius}, current radius is ${t}`),this.outputShape=e,this.elementsPerWorkgroup=this.workgroupSize[0]-2*this.maxAllowRadius,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=as(this.dispatchLayout,this.outputShape,[this.elementsPerWorkgroup,this.workgroupSize[1],this.workgroupSize[2]]),this.shaderKey="lrn_shared"}getUserCode(){return`\n    var <workgroup>lrnSub: array<f32, ${this.workgroupSize[0]}>;\n    const elementsPerWorkgroup = ${this.elementsPerWorkgroup};\n    const maxAllowRadius = ${this.maxAllowRadius};\n\n    ${Qi()} {\n      let localDepth = i32(localId.x);\n      let workgroupDepth = i32(workgroupId.x) * elementsPerWorkgroup;\n      let xDepth = workgroupDepth + localDepth - maxAllowRadius;\n      let b = i32(globalId.z) / uniforms.xShape[1];\n      let r = i32(globalId.z) - b * uniforms.xShape[1];\n      let c = i32(globalId.y);\n      let d = workgroupDepth + localDepth;\n\n      var x = 0.0;\n      if (xDepth >= 0 && xDepth < uniforms.xShape[3]) {\n        x = getX(b, r, c, xDepth);\n      }\n      lrnSub[localDepth] = x;\n      workgroupBarrier();\n\n      if (localDepth < elementsPerWorkgroup && d < uniforms.outShape[3]) {\n        var sum = 0.0;\n        let index = localDepth + maxAllowRadius;\n        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {\n          let z = lrnSub[index + i];\n          sum = sum + z * z;\n        }\n        ${jl}\n\n        setOutputAtCoords(b, r, c, d, lrnSub[index] * powValue);\n      }\n    } `}}const Zl={kernelName:gt,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{depthRadius:s,bias:o,alpha:a,beta:u}=r;let l;l=s>16?new Yl(i.shape):new Ql(i.shape,s);const h=[{type:"int32",data:[s]},{type:"float32",data:[o]},{type:"float32",data:[a]},{type:"float32",data:[u]}];return n.runWebGPUProgram(l,[i],i.dtype,h)}},Jl={kernelName:xt,backendName:"webgpu",kernelFunc:ro({opType:gs.MAX,cpuKernelImpl:ta})};const eh={kernelName:yt,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{filterSize:s,strides:o,pad:a,dimRoundingMode:u}=r;return Xa(i,z.computePool2DInfo(i.shape,s,o,1,a,u),"max",n)}};const th={kernelName:bt,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{axis:s,keepDims:o}=r;return Pa(i,s,o,"min",n)}},nh={kernelName:wt,backendName:"webgpu",kernelFunc:ro({opType:gs.MIN,cpuKernelImpl:na})};class rh{constructor(e,t,n){this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.map((t,n)=>t[0]+e[n]+t[1]),this.dispatchLayout=hs(this.outputShape),this.dispatch=as(this.dispatchLayout,this.outputShape,this.workgroupSize),this.xShape=e,t.map((e,t)=>{this.uniforms+=` pad${t} : vec2<i32>,`}),this.offset="reflect"===n?0:1,this.shaderKey="mirrorPad_"+n}getUserCode(){const e=this.xShape.length,t=this.xShape.map((e,t)=>`uniforms.pad${t}[0]`).join(","),n=this.xShape.map((t,n)=>`uniforms.pad${n}[0] + uniforms.xShape${e>1?`[${n}]`:""}`).join(","),r=1===e?"start":"start[i]",i=1===e?"end":"end[i]",s=1===e?"outC":"outC[i]",o=ji(e),a=e>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,e):"coords";return`\n      ${Qi("index")} {\n        if (index < uniforms.size) {\n          let start = ${o}(${t});\n          let end = ${o}(${n});\n          var outC = getCoordsFromIndex(index);\n          for (var i = 0; i < ${e}; i = i + 1) {\n            if (${s} < ${r}) {\n              ${s} = ${r} * 2 - ${s} - ${this.offset};\n            } else if(${s} >= ${i}) {\n              ${s} = (${i} - 1) * 2 - ${s} + ${this.offset};\n            }\n          }\n          let coords = outC - start;\n          setOutputAtIndex(index, getX(${a}));\n        }\n      }\n    `}}const ih={kernelName:vt,backendName:"webgpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{paddings:i,mode:s}=t,o=n,a=i.map(e=>({type:"int32",data:[e[0],e[1]]})),u=new rh(r.shape,i,s);return o.runWebGPUProgram(u,[r],r.dtype,a)}},sh={kernelName:kt,backendName:"webgpu",kernelFunc:ro({opType:gs.MOD})};const oh={kernelName:St,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])){const e=n.tensorMap.get(r.dataId),[t,i]=ia(e.values,r.shape,r.dtype);return n.makeTensorInfo(i,r.dtype,t)}const i=new to(r.shape,Cs.NEG);return n.runWebGPUProgram(i,[r],r.dtype)}};const ah={kernelName:It,backendName:"webgpu",kernelFunc:function(e){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:i,scores:s}=t,{maxOutputSize:o,iouThreshold:a,scoreThreshold:u}=r,l=n.readSync(i.dataId),h=n.readSync(s.dataId),{selectedIndices:c}=Ct.nonMaxSuppressionV3Impl(l,h,o,a,u);return n.makeTensorInfo([c.length],"int32",new Int32Array(c))}};const uh={kernelName:Rt,backendName:"webgpu",kernelFunc:function(e){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:i,scores:s}=t,{maxOutputSize:o,iouThreshold:a,scoreThreshold:u,softNmsSigma:l}=r,h=n.readSync(i.dataId),c=n.readSync(s.dataId),d=o,p=a,f=u,m=l,{selectedIndices:g,selectedScores:x}=Ct.nonMaxSuppressionV5Impl(h,c,d,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([x.length],"float32",new Float32Array(x))]}};class lh{constructor(e,t){this.variableNames=["x"],this.uniforms="onValue : f32, offValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,t],this.dispatchLayout=hs(this.outputShape),this.dispatch=as(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="onehot"}getUserCode(){return`\n      ${Qi("index")} {\n        if(index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          setOutputAtIndex(index, mix(uniforms.offValue, uniforms.onValue,\n                                      f32(i32(round(getX(coords.x))) == coords.y)));\n        }\n      }\n    `}}const hh={kernelName:Tt,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{indices:s}=t,{dtype:o,depth:a,onValue:u,offValue:l}=i,h=r.sizeFromShape(s.shape),c=new lh(h,a),d=Hs({inputs:{x:s},backend:n,attrs:{shape:[h]}}),p=[{type:"float32",data:[u]},{type:"float32",data:[l]}],f=n.runWebGPUProgram(c,[d],o,p);n.disposeData(d.dataId);const m=Hs({inputs:{x:f},backend:n,attrs:{shape:[...s.shape,a]}});return n.disposeData(f.dataId),m}};function ch(e){const{inputs:t,backend:n}=e,{x:r}=t;if("complex64"===r.dtype){const e=uu({inputs:{input:r},backend:n}),t=ch({inputs:{x:e},backend:n}),i=gu({inputs:{input:r},backend:n}),s=ch({inputs:{x:i},backend:n}),o=Js({inputs:{real:t,imag:s},backend:n});return n.disposeData(e.dataId),n.disposeData(t.dataId),n.disposeData(i.dataId),n.disposeData(s.dataId),o}return Vs({attrs:{shape:r.shape,dtype:r.dtype,value:"string"===r.dtype?"":0},backend:n})}const dh={kernelName:$t,backendName:"webgpu",kernelFunc:ch};const ph={kernelName:At,backendName:"webgpu",kernelFunc:function e(t){const{inputs:n,backend:r}=t,{x:i}=n;if("string"===i.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===i.dtype){const t=uu({inputs:{input:i},backend:r}),n=e({inputs:{x:t},backend:r}),s=gu({inputs:{input:i},backend:r}),o=ch({inputs:{x:s},backend:r}),a=Js({inputs:{real:n,imag:o},backend:r});return r.disposeData(t.dataId),r.disposeData(n.dataId),r.disposeData(s.dataId),r.disposeData(o.dataId),a}return Vs({attrs:{shape:i.shape,dtype:i.dtype,value:1},backend:r})}};const fh={kernelName:Pt,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{axis:s}=i;if(1===t.length)return hl({inputs:{input:t[0]},backend:n,attrs:{dim:s}});const o=t[0].shape,a=t[0].dtype;t.forEach(e=>{r.assertShapesMatch(o,e.shape,"All tensors passed to stack must have matching shapes"),r.assert(a===e.dtype,()=>"All tensors passed to stack must have matching dtypes")});const u=[],l=bu({inputs:t.map(e=>{const t=hl({inputs:{input:e},backend:n,attrs:{dim:s}});return u.push(t),t}),backend:n,attrs:{axis:s}});return u.forEach(e=>n.disposeData(e.dataId)),l}};class mh{constructor(e,t){this.variableNames=["x"],this.uniforms="constantValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.map((t,n)=>t[0]+e[n]+t[1]),this.dispatchLayout=hs(this.outputShape),this.dispatch=as(this.dispatchLayout,this.outputShape,this.workgroupSize),t.map((e,t)=>{this.uniforms+=` pad${t} : vec2<i32>,`}),this.xShape=e,this.shaderKey="pad"}getUserCode(){const e=this.xShape.length,t=ji(e),n=this.xShape.map((e,t)=>`uniforms.pad${t}[0]`).join(","),r=this.xShape.map((t,n)=>`uniforms.pad${n}[0] + uniforms.xShape${e>1?`[${n}]`:""}`).join(","),i=e>1?`${t}(${n})`:""+n,s=e>1?`${t}(${r})`:""+r,o=e>1?"any(outC < start)":"outC < start",a=e>1?"any(outC >= end)":"outC >= end",u=e>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,e):"coords";return`\n      ${Qi("index")} {\n        if (index < uniforms.size) {\n          let start = ${i};\n          let end = ${s};\n          let outC = getCoordsFromIndex(index);\n\n          if (${o} || ${a}) {\n            setOutputAtIndex(index, uniforms.constantValue);\n          } else {\n            let coords = outC - start;\n            setOutputAtIndex(index, getX(${u}));\n          }\n        }\n      }\n    `}}const gh=e=>{const{inputs:t,backend:n,attrs:i}=e,{x:s}=t,{paddings:o,constantValue:a}=i;if(o.every(e=>r.arraysEqual(e,[0,0])))return Qs({inputs:{x:s},backend:n});if(0===r.sizeFromShape(s.shape)){return Vs({backend:n,attrs:{shape:o.map((e,t)=>e[0]+s.shape[t]+e[1]),value:a,dtype:s.dtype}})}const u=[{type:"float32",data:[a]}];o.map(e=>u.push({type:"int32",data:[e[0],e[1]]}));const l=new mh(s.shape,o);return n.runWebGPUProgram(l,[s],s.dtype,u)},xh={kernelName:zt,backendName:"webgpu",kernelFunc:gh},yh={kernelName:Nt,backendName:"webgpu",kernelFunc:ro({opType:gs.POW})};const bh={kernelName:Mt,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r,alpha:i}=t,s=new Ys(gs.PRELU,r.shape,i.shape);return n.runWebGPUProgram(s,[r,i],"float32")}};const wh={kernelName:Ft,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{axis:s,keepDims:o}=r;return Pa(i,s,o,"prod",n)}},vh={kernelName:Et,backendName:"webgpu",kernelFunc:e=>{const{backend:t,attrs:n}=e,{start:r,stop:i,step:s,dtype:o}=n,a=aa(r,i,s,o);return t.makeTensorInfo([a.length],o,a)}},kh=ro({opType:gs.DIV}),Sh={kernelName:_t,backendName:"webgpu",kernelFunc:kh},Ih={kernelName:Ot,backendName:"webgpu",kernelFunc:no({opType:Cs.RECIPROCAL})},Ch={kernelName:Bt,backendName:"webgpu",kernelFunc:no({opType:Cs.RELU})},Rh={kernelName:Lt,backendName:"webgpu",kernelFunc:no({opType:Cs.RELU6})};class Th{constructor(e,t,n){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, halfPixelCenters : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],t,n,e[3]],this.dispatchLayout=hs(this.outputShape),this.dispatch=as(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="resizeBilinear"}getUserCode(){return`\n      ${Qi("index")} {\n        if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n          let b = coords[0];\n          let d = coords[3];\n          let rc = coords.yz;\n\n          let effectiveInSize = vec2<f32>(\n            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveOutSize = vec2<f32>(\n            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveInputOverOutputRatioRC =\n              effectiveInSize / effectiveOutSize;\n\n          // Fractional source index\n          let sourceFracIndexRC =\n            (vec2<f32>(rc) + vec2<f32>(uniforms.halfPixelCenters)) *\n            effectiveInputOverOutputRatioRC - vec2<f32>(uniforms.halfPixelCenters);\n\n          // Compute the four integer indices.\n          let sourceFloorRC = vec2<i32>(sourceFracIndexRC);\n          let sourceCeilRC = vec2<i32>(\n            min(vec2<f32>(uniforms.xShape.yz) - vec2<f32>(1.0), ceil(sourceFracIndexRC)));\n\n          let topLeft = getX(b, sourceFloorRC.x, sourceFloorRC.y, d);\n          let bottomLeft = getX(b, sourceCeilRC.x, sourceFloorRC.y, d);\n          let topRight = getX(b, sourceFloorRC.x, sourceCeilRC.y, d);\n          let bottomRight = getX(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n          let fracRC = sourceFracIndexRC - vec2<f32>(sourceFloorRC);\n\n          let top = topLeft + (topRight - topLeft) * fracRC.y;\n          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n          let newValue = top + (bottom - top) * fracRC.x;\n\n          setOutputAtIndex(index, newValue);\n        }\n      }\n    `}}const $h={kernelName:Dt,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:i}=t,{alignCorners:s,size:o,halfPixelCenters:a}=r,[u,l]=o,h=[{type:"float32",data:[s&&u>1?1:0,s&&l>1?1:0]},{type:"float32",data:[a?.5:0]}],c=new Th(i.shape,u,l);return n.runWebGPUProgram(c,[i],"float32",h)}};class Ah{constructor(e,t,n,r){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, roundBase : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],t,n,e[3]],this.dispatchLayout=hs(this.outputShape),this.dispatch=as(this.dispatchLayout,this.outputShape,this.workgroupSize),this.halfPixelCenters=r,this.shaderKey="resizeNearest_"+r}getUserCode(){let e;e=this.halfPixelCenters?"max((vec2<f32>(rc) + vec2<f32>(0.5)) * effectiveInputOverOutputRatioRC, vec2<f32>(0.0))":"vec2<f32>(rc) * effectiveInputOverOutputRatioRC";return`\n      ${Qi("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let b = coords[0];\n          let d = coords[3];\n          let rc = coords.yz;\n\n          let effectiveInSize = vec2<f32>(\n            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveOutSize = vec2<f32>(\n            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveInputOverOutputRatioRC =\n              effectiveInSize / effectiveOutSize;\n\n          // Fractional source index\n          let sourceFracIndexRC = ${e};\n\n          // Compute the coordinators of nearest neighbor point.\n          let inputShapeRC = vec2<f32>(f32(uniforms.xShape.y), f32(uniforms.xShape.z));\n          let sourceNearestRC = vec2<i32>(\n            min(inputShapeRC - 1.0, floor(sourceFracIndexRC + uniforms.roundBase)));\n          let newValue = getX(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n          setOutputAtIndex(index, newValue);\n        }\n      }\n    `}}const Ph={kernelName:Ut,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:i}=t,{alignCorners:s,halfPixelCenters:o,size:a}=r,[u,l]=a,h=[{type:"float32",data:[s&&u>1?1:0,s&&l>1?1:0]},{type:"float32",data:[s?.5:0]}],c=new Ah(i.shape,u,l,o);return n.runWebGPUProgram(c,[i],i.dtype,h)}};class zh{constructor(e){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=hs(this.outputShape),this.dispatch=as(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=" axis : vec4<i32>,",this.shaderKey="reverse"}getUserCode(){return`\n      \n      // Using uniform variables as judging conditions, so the function has\n      // coherent execution within all threads.\n      fn getReverseCoords(coords : vec4<i32>) -> vec4<i32> {\n        var reverseCoords = coords;\n        if (uniforms.axis[0] == 1) {\n          reverseCoords[0] = uniforms.xShape[0] - coords[0] - 1;\n        }\n        if (uniforms.axis[1] == 1) {\n          reverseCoords[1] = uniforms.xShape[1] - coords[1] - 1;\n        }\n        if (uniforms.axis[2] == 1) {\n          reverseCoords[2] = uniforms.xShape[2] - coords[2] - 1;\n        }\n        if (uniforms.axis[3] == 1) {\n          reverseCoords[3] = uniforms.xShape[3] - coords[3] - 1;\n        }\n\n        return reverseCoords;\n      }\n    \n      ${Qi("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let reverseCoords = getReverseCoords(coords);\n          setOutputAtIndex(index, getX(reverseCoords[0],\n              reverseCoords[1], reverseCoords[2], reverseCoords[3]));\n        }\n      }\n    `}}const Nh={kernelName:Wt,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{x:s}=t,{dims:o}=i,a=s.shape.length;if(0===a)return Qs({inputs:{x:s},backend:n});const u=s.shape,l=[1,1,1,1];u.forEach((e,t)=>{l[t+4-a]=e});const h=r.parseAxisParam(o,s.shape),c=[0,0,0,0];h.forEach(e=>{c[e+4-a]=1});const d=[{type:"int32",data:c}],p=Hs({inputs:{x:s},backend:n,attrs:{shape:l}}),f=new zh(l),m=n.runWebGPUProgram(f,[p],p.dtype,d);n.disposeData(p.dataId);const g=Hs({inputs:{x:m},backend:n,attrs:{shape:u}});return n.disposeData(m.dataId),g}};class Mh{constructor(e,t){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=hs(this.outputShape),this.dispatch=as(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms="centerX : f32, centerY : f32, sinRadians : f32,\n          cosRadians : f32,",this.shaderKey="rotate",this.outputShape=e,"number"==typeof t?(this.uniforms+=" fillValue : f32,",this.fillSnippet="var outputValue = uniforms.fillValue;",this.shaderKey+="_float"):(this.uniforms+=" fillValue : vec3<f32>,",this.fillSnippet="var outputValue = uniforms.fillValue[coords[3]];",this.shaderKey+="_vec3")}getUserCode(){return`\n        ${Qi("index")} {\n          if (index < uniforms.size) {\n            let coords = getCoordsFromIndex(index);\n            let coordXFloat = (f32(coords[2]) - uniforms.centerX) *\n                uniforms.cosRadians - (f32(coords[1]) - uniforms.centerY) *\n                uniforms.sinRadians;\n            let coordYFloat = (f32(coords[2]) - uniforms.centerX) *\n                uniforms.sinRadians + (f32(coords[1]) - uniforms.centerY) *\n                uniforms.cosRadians;\n            let coordX = i32(round(coordXFloat + uniforms.centerX));\n            let coordY = i32(round(coordYFloat + uniforms.centerY));\n            ${this.fillSnippet}\n            if(coordX >= 0 && coordX < uniforms.xShape[2] && coordY >= 0 &&\n                coordY < uniforms.xShape[1]) {\n              outputValue = getX(coords[0], coordY, coordX, coords[3]);\n            }\n            setOutputAtIndex(index, outputValue);\n          }\n        }\n      `}}const Fh={kernelName:Vt,backendName:"webgpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:r}=e,{radians:i,fillValue:s,center:o}=t,a=n,u=new Mh(r.shape,s),[l,h]=z.getImageCenter(o,r.shape[1],r.shape[2]),c=[{type:"float32",data:[l]},{type:"float32",data:[h]},{type:"float32",data:[Math.sin(i)]},{type:"float32",data:[Math.cos(i)]}];"number"==typeof s?c.push({type:"float32",data:[Number.parseFloat(s.toFixed(2))]}):c.push({type:"float32",data:s});return a.runWebGPUProgram(u,[r],r.dtype,c)}},Eh={kernelName:Gt,backendName:"webgpu",kernelFunc:no({opType:Cs.ROUND})},_h={kernelName:Ht,backendName:"webgpu",kernelFunc:no({opType:Cs.RSQRT,cpuKernelImpl:ua})};class Oh{constructor(e,t,n,r,i,s,o,a=!0){this.variableNames=["updates","indices"],this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=s,this.type=o,this.sumDupeIndices=a,this.dispatchLayout=hs(e),this.dispatch=as(this.dispatchLayout,e,this.workgroupSize),this.sliceDimGreaterThanOne=t>1,this.shaderKey=`scatter_${n}_${r}_${this.sliceDimGreaterThanOne}_${o}_${a}`;const u=ji(i.length);this.uniforms=`sliceDim : i32, strides: ${u}, updatesSize: i32,`,this.updatesRank=r,this.indicesRank=n}getUserCode(){let e="";1===this.indicesRank?e="coords[0]":2===this.indicesRank&&(e="coords[0], j");const t=`getIndices(${e})`,n=this.sliceDimGreaterThanOne?"uniforms.strides[j]":"uniforms.strides";let r="",i="";1===this.dispatchLayout.x.length?(r="flattenedIndex",i="\n      fn getUpdatesCoordsFromFlatIndex(index : i32) -> i32 {\n        return index;\n      }\n      "):2===this.dispatchLayout.x.length&&(r="vec2<i32>(flattenedIndex, coords[1])",i="\n      fn getUpdatesCoordsFromFlatIndex(index : i32) -> vec2<i32> {\n        // N.B. |updates| could be a scalar tensor, conceptually representing a\n        // 2D tensor with all values equal to that. By design, its size must be\n        // the same as |outShape[1]| in one dimension, and |indicesShape[0]|\n        // gives the other.\n        let sliceSize = uniforms.outShape[1];\n        let d0 = index / sliceSize;\n        let d1 = index - d0 * sliceSize;\n        return vec2<i32>(d0, d1);\n      }\n      ");const s=`getUpdates(${Array.from({length:this.updatesRank},(e,t)=>`coords[${t}]`).join(", ")})`;return`\n    ${i}\n      ${Qi("index")} {\n        if (index < uniforms.updatesSize) {\n          let coords = getUpdatesCoordsFromFlatIndex(index);\n          var flattenedIndex = 0;\n          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {\n            let indexInside = i32(round(${t}));\n            flattenedIndex = flattenedIndex + indexInside * ${n};\n          }\n          let updateValue =\n              ${is(this.type,!1)}(${s});\n          let flatIndex = getOutputIndexFromCoords(${r});\n\n          ${this.sumDupeIndices?Xi("&result[flatIndex]","updateValue",this.type):"atomicStore(&result[flatIndex], bitcast<i32>(updateValue));"}\n        }\n      }`}}const Bh={kernelName:Kt,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{indices:s,updates:o}=t,{shape:a}=i,{sliceRank:u,numUpdates:l,sliceSize:h,strides:c,outputSize:d}=z.calculateShapes(o,s,a),p=[d/h,h];if(0===d)return n.makeTensorInfo(a,s.dtype);const f=Hs({inputs:{x:s},backend:n,attrs:{shape:[l,u]}}),m=Hs({inputs:{x:o},backend:n,attrs:{shape:[l,h]}}),g=m.dtype,x=Vs({backend:n,attrs:{shape:p,value:0,dtype:g}}),y=[{type:"int32",data:[u]},{type:"int32",data:c},{type:"int32",data:[r.sizeFromShape(m.shape)]}],b=new Oh(m.shape,u,f.shape.length,m.shape.length,c,p,g),w=n.runWebGPUProgram(b,[m,f],g,y,x),v=Hs({inputs:{x:w},backend:n,attrs:{shape:a}});return n.disposeData(f.dataId),n.disposeData(m.dataId),n.disposeData(w.dataId),v}};class Lh{constructor(e,t){this.outputShape=[],this.variableNames=["sortedSequence","values"],this.uniforms="numInputs : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=hs(this.outputShape),this.dispatch=as(this.dispatchLayout,this.outputShape,this.workgroupSize),this.side=t,this.shaderKey="search_sorted_"+t}getUserCode(){return`\n      fn findBound(batch: i32, value: f32) -> i32 {\n        var left = i32(0);\n        var right = uniforms.numInputs;\n        while (left < right) {\n          var mid = (left + right) / 2;\n          if (getSortedSequence(batch, mid) ${"left"===this.side?"<":"<="} value) {\n            left = mid + 1;\n          } else {\n            right = mid;\n          }\n        }\n        return right;\n      }\n\n      ${Qi("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let value = getValuesByOutputIndex(index);\n          setOutputAtIndexI32(index, findBound(coords[0], value));\n        }\n      }\n    `}}const Dh={kernelName:Xt,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sortedSequence:i,values:s}=t,{side:o}=r,a=new Lh([s.shape[0],s.shape[1]],o),u=[{type:"int32",data:[i.shape[1]]}];return n.runWebGPUProgram(a,[i,s],"int32",u)}};class Uh{constructor(e,t,n){this.variableNames=["c","a","b"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=hs(this.outputShape),this.dispatch=as(this.dispatchLayout,this.outputShape,this.workgroupSize),this.cRank=e,this.rank=n,this.shaderKey="select"}getUserCode(){let e,t;if(this.rank>4)throw Error(`Where for rank ${this.rank} is not yet supported`);if(1===this.rank)t="resRC",e="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[],i=[];for(let e=0;e<this.outputShape.length;e++)i.push(""+n[e]),e<this.cRank&&r.push(""+n[e]);e=r.join(),t=i.join()}return`\n      ${Qi("index")} {\n        if (index < uniforms.size) {\n          let resRC = getCoordsFromIndex(index);\n          let cVal = getC(${e});\n          if (cVal >= 1.0) {\n            setOutputAtIndex(index, getA(${t}));\n          } else {\n            setOutputAtIndex(index, getB(${t}));\n          }\n        }\n      }\n    `}}const Wh={kernelName:qt,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:r,t:i,e:s}=t,o=new Uh(r.shape.length,i.shape,i.shape.length);return n.runWebGPUProgram(o,[r,i,s],W(i.dtype,s.dtype))}},Vh={kernelName:jt,backendName:"webgpu",kernelFunc:no({opType:Cs.SELU})},Gh={kernelName:Yt,backendName:"webgpu",kernelFunc:no({opType:Cs.SIGMOID})},Hh={kernelName:Qt,backendName:"webgpu",kernelFunc:no({opType:Cs.SIGN})},Kh={kernelName:Zt,backendName:"webgpu",kernelFunc:no({opType:Cs.SIN})},Xh={kernelName:Jt,backendName:"webgpu",kernelFunc:no({opType:Cs.SINH})},qh=ro({opType:gs.SUB,cpuKernelImpl:fa,supportsComplex:!0}),jh={kernelName:en,backendName:"webgpu",kernelFunc:qh};const Yh={kernelName:tn,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{logits:s}=t,{dim:o}=i,a=r.parseAxisParam([o],s.shape),u=Va({inputs:{x:s},backend:n,attrs:{reductionIndices:a,keepDims:!1}}),l=z.expandShapeToKeepDim(u.shape,a),h=Hs({inputs:{x:u},backend:n,attrs:{shape:l}}),c=qh({inputs:{a:s,b:h},backend:n}),d=ul({inputs:{x:c},backend:n}),p=nl({inputs:{x:d},backend:n,attrs:{axis:a,keepDims:!1}}),f=Hs({inputs:{x:p},backend:n,attrs:{shape:l}}),m=kh({inputs:{a:d,b:f},backend:n});return n.disposeData(u.dataId),n.disposeData(h.dataId),n.disposeData(c.dataId),n.disposeData(d.dataId),n.disposeData(p.dataId),n.disposeData(f.dataId),m}},Qh={kernelName:nn,backendName:"webgpu",kernelFunc:no({opType:Cs.SOFTPLUS})},Zh={kernelName:rn,backendName:"webgpu",kernelFunc:e=>{const{inputs:t,backend:n,attrs:i}=e,{x:s}=t,{blockShape:o,paddings:a}=i;r.assert(s.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGPU backend not implemented yet");const u=o.reduce((e,t)=>e*t),l=[[0,0]];l.push(...a);for(let e=1+o.length;e<s.shape.length;++e)l.push([0,0]);const h=[],c=gh({inputs:{x:s},backend:n,attrs:{paddings:l,constantValue:0}}),d=z.getReshaped(c.shape,o,u,!1),p=z.getPermuted(d.length,o.length,!1),f=z.getReshapedPermuted(c.shape,o,u,!1),m=Hs({inputs:{x:c},backend:n,attrs:{shape:d}}),g=Ta({inputs:{x:m},backend:n,attrs:{perm:p}}),x=Hs({inputs:{x:g},backend:n,attrs:{shape:f}});return h.push(c),h.push(m),h.push(g),h.forEach(e=>n.disposeData(e.dataId)),x}};class Jh{constructor(e,t){this.variableNames=["A"],this.workgroupSize=[64,1,1],this.size=!0;const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[r]*t[r];this.outputShape=n,this.dispatchLayout=hs(this.outputShape),this.dispatch=as(this.dispatchLayout,this.outputShape,this.workgroupSize),this.rank=this.outputShape.length,this.shaderKey="tile"}getUserCode(){const e=function(e,t=""){if(e>=5)throw Error(`Tile for rank ${e} is not yet supported`);if(1===e)return`(resRC % ${t}aShape)`;const n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let i=0;i<e;i++)r.push(`(${n[i]} % ${t}aShape[${i}])`);return r.join()}(this.rank,"uniforms.");return`\n      ${Qi("index")} {\n        if (index < uniforms.size) {\n          let resRC = getCoordsFromIndex(index);\n          setOutputAtIndex(index, getA(${e}));\n        }\n      }\n    `}}function ec(e){const{inputs:t,backend:n,attrs:i}=e,{x:s}=t,{reps:o}=i;if(n.shouldExecuteOnCPU([s])||"string"===s.dtype||s.shape.length>=5){const e=n.readSync(s.dataId),t="string"===s.dtype?e.map(e=>r.decodeString(e)):e,i=F(s.shape,s.dtype,t),a=ma(i,o);return n.makeTensorInfo(a.shape,a.dtype,a.values)}const a=new Jh(s.shape,o);return n.runWebGPUProgram(a,[s],s.dtype)}const tc={kernelName:sn,backendName:"webgpu",kernelFunc:ec};const nc={kernelName:on,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{sparseIndices:s,sparseValues:o,defaultValue:a}=t,{outputShape:u}=i,{sliceRank:l,numUpdates:h,sliceSize:c,strides:d,outputSize:p}=z.calculateShapes(o,s,u);if("string"===o.dtype){const e=n.bufferSync(s),t=n.bufferSync(o),i=r.decodeString(n.readSync(a.dataId)[0]),f=la(e,t,u,p,c,h,l,d,i,!1);return n.makeTensorInfo(u,f.dtype,f.values)}const f=[p/c,c],m=Hs({inputs:{x:s},backend:n,attrs:{shape:[h,l]}}),g=o.shape.length?Hs({inputs:{x:o},backend:n,attrs:{shape:[h,c]}}):Qs({inputs:{x:o},backend:n}),x=g.dtype,y=n.makeTensorInfo([],x,r.makeZerosTypedArray(1,x)),b=Hs({inputs:{x:a},backend:n,attrs:{shape:Array(f.length).fill(1)}}),w=ec({inputs:{x:b},backend:n,attrs:{reps:f}}),v=[{type:"int32",data:[l]},{type:"int32",data:d},{type:"int32",data:[r.sizeFromShape([h,c])]}];switch(h){case 0:break;case 1:{const e=new Oh([h,c],l,m.shape.length,g.shape.length,d,f,x,!1);n.runWebGPUProgram(e,[g,m],x,v,w)}break;default:{const e=new Oh([h,c],l,m.shape.length,y.shape.length,d,f,x,!1);n.runWebGPUProgram(e,[y,m],x,v,w)}{const e=new Oh([h,c],l,m.shape.length,g.shape.length,d,f,x);n.runWebGPUProgram(e,[g,m],x,v,w)}}const k=Hs({inputs:{x:w},backend:n,attrs:{shape:u}});return n.disposeData(m.dataId),n.disposeData(g.dataId),n.disposeData(b.dataId),n.disposeData(y.dataId),n.disposeData(w.dataId),k}};const rc={kernelName:an,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{x:s}=t,{numOrSizeSplits:o,axis:a}=i,u=r.parseAxisParam(a,s.shape)[0],l=z.prepareSplitSize(s,o,u),h=s.shape.length,c=new Array(h).fill(0),d=s.shape.slice();return l.map(e=>{const t=[...d];t[u]=e;const r=eu({inputs:{x:s},backend:n,attrs:{begin:c,size:t}});return c[u]+=e,r})}},ic={kernelName:un,backendName:"webgpu",kernelFunc:no({opType:Cs.SQRT})},sc={kernelName:ln,backendName:"webgpu",kernelFunc:({inputs:e,backend:t})=>{const{x:n}=e,r=t,i=new to(n.shape,Cs.SQUARE);return r.runWebGPUProgram(i,[n],n.dtype)}},oc={kernelName:hn,backendName:"webgpu",kernelFunc:ro({opType:gs.SQUARED_DIFFERENCE})};const ac={kernelName:cn,backendName:"webgpu",kernelFunc:function({inputs:e,attrs:t,backend:n}){const{x:r}=e,i=new to(r.shape,Cs.STEP,"stepAlpha : f32,"),s=[{type:"float32",data:[t.alpha]}];return n.runWebGPUProgram(i,[r],r.dtype,s)}};class uc{constructor(e){this.variableNames=["x"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=hs(this.outputShape),this.dispatch=as(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]);const t=ji(this.outputShape.length);this.uniforms=`begin : ${t},  strides : ${t}, `,this.shaderKey="stridedSlice"}getUserCode(){let e="";if(1===this.outputShape.length)e="coords * uniforms.strides + uniforms.begin";else{let t=0;e=this.outputShape.map((e,n)=>(t++,1===this.outputShape.length?`coords * uniforms.strides[${n}] + uniforms.begin[${n}]`:`coords[${t-1}] * uniforms.strides[${n}] + uniforms.begin[${n}]`)).join(",")}return`\n       ${Qi("index")} {\n         if (index < uniforms.size) {\n           let coords = getCoordsFromIndex(index);\n           setOutputAtIndex(index, getX(${e}));\n         }\n       }\n     `}}const lc={kernelName:dn,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{x:s}=t,{begin:o,end:a,strides:u,beginMask:l,endMask:h,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:p}=i,{finalShapeSparse:f,finalShape:m,isIdentity:g,sliceDim0:x,isSimpleSlice:y,begin:b,end:w,strides:v}=G.sliceInfo(s.shape,o,a,u,l,h,c,d,p);let k;if(g)k=Hs({inputs:{x:s},backend:n,attrs:{shape:m}});else if(x||y){r.assert(s.shape.length>=1,()=>"Input must have rank at least 1, got: "+s.shape.length);const e=G.computeOutShape(b,w,v),t=eu({inputs:{x:s},backend:n,attrs:{begin:b,size:e}});k=Hs({inputs:{x:t},backend:n,attrs:{shape:m}}),n.disposeData(t.dataId)}else{if(n.shouldExecuteOnCPU([s])){const e=n.readSync(s.dataId),t=F(s.shape,s.dtype,e),r=da(f,t,v,b);k=n.makeTensorInfo(m,s.dtype,r.values)}else{const e=new uc(f),t=[{type:"int32",data:b},{type:"int32",data:v}],r=n.runWebGPUProgram(e,[s],s.dtype,t);k=Hs({inputs:{x:r},backend:n,attrs:{shape:m}}),n.disposeData(r.dataId)}}return k}};const hc={kernelName:pn,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{separator:i,nGramWidths:s,leftPad:o,rightPad:a,padWidth:u,preserveShortSequences:l}=r,{data:h,dataSplits:c}=t,d=n.readSync(h.dataId),p=n.readSync(c.dataId),[f,m]=pa(d,p,i,s,o,a,u,l);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(c.shape,"int32",m)]}},cc={kernelName:fn,backendName:"webgpu",kernelFunc:no({opType:Cs.TAN})},dc={kernelName:mn,backendName:"webgpu",kernelFunc:no({opType:Cs.TANH})};class pc{constructor(e){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=hs(this.outputShape),this.dispatch=as(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms="inputSize : i32, firstPass : i32, negativeInf : f32,\n        dir : i32, inc : i32,",this.shaderKey="swap"}getUserCode(){return`\n        ${Qi("index")} {\n          if (index < uniforms.size) {\n            let outC = getCoordsFromIndex(index);\n            let batch = outC[0];\n            let elemIdx = outC[1];\n            // We compare elements pair-wise within a group of size 2 * inc.\n            // The comparing rule for each group alternates between ascending\n            // and descending. Within each group, we compare each pair at\n            // positions i and i+inc. To decide whether an element at position i\n            // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n            // inc, it is in the first half of the group, we denote it as x0,\n            // otherwise we denote it as x1.\n            // For example, as shown in the Bitonic top K paper referenced\n            // above, Figure5(a) shows that element[1] is in the second half of\n            // the group when group size is 2, but it is in the first half of\n            // the group when group size is 4.\n            let isFirstInPair = elemIdx % (2 * uniforms.inc) < uniforms.inc;\n            var i = 0;\n            if (isFirstInPair) {\n              i = elemIdx;\n            } else {\n              i = elemIdx - uniforms.inc;\n            }\n\n            var i0 = 0;\n            if (uniforms.firstPass == 1) {\n              i0 = i;\n            } else {\n              i0 = i32(getIndices(batch, i));\n            }\n\n            var i1 = 0;\n            if (uniforms.firstPass == 1) {\n              i1 = i + uniforms.inc;\n            } else {\n              i1 = i32(getIndices(batch, i + uniforms.inc));\n            }\n\n            var x0 = f32(0.0);\n            var x1 = f32(0.0);\n            if (i0 < uniforms.inputSize) {\n              x0 = getX(batch, i0);\n            } else {\n              x0 = uniforms.negativeInf;\n            }\n            if (i1 < uniforms.inputSize) {\n              x1 = getX(batch, i1);\n            } else {\n              x1 = uniforms.negativeInf;\n            }\n\n            let reverse = elemIdx % (2 * uniforms.dir) >= uniforms.dir;\n            let isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n            if (reverse == isGreater) {\n              // Elements in opposite order of direction\n              let iTemp = i0;\n              i0 = i1;\n              i1 = iTemp;\n            }\n            if (isFirstInPair) {\n              setOutputAtIndex(index, f32(i0));\n            } else {\n              setOutputAtIndex(index, f32(i1));\n            }\n          }\n        }\n      `}}class fc{constructor(e){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=hs(this.outputShape),this.dispatch=as(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms="inputSize : i32, firstPass : i32, k : i32,",this.shaderKey="merge"}getUserCode(){return`\n        ${Qi("index")} {\n          if (index < uniforms.size) {\n            let outC = getCoordsFromIndex(index);\n            let batch = outC[0];\n            let elemIdx = outC[1];\n            // The output size is half of the previous size.\n            // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _\n            // (k=4), we only need to output the indices at positions |, the\n            // indices at positions _ can be thrown away, see Figure5(b) After\n            // Phase 2 (Merge phase) in the Bitonic Top K paper referenced\n            // above.\n            // For example, the paper shows we only need to output the orange\n            // bars. The output sequence should look like this | | | | | | | |.\n            // Because the sequence is halved, to map the output index back to\n            // the previous sequence to find the corresponding value, we need\n            // to double the index. When we double the index, we basically\n            // interpolate a position, so 2i looks like\n            // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k\n            // position of each 2k positions by - elemIdx % k. E.g. for output\n            // at index 4,5,6,7, we want to get the corresponding element at\n            // original index 8,9,10,11, for output at index 8,9,10,11,\n            // we want to get the corresponding element at original index\n            // 16,17,18,19, so on and so forth.\n\n            var i = 0;\n            if (elemIdx < uniforms.k) {\n              i = elemIdx;\n            } else {\n              i = elemIdx * 2 - elemIdx % uniforms.k;\n            }\n            var i0 = 0;\n            if (uniforms.firstPass == 1) {\n              i0 = i;\n            } else {\n              i0 = i32(getIndices(batch, i));\n            }\n            var i1 = 0;\n            if (uniforms.firstPass == 1) {\n              i1 = i + uniforms.k;\n            } else {\n              i1 = i32(getIndices(batch, i + uniforms.k));\n            }\n\n            let x0 = getX(batch, i0);\n            var x1 = f32(0.0);\n            if (i1 < uniforms.inputSize) {\n              x1 = getX(batch, i1);\n            } else {\n              x1 = x0;\n            }\n\n            if (x0 >= x1) {\n              setOutputAtIndex(index, f32(i0));\n            } else {\n              setOutputAtIndex(index, f32(i1));\n            }\n          }\n        }\n      `}}function mc(e,t){null!==t&&e.disposeData(t.dataId)}function gc(e){let t=1;for(;t<e;)t*=2;return t}const xc={kernelName:gn,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{x:s}=t,{k:o,sorted:a}=i,u=s.shape,l=u[u.length-1];if(n.shouldExecuteOnCPU([s])){const e=n.readSync(s.dataId),[t,r]=ga(e,u,s.dtype,o,a);return[n.makeTensorInfo(t.shape,t.dtype,t.values),n.makeTensorInfo(r.shape,r.dtype,r.values)]}if(0===o)return u[u.length-1]=0,[n.makeTensorInfo(u,s.dtype,[]),n.makeTensorInfo(u,"int32",[])];if(1===l)return[s,Vs({attrs:{shape:u,dtype:"int32",value:0},backend:n})];const h=r.sizeFromShape(u)/l,c=Hs({inputs:{x:s},attrs:{shape:[h,l]},backend:n}),d=gc(o),p=gc(l);let f=null;const m=()=>null===f?[c,c]:[c,f],g=(e,t,r)=>{const i=m(),s=new pc(r),o=[{type:"int32",data:[l]},{type:"int32",data:[null===f?1:0]},{type:"float32",data:[Number.NEGATIVE_INFINITY]},{type:"int32",data:[e]},{type:"int32",data:[t]}],a=f;f=n.runWebGPUProgram(s,i,"int32",o),mc(n,a)};for(let e=1;e<d;e*=2){const t=2*e;for(let n=e;n>=1;n/=2)g(t,n,[h,p])}for(let e=p;e>d;e/=2){const t=m(),r=new fc([h,e/2]),i=[{type:"int32",data:[l]},{type:"int32",data:[null===f?1:0]},{type:"int32",data:[d]}],s=f;f=n.runWebGPUProgram(r,t,"int32",i),mc(n,s);const o=d/2,a=2*o;for(let e=o;e>=1;e/=2)g(a,e,f.shape)}let x=f;f=eu({inputs:{x:f},backend:n,attrs:{begin:0,size:[h,o]}}),mc(n,x);let y=zl({inputs:{x:c,indices:f},backend:n,attrs:{axis:1,batchDims:1}});mc(n,c);const b=u.slice(0,-1);b.push(o),x=f,f=Hs({inputs:{x:f},attrs:{shape:b},backend:n}),mc(n,x);const w=y;return y=Hs({inputs:{x:y},attrs:{shape:b},backend:n}),mc(n,w),[y,f]}};class yc{constructor(e){this.variableNames=["Image","Transforms"],this.uniforms="interpolationModeId : i32, fillModeId : i32, fillValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=hs(this.outputShape),this.dispatch=as(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="transform"}getUserCode(){return`\n          fn mapCoord(outCoord : f32, len : f32) -> f32{\n            var inCoord = outCoord;\n            if(uniforms.fillModeId == 2) {\n              if (inCoord < 0.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz2 = 2.0 * len;\n                  if (inCoord < sz2) {\n                    inCoord = sz2 * f32(i32(f32(-inCoord / sz2))) +\n                    inCoord;\n                  }\n                  if (inCoord < -len) {\n                    inCoord = inCoord + sz2;\n                  } else {\n                    inCoord = -inCoord - 1.0;\n                  }\n                }\n              } else if (inCoord > len - 1.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz2 = 2.0 * len;\n                  inCoord = inCoord - sz2 * f32(i32(f32(inCoord / sz2)));\n                  if (inCoord >= len) {\n                    inCoord = sz2 - inCoord - 1.0;\n                  }\n                }\n              }\n              return clamp(inCoord, 0.0, len - 1.0);\n            } else if (uniforms.fillModeId == 3) {\n              if (inCoord < 0.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz = len - 1.0;\n                  inCoord = inCoord + len * (f32(i32(f32(-inCoord / sz))) + 1.0);\n                }\n              } else if (inCoord > len - 1.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz = len - 1.0;\n                  inCoord = inCoord - len * f32(i32(f32(inCoord / sz)));\n                }\n              }\n              return clamp(inCoord, 0.0, len - 1.0);\n            } else if (uniforms.fillModeId == 4) {\n              return clamp(outCoord, 0.0, len - 1.0);\n            }\n            return outCoord;\n          }\n          fn readWithFillValue(batch : i32, coordY : i32, coordX : i32,\n            channel : i32) -> f32 {\n            var outputValue : f32;\n            if (0 <= coordY && coordY < uniforms.imageShape[1] && 0 <= coordX && coordX < uniforms.imageShape[2]) {\n                outputValue = getImage(batch, coordY, coordX, channel);\n            } else {\n              outputValue = uniforms.fillValue;\n            }\n            return outputValue;\n          }\n\n          ${Qi("index")} {\n            if (index < uniforms.size) {\n              let coords = getCoordsFromIndex(index);\n              var outputValue : f32;\n              let batch = coords[0];\n              let x = coords[2];\n              let y = coords[1];\n              let channel = coords[3];\n              let xf = f32(x);\n              let yf = f32(y);\n              let a1 = getTransforms(batch, 0);\n              let a2 = getTransforms(batch, 1);\n              let a3 = getTransforms(batch, 2);\n              let b1 = getTransforms(batch, 3);\n              let b2 = getTransforms(batch, 4);\n              let b3 = getTransforms(batch, 5);\n              let c1 = getTransforms(batch, 6);\n              let c2 = getTransforms(batch, 7);\n              let projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = uniforms.fillValue;\n              } else {\n                let inX = (a1 * xf + a2 * yf + a3) / projection;\n                let inY = (b1 * xf + b2 * yf + b3) / projection;\n                let mapX = mapCoord(inX, f32(uniforms.imageShape[2]));\n                let mapY = mapCoord(inY, f32(uniforms.imageShape[1]));\n\n                if (uniforms.interpolationModeId == 1) {\n                  let coordY = i32(round(mapY));\n                  let coordX = i32(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  let yFloor = floor(mapY);\n                  let xFloor = floor(mapX);\n                  let yCeil = yFloor + 1.0;\n                  let xCeil = xFloor + 1.0;\n                  let valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, i32(yFloor), i32(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, i32(yFloor), i32(xCeil), channel);\n                  let valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, i32(yCeil), i32(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, i32(yCeil), i32(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutputAtIndex(index, outputValue);\n            }\n          }\n        `}}const bc=[qs,ba,wa,va,ka,Ia,za,Na,Fa,Ea,_a,Oa,Ba,La,Da,qa,Ya,Qa,nu,su,hu,cu,fu,eo,wu,Ru,Au,zu,Nu,Mu,Eu,Uu,Wu,Vu,Hu,ju,Qu,Ju,il,sl,ol,al,ll,cl,dl,ml,Gs,xl,vl,yl,bl,Cl,Rl,Tl,Al,Nl,Ml,Fl,Zs,El,xu,_l,Ol,Bl,Ll,Dl,Ul,Vl,Hl,Gl,Kl,Xl,ql,Zl,Ga,Jl,eh,Ka,th,nh,ih,sh,tl,oh,ah,uh,au,hh,ph,fh,xh,yh,bh,wh,vh,lu,Sh,Ih,Ch,Rh,Ks,$h,Ph,Nh,Fh,Eh,_h,Bh,Dh,Wh,Vh,Gh,Hh,Kh,Xh,tu,ac,lc,hc,Yh,Qh,Zh,nc,rc,ic,sc,oc,jh,rl,cc,dc,tc,xc,{kernelName:xn,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{image:i,transforms:s}=t,{interpolation:o,fillMode:a,fillValue:u,outputShape:l}=r,[h,c,d,p]=i.shape,[f,m]=null!=l?l:[c,d],g=new yc([h,f,m,p]),x="nearest"===o?1:2;let y;switch(a){case"constant":y=1;break;case"reflect":y=2;break;case"wrap":y=3;break;case"nearest":y=4;break;default:y=1}const b=[{type:"int32",data:[x]},{type:"int32",data:[y]},{type:"float32",data:[u]}];return n.runWebGPUProgram(g,[i,s],"float32",b)}},$a,{kernelName:yn,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{value:i}=t;let{axis:s}=r;s<0&&(s+=i.shape.length);const o=i,a=o.shape.length,u=i.shape[s],l=new Array(a-1);let h=0;for(let e=0;e<a;e++)e!==s&&(l[h++]=o.shape[e]);const c=[],d=new Array(a).fill(0),p=o.shape.slice();p[s]=1;const f=new Array(u);for(let e=0;e<f.length;e++){d[s]=e;const t=eu({inputs:{x:o},backend:n,attrs:{begin:d,size:p}}),r=Hs({inputs:{x:t},backend:n,attrs:{shape:l}});f[e]=r,c.push(t)}return c.forEach(e=>n.disposeData(e.dataId)),f}},dh];for(const e of bc)bn(e);function wc(){for(var e,t=[],n=0;n<arguments.length;n++)t[n]=arguments[n];switch(t.length){case 0:e="fn main() ";break;case 1:e="fn main(".concat(t[0]," : i32)");break;default:throw Error("Unreachable")}return e}var vc=function(){function e(e){this.variableNames=["A","B"],this.size=!0;this.workgroupSize=[32,1,1],this.outputShape=[e[0],1],this.dispatchLayout=hs(this.outputShape),this.dispatch=as(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="getpointsConfidenceOp"}return e.prototype.getUserCode=function(){return"\n        ".concat(wc("index")," {\n          if (index < uniforms.size) {\n            let y = B[index * 2];\n            let x = B[index * 2 + 1];\n            let outIndex = y * uniforms.aShape.x * uniforms.aShape.z + x * uniforms.aShape.z + index;\n            result[index] = A[outIndex];\n          }\n        }\n        ")},e}();function kc(e,t){if(w()instanceof ms)return function(e,t){var n=w(),r=new vc(t.shape),i=n.runWebGPUProgram(r,[e,t],"float32");return g().makeTensorFromTensorInfo(i)}(e,t);throw new Error("getPointsConfidenceWebGPU is not supported in this backend!")}var Sc=function(){function e(e){if(this.variableNames=["A","B"],this.size=!0,this.supportedLastDimension=2,2!==e.length||e[1]!==this.supportedLastDimension)throw new Error("GetOffsetVectorsProgram only supports shape of [x, ".concat(this.supportedLastDimension,"], but current shape is ").concat(e));this.workgroupSize=[32,1,1],this.outputShape=e;var t=[e[0],1];this.dispatchLayout=hs(t),this.dispatch=as(this.dispatchLayout,t,this.workgroupSize),this.shaderKey="GetOffsetVectors"}return e.prototype.getUserCode=function(){return"\n    fn getOffsetPoint(y: i32, x: i32, index: i32) -> vec2<i32> {\n      let outIndexY = y * uniforms.bShape.x * uniforms.bShape.y + x * uniforms.bShape.y + index;\n      let outIndexX = outIndexY + uniforms.bShape.z;\n      let outY = i32(B[outIndexY]);\n      let outX = i32(B[outIndexX]);\n      return vec2<i32>(outY, outX);\n    }\n\n    ".concat(wc("index")," {\n      if (index < uniforms.size) {\n        let indexY = index * ").concat(this.supportedLastDimension,";\n        let indexX = indexY + 1;\n        let heatmapY = A[indexY];\n        let heatmapX = A[indexX];\n        let out = getOffsetPoint(i32(heatmapY), i32(heatmapX), index);\n        result[indexY] = f32(out[0]);\n        result[indexX] = f32(out[1]);\n      }\n    }\n    ")},e}();function Ic(e,t){if(w()instanceof ms)return function(e,t){var n=w(),r=new Sc(e.shape),i=n.runWebGPUProgram(r,[e,t],"float32");return g().makeTensorFromTensorInfo(i)}(e,t);throw new Error("getOffsetVectorsGPU is not supported in this backend!")}function Cc(e){var t=e.shape,n=t[0],r=t[1],s=t[2];return i((function(){var t,a,u=I(e,[n*r,s]),h=vn(u,0),c=l(v(h,wn(r,"int32")),1),d=l((t=h,a=r,i((function(){var e=v(t,wn(a,"int32"));return x(t,o(e,wn(a,"int32")))}))),1);return S([c,d],1)}))}function Rc(e,t,n){return i((function(){var r=function(e,t){for(var n=[],r=0;r<An.length;r++){var i=e.get(r,0).valueOf(),s=e.get(r,1).valueOf(),o=Tc(i,s,r,t),u=o.x,l=o.y;n.push(l),n.push(u)}return a(n,[An.length,2])}(e,n);return s(h(o(e.toTensor(),wn(t,"int32")),"float32"),r)}))}function Tc(e,t,n,r){return{y:r.get(e,t,n),x:r.get(e,t,n+An.length)}}function $c(e,t,n){return Rn(this,void 0,void 0,(function(){var r,i,s,o,a,u,l,h,c,d;return Tn(this,(function(p){switch(p.label){case 0:return r=0,i=Cc(e),[4,Promise.all([e.buffer(),t.buffer(),i.buffer()])];case 1:return s=p.sent(),o=s[0],a=s[1],u=s[2],[4,(l=Rc(u,n,a)).buffer()];case 2:return h=p.sent(),c=Array.from(function(e,t){for(var n=t.shape[0],r=new Float32Array(n),i=0;i<n;i++){var s=t.get(i,0),o=t.get(i,1);r[i]=e.get(s,o,i)}return r}(o,u)),d=c.map((function(e,t){return r+=e,{y:h.get(t,0),x:h.get(t,1),score:e,name:An[t]}})),i.dispose(),l.dispose(),[2,{keypoints:d,score:r/d.length}]}}))}))}function Ac(e,t,n){return Rn(this,void 0,void 0,(function(){var r,a,u;return Tn(this,(function(l){return r=Cc(e),a=function(e,t,n){return i((function(){var r=Ic(e,n);return s(h(o(e,wn(t,"int32")),"float32"),r)}))}(r,n,t),u=kc(e,r),[2,[a,u]]}))}))}function Pc(e,t){return(e-1)%t==0}var zc="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/mobilenet/",Nc="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/resnet50/";function Mc(e,t){return function(e,t){return(e-1)%t==0}(e,t)?e:Math.floor(e/t)*t+1}var Fc=function(){function e(e,t){this.posenetModel=e;var n=this.posenetModel.inputs[0].shape;r.assert(-1===n[1]&&-1===n[2],(function(){return"Input shape [".concat(n[1],", ").concat(n[2],"] ")+"must both be equal to or -1"}));var i,s,o=(i=t.inputResolution,s=t.outputStride,{height:Mc(i.height,s),width:Mc(i.width,s)});!function(e){r.assert(mi.indexOf(e)>=0,(function(){return"outputStride of ".concat(e," is invalid. ")+"It must be either 8 or 16."}))}(t.outputStride),function(e,t){r.assert(Pc(e.height,t),(function(){return"height of ".concat(e.height," is invalid for output stride ")+"".concat(t,".")})),r.assert(Pc(e.width,t),(function(){return"width of ".concat(e.width," is invalid for output stride ")+"".concat(t,".")}))}(o,t.outputStride),this.inputResolution=o,this.outputStride=t.outputStride,this.architecture=t.architecture}return e.prototype.estimatePoses=function(e,t){return void 0===t&&(t=yi),Rn(this,void 0,void 0,(function(){return Tn(this,(function(n){return[2,this.estimatePosesGPU(e,t,!1)]}))}))},e.prototype.estimatePosesGPU=function(e,t,n){return void 0===t&&(t=yi),void 0===n&&(n=!1),Rn(this,void 0,void 0,(function(){var r,i,o,a,u,l,h,c,f,m,g,x,y,b,w,v,k,S;return Tn(this,(function(I){switch(I.label){case 0:return r=function(e){var t=e;if(null==t.maxPoses&&(t.maxPoses=1),t.maxPoses<=0)throw new Error("Invalid maxPoses ".concat(t.maxPoses,". Should be > 0."));if(t.maxPoses>1){if((t=Cn(Cn({},bi),t)).scoreThreshold<0||t.scoreThreshold>1)throw new Error("Invalid scoreThreshold ".concat(t.scoreThreshold,". ")+"Should be in range [0.0, 1.0]");if(t.nmsRadius<=0)throw new Error("Invalid nmsRadius ".concat(t.nmsRadius,"."))}return t}(t),null==e?[2,n?[[],[]]:[]]:(this.maxPoses=r.maxPoses,i=nr(e,{outputTensorSize:this.inputResolution,keepAspectRatio:!0,borderMode:"replicate"}),o=i.imageTensor,a=i.padding,u="ResNet50"===this.architecture?s(o,wi):tr(o,[-1,1]),l=this.posenetModel.predict(u),"ResNet50"===this.architecture?(h=d(l[2],[0]),c=d(l[3],[0]),f=d(l[0],[0]),m=d(l[1],[0])):(h=d(l[0],[0]),c=d(l[1],[0]),f=d(l[2],[0]),m=d(l[3],[0])),g=R(c),1!==this.maxPoses?[3,5]:n?[4,Ac(g,h,this.outputStride)]:[3,2]);case 1:return y=I.sent(),w=y[0],b=y[1],x=[w,b],[3,4];case 2:return[4,$c(g,h,this.outputStride)];case 3:w=I.sent(),x=[w],I.label=4;case 4:return[3,7];case 5:if(n)throw new Error("GPU renderer only supports single pose!");return[4,Bi(g,h,f,m,this.outputStride,this.maxPoses,r.scoreThreshold,r.nmsRadius)];case 6:x=I.sent(),I.label=7;case 7:if(n){if(!0===r.flipHorizontal)throw new Error("flipHorizontal is not supported!");v=this.getCanvasInfo(Hn(e),this.inputResolution,a)}else S=Hn(e),k=function(e,t,n,r){var i=t.height,s=t.width,o=i/(n.height*(1-r.top-r.bottom)),a=s/(n.width*(1-r.left-r.right)),u=-r.top*n.height,l=-r.left*n.width;if(1===a&&1===o&&0===u&&0===l)return e;for(var h=0,c=e;h<c.length;h++)for(var d=0,p=c[h].keypoints;d<p.length;d++){var f=p[d];f.x=(f.x+l)*a,f.y=(f.y+u)*o}return e}(x,S,this.inputResolution,a),r.flipHorizontal&&(k=function(e,t){for(var n=0,r=e;n<r.length;n++)for(var i=0,s=r[n].keypoints;i<s.length;i++){var o=s[i];o.x=t.width-1-o.x}return e}(k,S));return o.dispose(),u.dispose(),p(l),h.dispose(),c.dispose(),f.dispose(),m.dispose(),g.dispose(),[2,n?[x,v]:k]}}))}))},e.prototype.getCanvasInfo=function(e,t,n){var r=e.height,i=e.width,s=r/(t.height*(1-n.top-n.bottom)),o=i/(t.width*(1-n.left-n.right)),a=-n.top*t.height;return[-n.left*t.width,a,o,s,e.width,e.height]},e.prototype.dispose=function(){this.posenetModel.dispose()},e.prototype.reset=function(){},e}();function Ec(e){return void 0===e&&(e=di),Rn(this,void 0,void 0,(function(){var t,n,r,i,s;return Tn(this,(function(o){switch(o.label){case 0:return"ResNet50"!==(t=function(e){var t=e||di;if(null==t.architecture&&(t.architecture="MobileNetV1"),pi.indexOf(t.architecture)<0)throw new Error("Invalid architecture ".concat(t.architecture,". ")+"Should be one of ".concat(pi));if(null==t.inputResolution&&(t.inputResolution={height:257,width:257}),null==t.outputStride&&(t.outputStride=16),fi[t.architecture].indexOf(t.outputStride)<0)throw new Error("Invalid outputStride ".concat(t.outputStride,". ")+"Should be one of ".concat(fi[t.architecture]," ")+"for architecture ".concat(t.architecture,"."));if(null==t.multiplier&&(t.multiplier=1),gi[t.architecture].indexOf(t.multiplier)<0)throw new Error("Invalid multiplier ".concat(t.multiplier,". ")+"Should be one of ".concat(gi[t.architecture]," ")+"for architecture ".concat(t.architecture,"."));if(null==t.quantBytes&&(t.quantBytes=4),xi.indexOf(t.quantBytes)<0)throw new Error("Invalid quantBytes ".concat(t.quantBytes,". ")+"Should be one of ".concat(xi," ")+"for architecture ".concat(t.architecture,"."));if("MobileNetV1"===t.architecture&&32===t.outputStride&&1!==t.multiplier)throw new Error("When using an output stride of 32, you must select 1 as the multiplier.");return t}(e)).architecture?[3,2]:(a=t.outputStride,u=t.quantBytes,l="model-stride".concat(a,".json"),n=4===u?Nc+"float/"+l:Nc+"quant".concat(u,"/")+l,[4,kn(t.modelUrl||n)]);case 1:return r=o.sent(),[2,new Fc(r,t)];case 2:return i=function(e,t,n){var r={1:"100",.75:"075",.5:"050"},i="model-stride".concat(e,".json");return 4===n?zc+"float/".concat(r[t],"/")+i:zc+"quant".concat(n,"/").concat(r[t],"/")+i}(t.outputStride,t.multiplier,t.quantBytes),[4,kn(t.modelUrl||i)];case 3:return s=o.sent(),[2,new Fc(s,t)]}var a,u,l}))}))}function _c(e,t){return Rn(this,void 0,void 0,(function(){var n,r;return Tn(this,(function(i){switch(e){case qr.PoseNet:return[2,Ec(t)];case qr.BlazePose:if(r=void 0,null!=(n=t)){if("tfjs"===n.runtime)return[2,Kr(t)];if("mediapipe"===n.runtime)return[2,Gn(t)];r=n.runtime}throw new Error("Expect modelConfig.runtime to be either 'tfjs' "+"or 'mediapipe', but got ".concat(r));case qr.MoveNet:return[2,ci(t)];default:throw new Error("".concat(e," is not a supported model name."))}}))}))}var Oc={keypointsToNormalizedKeypoints:yr},Bc={modelType:{SINGLEPOSE_LIGHTNING:"SinglePose.Lightning",SINGLEPOSE_THUNDER:"SinglePose.Thunder",MULTIPOSE_LIGHTNING:"MultiPose.Lightning"}};export{qr as SupportedModels,Xr as TrackerType,Oc as calculators,_c as createDetector,Bc as movenet,Jr as util};
